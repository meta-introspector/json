(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module de.
  Module  Deserializer.
  Section Deserializer.
    Context (R : Set).
    
    Record t : Set := {
      read : R;
      scratch : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A;
      remaining_depth : u8.t;
    }.
    
    Definition Get_read :=
      Ref.map (fun α => Some α.(read)) (fun β α => Some (α <| read := β |>)).
    Definition Get_scratch :=
      Ref.map
        (fun α => Some α.(scratch))
        (fun β α => Some (α <| scratch := β |>)).
    Definition Get_remaining_depth :=
      Ref.map
        (fun α => Some α.(remaining_depth))
        (fun β α => Some (α <| remaining_depth := β |>)).
  End Deserializer.
  End Deserializer.
  
  Module  Impl_serde_json_de_Deserializer_t_R.
  Section Impl_serde_json_de_Deserializer_t_R.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.de.Deserializer.t R.
    
    (*
        pub fn new(read: R) -> Self {
            Deserializer {
                read,
                scratch: Vec::new(),
                remaining_depth: 128,
                #[cfg(feature = "float_roundtrip")]
                single_precision: false,
                #[cfg(feature = "unbounded_depth")]
                disable_recursion_limit: false,
            }
        }
    *)
    Definition new (read : R) : M Self :=
      let* read := M.alloc read in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_de_Deserializer_t_R.
  End Impl_serde_json_de_Deserializer_t_R.
  
  Module  Impl_serde_json_de_Deserializer_t_serde_json_read_IoRead_t_R.
  Section Impl_serde_json_de_Deserializer_t_serde_json_read_IoRead_t_R.
    Context {R : Set}.
    
    Definition Self : Set :=
      serde_json.de.Deserializer.t (serde_json.read.IoRead.t R).
    
    (*
        pub fn from_reader(reader: R) -> Self {
            Deserializer::new(read::IoRead::new(reader))
        }
    *)
    Definition from_reader (reader : R) : M Self :=
      let* reader := M.alloc reader in
      M.read foo.
    
    Global Instance AssociatedFunction_from_reader :
      Notations.DoubleColon Self "from_reader" := {
      Notations.double_colon := from_reader;
    }.
  End Impl_serde_json_de_Deserializer_t_serde_json_read_IoRead_t_R.
  End Impl_serde_json_de_Deserializer_t_serde_json_read_IoRead_t_R.
  
  Module  Impl_serde_json_de_Deserializer_t_serde_json_read_SliceRead_t.
  Section Impl_serde_json_de_Deserializer_t_serde_json_read_SliceRead_t.
    Definition Self : Set :=
      serde_json.de.Deserializer.t serde_json.read.SliceRead.t.
    
    (*
        pub fn from_slice(bytes: &'a [u8]) -> Self {
            Deserializer::new(read::SliceRead::new(bytes))
        }
    *)
    Definition from_slice (bytes : ref (slice u8.t)) : M Self :=
      let* bytes := M.alloc bytes in
      M.read foo.
    
    Global Instance AssociatedFunction_from_slice :
      Notations.DoubleColon Self "from_slice" := {
      Notations.double_colon := from_slice;
    }.
  End Impl_serde_json_de_Deserializer_t_serde_json_read_SliceRead_t.
  End Impl_serde_json_de_Deserializer_t_serde_json_read_SliceRead_t.
  
  Module  Impl_serde_json_de_Deserializer_t_serde_json_read_StrRead_t.
  Section Impl_serde_json_de_Deserializer_t_serde_json_read_StrRead_t.
    Definition Self : Set :=
      serde_json.de.Deserializer.t serde_json.read.StrRead.t.
    
    (*
        pub fn from_str(s: &'a str) -> Self {
            Deserializer::new(read::StrRead::new(s))
        }
    *)
    Definition from_str (s : ref str.t) : M Self :=
      let* s := M.alloc s in
      M.read foo.
    
    Global Instance AssociatedFunction_from_str :
      Notations.DoubleColon Self "from_str" := {
      Notations.double_colon := from_str;
    }.
  End Impl_serde_json_de_Deserializer_t_serde_json_read_StrRead_t.
  End Impl_serde_json_de_Deserializer_t_serde_json_read_StrRead_t.
  
  Module ParserNumber.
    Inductive t : Set :=
    | F64 (_ : f64.t)
    | U64 (_ : u64.t)
    | I64 (_ : i64.t).
    
    Definition Get_F64_0 :=
      Ref.map
        (fun α => match α with | F64 α0 => Some α0 | _ => None end)
        (fun β α => match α with | F64 _ => Some (F64 β) | _ => None end).
    
    Definition Get_U64_0 :=
      Ref.map
        (fun α => match α with | U64 α0 => Some α0 | _ => None end)
        (fun β α => match α with | U64 _ => Some (U64 β) | _ => None end).
    
    Definition Get_I64_0 :=
      Ref.map
        (fun α => match α with | I64 α0 => Some α0 | _ => None end)
        (fun β α => match α with | I64 _ => Some (I64 β) | _ => None end).
  End ParserNumber.
  
  Module  Impl_serde_json_de_ParserNumber_t.
  Section Impl_serde_json_de_ParserNumber_t.
    Definition Self : Set := serde_json.de.ParserNumber.t.
    
    (*
        fn visit<'de, V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            match self {
                ParserNumber::F64(x) => visitor.visit_f64(x),
                ParserNumber::U64(x) => visitor.visit_u64(x),
                ParserNumber::I64(x) => visitor.visit_i64(x),
                #[cfg(feature = "arbitrary_precision")]
                ParserNumber::String(x) => visitor.visit_map(NumberDeserializer { number: x.into() }),
            }
        }
    *)
    Definition visit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_visit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "visit" := {
      Notations.double_colon := visit (V := V);
    }.
    
    (*
        fn invalid_type(self, exp: &dyn Expected) -> Error {
            match self {
                ParserNumber::F64(x) => de::Error::invalid_type(Unexpected::Float(x), exp),
                ParserNumber::U64(x) => de::Error::invalid_type(Unexpected::Unsigned(x), exp),
                ParserNumber::I64(x) => de::Error::invalid_type(Unexpected::Signed(x), exp),
                #[cfg(feature = "arbitrary_precision")]
                ParserNumber::String(_) => de::Error::invalid_type(Unexpected::Other("number"), exp),
            }
        }
    *)
    Definition invalid_type
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT}
        (self : Self)
        (exp : ref DynT)
        : M serde_json.error.Error.t :=
      let* self := M.alloc self in
      let* exp := M.alloc exp in
      M.read foo.
    
    Global Instance AssociatedFunction_invalid_type
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :
      Notations.DoubleColon Self "invalid_type" := {
      Notations.double_colon := invalid_type (DynT := DynT);
    }.
  End Impl_serde_json_de_ParserNumber_t.
  End Impl_serde_json_de_ParserNumber_t.
  
  Module  Impl_serde_json_de_Deserializer_t_R_2.
  Section Impl_serde_json_de_Deserializer_t_R_2.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.de.Deserializer.t R.
    
    (*
        pub fn end(&mut self) -> Result<()> {
            match tri!(self.parse_whitespace()) {
                Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),
                None => Ok(()),
            }
        }
    *)
    Definition end_
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    (*
        pub fn into_iter<T>(self) -> StreamDeserializer<'de, R, T>
        where
            T: de::Deserialize<'de>,
        {
            // This cannot be an implementation of std::iter::IntoIterator because
            // we need the caller to choose what T is.
            let offset = self.read.byte_offset();
            StreamDeserializer {
                de: self,
                offset,
                failed: false,
                output: PhantomData,
                lifetime: PhantomData,
            }
        }
    *)
    Definition into_iter
        {T : Set}
        {ℋ_0 : serde.de.Deserialize.Trait T}
        (self : Self)
        : M (serde_json.de.StreamDeserializer.t R T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_iter
        {T : Set}
        {ℋ_0 : serde.de.Deserialize.Trait T} :
      Notations.DoubleColon Self "into_iter" := {
      Notations.double_colon := into_iter (T := T);
    }.
    
    (*
        pub(crate) fn peek(&mut self) -> Result<Option<u8>> {
            self.read.peek()
        }
    *)
    Definition peek
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek :
      Notations.DoubleColon Self "peek" := {
      Notations.double_colon := peek;
    }.
    
    (*
        fn peek_or_null(&mut self) -> Result<u8> {
            Ok(tri!(self.peek()).unwrap_or(b'\x00'))
        }
    *)
    Definition peek_or_null
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result u8.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek_or_null :
      Notations.DoubleColon Self "peek_or_null" := {
      Notations.double_colon := peek_or_null;
    }.
    
    (*
        fn eat_char(&mut self) {
            self.read.discard();
        }
    *)
    Definition eat_char (self : mut_ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_eat_char :
      Notations.DoubleColon Self "eat_char" := {
      Notations.double_colon := eat_char;
    }.
    
    (*
        fn next_char(&mut self) -> Result<Option<u8>> {
            self.read.next()
        }
    *)
    Definition next_char
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_char :
      Notations.DoubleColon Self "next_char" := {
      Notations.double_colon := next_char;
    }.
    
    (*
        fn next_char_or_null(&mut self) -> Result<u8> {
            Ok(tri!(self.next_char()).unwrap_or(b'\x00'))
        }
    *)
    Definition next_char_or_null
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result u8.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_char_or_null :
      Notations.DoubleColon Self "next_char_or_null" := {
      Notations.double_colon := next_char_or_null;
    }.
    
    (*
        fn error(&self, reason: ErrorCode) -> Error {
            let position = self.read.position();
            Error::syntax(reason, position.line, position.column)
        }
    *)
    Definition error
        (self : ref Self)
        (reason : serde_json.error.ErrorCode.t)
        : M serde_json.error.Error.t :=
      let* self := M.alloc self in
      let* reason := M.alloc reason in
      M.read foo.
    
    Global Instance AssociatedFunction_error :
      Notations.DoubleColon Self "error" := {
      Notations.double_colon := error;
    }.
    
    (*
        fn peek_error(&self, reason: ErrorCode) -> Error {
            let position = self.read.peek_position();
            Error::syntax(reason, position.line, position.column)
        }
    *)
    Definition peek_error
        (self : ref Self)
        (reason : serde_json.error.ErrorCode.t)
        : M serde_json.error.Error.t :=
      let* self := M.alloc self in
      let* reason := M.alloc reason in
      M.read foo.
    
    Global Instance AssociatedFunction_peek_error :
      Notations.DoubleColon Self "peek_error" := {
      Notations.double_colon := peek_error;
    }.
    
    (*
        fn parse_whitespace(&mut self) -> Result<Option<u8>> {
            loop {
                match tri!(self.peek()) {
                    Some(b' ' | b'\n' | b'\t' | b'\r') => {
                        self.eat_char();
                    }
                    other => {
                        return Ok(other);
                    }
                }
            }
        }
    *)
    Definition parse_whitespace
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_whitespace :
      Notations.DoubleColon Self "parse_whitespace" := {
      Notations.double_colon := parse_whitespace;
    }.
    
    (*
        fn peek_invalid_type(&mut self, exp: &dyn Expected) -> Error {
            let err = match self.peek_or_null().unwrap_or(b'\x00') {
                b'n' => {
                    self.eat_char();
                    if let Err(err) = self.parse_ident(b"ull") {
                        return err;
                    }
                    de::Error::invalid_type(Unexpected::Unit, exp)
                }
                b't' => {
                    self.eat_char();
                    if let Err(err) = self.parse_ident(b"rue") {
                        return err;
                    }
                    de::Error::invalid_type(Unexpected::Bool(true), exp)
                }
                b'f' => {
                    self.eat_char();
                    if let Err(err) = self.parse_ident(b"alse") {
                        return err;
                    }
                    de::Error::invalid_type(Unexpected::Bool(false), exp)
                }
                b'-' => {
                    self.eat_char();
                    match self.parse_any_number(false) {
                        Ok(n) => n.invalid_type(exp),
                        Err(err) => return err,
                    }
                }
                b'0'..=b'9' => match self.parse_any_number(true) {
                    Ok(n) => n.invalid_type(exp),
                    Err(err) => return err,
                },
                b'"' => {
                    self.eat_char();
                    self.scratch.clear();
                    match self.read.parse_str(&mut self.scratch) {
                        Ok(s) => de::Error::invalid_type(Unexpected::Str(&s), exp),
                        Err(err) => return err,
                    }
                }
                b'[' => de::Error::invalid_type(Unexpected::Seq, exp),
                b'{' => de::Error::invalid_type(Unexpected::Map, exp),
                _ => self.peek_error(ErrorCode::ExpectedSomeValue),
            };
    
            self.fix_position(err)
        }
    "
    *)
    Definition peek_invalid_type
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT}
        (self : mut_ref Self)
        (exp : ref DynT)
        : M serde_json.error.Error.t :=
      let* self := M.alloc self in
      let* exp := M.alloc exp in
      M.read foo.
    
    Global Instance AssociatedFunction_peek_invalid_type
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :
      Notations.DoubleColon Self "peek_invalid_type" := {
      Notations.double_colon := peek_invalid_type (DynT := DynT);
    }.
    
    (*
        pub(crate) fn deserialize_number<'any, V>(&mut self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'any>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'-' => {
                    self.eat_char();
                    tri!(self.parse_integer(false)).visit(visitor)
                }
                b'0'..=b'9' => tri!(self.parse_integer(true)).visit(visitor),
                _ => Err(self.peek_invalid_type(&visitor)),
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition deserialize_number
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : mut_ref Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_number
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_number" := {
      Notations.double_colon := deserialize_number (V := V);
    }.
    
    (*
        pub(crate) fn do_deserialize_i128<'any, V>(&mut self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'any>,
        {
            let mut buf = String::new();
    
            match tri!(self.parse_whitespace()) {
                Some(b'-') => {
                    self.eat_char();
                    buf.push('-');
                }
                Some(_) => {}
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            tri!(self.scan_integer128(&mut buf));
    
            let value = match buf.parse() {
                Ok(int) => visitor.visit_i128(int),
                Err(_) => {
                    return Err(self.error(ErrorCode::NumberOutOfRange));
                }
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition do_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : mut_ref Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_do_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "do_deserialize_i128" := {
      Notations.double_colon := do_deserialize_i128 (V := V);
    }.
    
    (*
        pub(crate) fn do_deserialize_u128<'any, V>(&mut self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'any>,
        {
            match tri!(self.parse_whitespace()) {
                Some(b'-') => {
                    return Err(self.peek_error(ErrorCode::NumberOutOfRange));
                }
                Some(_) => {}
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            }
    
            let mut buf = String::new();
            tri!(self.scan_integer128(&mut buf));
    
            let value = match buf.parse() {
                Ok(int) => visitor.visit_u128(int),
                Err(_) => {
                    return Err(self.error(ErrorCode::NumberOutOfRange));
                }
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition do_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : mut_ref Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_do_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "do_deserialize_u128" := {
      Notations.double_colon := do_deserialize_u128 (V := V);
    }.
    
    (*
        fn scan_integer128(&mut self, buf: &mut String) -> Result<()> {
            match tri!(self.next_char_or_null()) {
                b'0' => {
                    buf.push('0');
                    // There can be only one leading '0'.
                    match tri!(self.peek_or_null()) {
                        b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),
                        _ => Ok(()),
                    }
                }
                c @ b'1'..=b'9' => {
                    buf.push(c as char);
                    while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {
                        self.eat_char();
                        buf.push(c as char);
                    }
                    Ok(())
                }
                _ => Err(self.error(ErrorCode::InvalidNumber)),
            }
        }
    *)
    Definition scan_integer128
        (self : mut_ref Self)
        (buf : mut_ref alloc.string.String.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* buf := M.alloc buf in
      M.read foo.
    
    Global Instance AssociatedFunction_scan_integer128 :
      Notations.DoubleColon Self "scan_integer128" := {
      Notations.double_colon := scan_integer128;
    }.
    
    (*
        fn fix_position(&self, err: Error) -> Error {
            err.fix_position(move |code| self.error(code))
        }
    *)
    Definition fix_position
        (self : ref Self)
        (err : serde_json.error.Error.t)
        : M serde_json.error.Error.t :=
      let* self := M.alloc self in
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_fix_position :
      Notations.DoubleColon Self "fix_position" := {
      Notations.double_colon := fix_position;
    }.
    
    (*
        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {
            for expected in ident {
                match tri!(self.next_char()) {
                    None => {
                        return Err(self.error(ErrorCode::EofWhileParsingValue));
                    }
                    Some(next) => {
                        if next != *expected {
                            return Err(self.error(ErrorCode::ExpectedSomeIdent));
                        }
                    }
                }
            }
    
            Ok(())
        }
    *)
    Definition parse_ident
        (self : mut_ref Self)
        (ident : ref (slice u8.t))
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* ident := M.alloc ident in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_ident :
      Notations.DoubleColon Self "parse_ident" := {
      Notations.double_colon := parse_ident;
    }.
    
    (*
        fn parse_integer(&mut self, positive: bool) -> Result<ParserNumber> {
            let next = match tri!(self.next_char()) {
                Some(b) => b,
                None => {
                    return Err(self.error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            match next {
                b'0' => {
                    // There can be only one leading '0'.
                    match tri!(self.peek_or_null()) {
                        b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),
                        _ => self.parse_number(positive, 0),
                    }
                }
                c @ b'1'..=b'9' => {
                    let mut significand = (c - b'0') as u64;
    
                    loop {
                        match tri!(self.peek_or_null()) {
                            c @ b'0'..=b'9' => {
                                let digit = (c - b'0') as u64;
    
                                // We need to be careful with overflow. If we can,
                                // try to keep the number as a `u64` until we grow
                                // too large. At that point, switch to parsing the
                                // value as a `f64`.
                                if overflow!(significand * 10 + digit, u64::max_value()) {
                                    return Ok(ParserNumber::F64(tri!(
                                        self.parse_long_integer(positive, significand),
                                    )));
                                }
    
                                self.eat_char();
                                significand = significand * 10 + digit;
                            }
                            _ => {
                                return self.parse_number(positive, significand);
                            }
                        }
                    }
                }
                _ => Err(self.error(ErrorCode::InvalidNumber)),
            }
        }
    *)
    Definition parse_integer
        (self : mut_ref Self)
        (positive : bool.t)
        : M ltac:(serde_json.error.Result serde_json.de.ParserNumber.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_integer :
      Notations.DoubleColon Self "parse_integer" := {
      Notations.double_colon := parse_integer;
    }.
    
    (*
        fn parse_number(&mut self, positive: bool, significand: u64) -> Result<ParserNumber> {
            Ok(match tri!(self.peek_or_null()) {
                b'.' => ParserNumber::F64(tri!(self.parse_decimal(positive, significand, 0))),
                b'e' | b'E' => ParserNumber::F64(tri!(self.parse_exponent(positive, significand, 0))),
                _ => {
                    if positive {
                        ParserNumber::U64(significand)
                    } else {
                        let neg = (significand as i64).wrapping_neg();
    
                        // Convert into a float if we underflow, or on `-0`.
                        if neg >= 0 {
                            ParserNumber::F64(-(significand as f64))
                        } else {
                            ParserNumber::I64(neg)
                        }
                    }
                }
            })
        }
    *)
    Definition parse_number
        (self : mut_ref Self)
        (positive : bool.t)
        (significand : u64.t)
        : M ltac:(serde_json.error.Result serde_json.de.ParserNumber.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      let* significand := M.alloc significand in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_number :
      Notations.DoubleColon Self "parse_number" := {
      Notations.double_colon := parse_number;
    }.
    
    (*
        fn parse_decimal(
            &mut self,
            positive: bool,
            mut significand: u64,
            exponent_before_decimal_point: i32,
        ) -> Result<f64> {
            self.eat_char();
    
            let mut exponent_after_decimal_point = 0;
            while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {
                let digit = (c - b'0') as u64;
    
                if overflow!(significand * 10 + digit, u64::max_value()) {
                    let exponent = exponent_before_decimal_point + exponent_after_decimal_point;
                    return self.parse_decimal_overflow(positive, significand, exponent);
                }
    
                self.eat_char();
                significand = significand * 10 + digit;
                exponent_after_decimal_point -= 1;
            }
    
            // Error if there is not at least one digit after the decimal point.
            if exponent_after_decimal_point == 0 {
                match tri!(self.peek()) {
                    Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),
                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),
                }
            }
    
            let exponent = exponent_before_decimal_point + exponent_after_decimal_point;
            match tri!(self.peek_or_null()) {
                b'e' | b'E' => self.parse_exponent(positive, significand, exponent),
                _ => self.f64_from_parts(positive, significand, exponent),
            }
        }
    *)
    Definition parse_decimal
        (self : mut_ref Self)
        (positive : bool.t)
        (significand : u64.t)
        (exponent_before_decimal_point : i32.t)
        : M ltac:(serde_json.error.Result f64.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      let* significand := M.alloc significand in
      let* exponent_before_decimal_point :=
        M.alloc exponent_before_decimal_point in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_decimal :
      Notations.DoubleColon Self "parse_decimal" := {
      Notations.double_colon := parse_decimal;
    }.
    
    (*
        fn parse_exponent(
            &mut self,
            positive: bool,
            significand: u64,
            starting_exp: i32,
        ) -> Result<f64> {
            self.eat_char();
    
            let positive_exp = match tri!(self.peek_or_null()) {
                b'+' => {
                    self.eat_char();
                    true
                }
                b'-' => {
                    self.eat_char();
                    false
                }
                _ => true,
            };
    
            let next = match tri!(self.next_char()) {
                Some(b) => b,
                None => {
                    return Err(self.error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            // Make sure a digit follows the exponent place.
            let mut exp = match next {
                c @ b'0'..=b'9' => (c - b'0') as i32,
                _ => {
                    return Err(self.error(ErrorCode::InvalidNumber));
                }
            };
    
            while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {
                self.eat_char();
                let digit = (c - b'0') as i32;
    
                if overflow!(exp * 10 + digit, i32::max_value()) {
                    let zero_significand = significand == 0;
                    return self.parse_exponent_overflow(positive, zero_significand, positive_exp);
                }
    
                exp = exp * 10 + digit;
            }
    
            let final_exp = if positive_exp {
                starting_exp.saturating_add(exp)
            } else {
                starting_exp.saturating_sub(exp)
            };
    
            self.f64_from_parts(positive, significand, final_exp)
        }
    *)
    Definition parse_exponent
        (self : mut_ref Self)
        (positive : bool.t)
        (significand : u64.t)
        (starting_exp : i32.t)
        : M ltac:(serde_json.error.Result f64.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      let* significand := M.alloc significand in
      let* starting_exp := M.alloc starting_exp in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_exponent :
      Notations.DoubleColon Self "parse_exponent" := {
      Notations.double_colon := parse_exponent;
    }.
    
    (*
        fn f64_from_parts(
            &mut self,
            positive: bool,
            significand: u64,
            mut exponent: i32,
        ) -> Result<f64> {
            let mut f = significand as f64;
            loop {
                match POW10.get(exponent.wrapping_abs() as usize) {
                    Some(&pow) => {
                        if exponent >= 0 {
                            f *= pow;
                            if f.is_infinite() {
                                return Err(self.error(ErrorCode::NumberOutOfRange));
                            }
                        } else {
                            f /= pow;
                        }
                        break;
                    }
                    None => {
                        if f == 0.0 {
                            break;
                        }
                        if exponent >= 0 {
                            return Err(self.error(ErrorCode::NumberOutOfRange));
                        }
                        f /= 1e308;
                        exponent += 308;
                    }
                }
            }
            Ok(if positive { f } else { -f })
        }
    *)
    Definition f64_from_parts
        (self : mut_ref Self)
        (positive : bool.t)
        (significand : u64.t)
        (exponent : i32.t)
        : M ltac:(serde_json.error.Result f64.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      let* significand := M.alloc significand in
      let* exponent := M.alloc exponent in
      M.read foo.
    
    Global Instance AssociatedFunction_f64_from_parts :
      Notations.DoubleColon Self "f64_from_parts" := {
      Notations.double_colon := f64_from_parts;
    }.
    
    (*
        fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {
            let mut exponent = 0;
            loop {
                match tri!(self.peek_or_null()) {
                    b'0'..=b'9' => {
                        self.eat_char();
                        // This could overflow... if your integer is gigabytes long.
                        // Ignore that possibility.
                        exponent += 1;
                    }
                    b'.' => {
                        return self.parse_decimal(positive, significand, exponent);
                    }
                    b'e' | b'E' => {
                        return self.parse_exponent(positive, significand, exponent);
                    }
                    _ => {
                        return self.f64_from_parts(positive, significand, exponent);
                    }
                }
            }
        }
    *)
    Definition parse_long_integer
        (self : mut_ref Self)
        (positive : bool.t)
        (significand : u64.t)
        : M ltac:(serde_json.error.Result f64.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      let* significand := M.alloc significand in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_long_integer :
      Notations.DoubleColon Self "parse_long_integer" := {
      Notations.double_colon := parse_long_integer;
    }.
    
    (*
        fn parse_decimal_overflow(
            &mut self,
            positive: bool,
            significand: u64,
            exponent: i32,
        ) -> Result<f64> {
            // The next multiply/add would overflow, so just ignore all further
            // digits.
            while let b'0'..=b'9' = tri!(self.peek_or_null()) {
                self.eat_char();
            }
    
            match tri!(self.peek_or_null()) {
                b'e' | b'E' => self.parse_exponent(positive, significand, exponent),
                _ => self.f64_from_parts(positive, significand, exponent),
            }
        }
    *)
    Definition parse_decimal_overflow
        (self : mut_ref Self)
        (positive : bool.t)
        (significand : u64.t)
        (exponent : i32.t)
        : M ltac:(serde_json.error.Result f64.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      let* significand := M.alloc significand in
      let* exponent := M.alloc exponent in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_decimal_overflow :
      Notations.DoubleColon Self "parse_decimal_overflow" := {
      Notations.double_colon := parse_decimal_overflow;
    }.
    
    (*
        fn parse_exponent_overflow(
            &mut self,
            positive: bool,
            zero_significand: bool,
            positive_exp: bool,
        ) -> Result<f64> {
            // Error instead of +/- infinity.
            if !zero_significand && positive_exp {
                return Err(self.error(ErrorCode::NumberOutOfRange));
            }
    
            while let b'0'..=b'9' = tri!(self.peek_or_null()) {
                self.eat_char();
            }
            Ok(if positive { 0.0 } else { -0.0 })
        }
    *)
    Definition parse_exponent_overflow
        (self : mut_ref Self)
        (positive : bool.t)
        (zero_significand : bool.t)
        (positive_exp : bool.t)
        : M ltac:(serde_json.error.Result f64.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      let* zero_significand := M.alloc zero_significand in
      let* positive_exp := M.alloc positive_exp in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_exponent_overflow :
      Notations.DoubleColon Self "parse_exponent_overflow" := {
      Notations.double_colon := parse_exponent_overflow;
    }.
    
    (*
        fn parse_any_signed_number(&mut self) -> Result<ParserNumber> {
            let peek = match tri!(self.peek()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'-' => {
                    self.eat_char();
                    self.parse_any_number(false)
                }
                b'0'..=b'9' => self.parse_any_number(true),
                _ => Err(self.peek_error(ErrorCode::InvalidNumber)),
            };
    
            let value = match tri!(self.peek()) {
                Some(_) => Err(self.peek_error(ErrorCode::InvalidNumber)),
                None => value,
            };
    
            match value {
                Ok(value) => Ok(value),
                // The de::Error impl creates errors with unknown line and column.
                // Fill in the position here by looking at the current index in the
                // input. There is no way to tell whether this should call `error`
                // or `peek_error` so pick the one that seems correct more often.
                // Worst case, the position is off by one character.
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition parse_any_signed_number
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result serde_json.de.ParserNumber.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_any_signed_number :
      Notations.DoubleColon Self "parse_any_signed_number" := {
      Notations.double_colon := parse_any_signed_number;
    }.
    
    (*
        fn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber> {
            self.parse_integer(positive)
        }
    *)
    Definition parse_any_number
        (self : mut_ref Self)
        (positive : bool.t)
        : M ltac:(serde_json.error.Result serde_json.de.ParserNumber.t) :=
      let* self := M.alloc self in
      let* positive := M.alloc positive in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_any_number :
      Notations.DoubleColon Self "parse_any_number" := {
      Notations.double_colon := parse_any_number;
    }.
    
    (*
        fn parse_object_colon(&mut self) -> Result<()> {
            match tri!(self.parse_whitespace()) {
                Some(b':') => {
                    self.eat_char();
                    Ok(())
                }
                Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),
                None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),
            }
        }
    *)
    Definition parse_object_colon
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_object_colon :
      Notations.DoubleColon Self "parse_object_colon" := {
      Notations.double_colon := parse_object_colon;
    }.
    
    (*
        fn end_seq(&mut self) -> Result<()> {
            match tri!(self.parse_whitespace()) {
                Some(b']') => {
                    self.eat_char();
                    Ok(())
                }
                Some(b',') => {
                    self.eat_char();
                    match self.parse_whitespace() {
                        Ok(Some(b']')) => Err(self.peek_error(ErrorCode::TrailingComma)),
                        _ => Err(self.peek_error(ErrorCode::TrailingCharacters)),
                    }
                }
                Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),
                None => Err(self.peek_error(ErrorCode::EofWhileParsingList)),
            }
        }
    *)
    Definition end_seq
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_seq :
      Notations.DoubleColon Self "end_seq" := {
      Notations.double_colon := end_seq;
    }.
    
    (*
        fn end_map(&mut self) -> Result<()> {
            match tri!(self.parse_whitespace()) {
                Some(b'}') => {
                    self.eat_char();
                    Ok(())
                }
                Some(b',') => Err(self.peek_error(ErrorCode::TrailingComma)),
                Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),
                None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),
            }
        }
    *)
    Definition end_map
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_map :
      Notations.DoubleColon Self "end_map" := {
      Notations.double_colon := end_map;
    }.
    
    (*
        fn ignore_value(&mut self) -> Result<()> {
            self.scratch.clear();
            let mut enclosing = None;
    
            loop {
                let peek = match tri!(self.parse_whitespace()) {
                    Some(b) => b,
                    None => {
                        return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                    }
                };
    
                let frame = match peek {
                    b'n' => {
                        self.eat_char();
                        tri!(self.parse_ident(b"ull"));
                        None
                    }
                    b't' => {
                        self.eat_char();
                        tri!(self.parse_ident(b"rue"));
                        None
                    }
                    b'f' => {
                        self.eat_char();
                        tri!(self.parse_ident(b"alse"));
                        None
                    }
                    b'-' => {
                        self.eat_char();
                        tri!(self.ignore_integer());
                        None
                    }
                    b'0'..=b'9' => {
                        tri!(self.ignore_integer());
                        None
                    }
                    b'"' => {
                        self.eat_char();
                        tri!(self.read.ignore_str());
                        None
                    }
                    frame @ (b'[' | b'{') => {
                        self.scratch.extend(enclosing.take());
                        self.eat_char();
                        Some(frame)
                    }
                    _ => return Err(self.peek_error(ErrorCode::ExpectedSomeValue)),
                };
    
                let (mut accept_comma, mut frame) = match frame {
                    Some(frame) => (false, frame),
                    None => match enclosing.take() {
                        Some(frame) => (true, frame),
                        None => match self.scratch.pop() {
                            Some(frame) => (true, frame),
                            None => return Ok(()),
                        },
                    },
                };
    
                loop {
                    match tri!(self.parse_whitespace()) {
                        Some(b',') if accept_comma => {
                            self.eat_char();
                            break;
                        }
                        Some(b']') if frame == b'[' => {}
                        Some(b'}') if frame == b'{' => {}
                        Some(_) => {
                            if accept_comma {
                                return Err(self.peek_error(match frame {
                                    b'[' => ErrorCode::ExpectedListCommaOrEnd,
                                    b'{' => ErrorCode::ExpectedObjectCommaOrEnd,
                                    _ => unreachable!(),
                                }));
                            } else {
                                break;
                            }
                        }
                        None => {
                            return Err(self.peek_error(match frame {
                                b'[' => ErrorCode::EofWhileParsingList,
                                b'{' => ErrorCode::EofWhileParsingObject,
                                _ => unreachable!(),
                            }));
                        }
                    }
    
                    self.eat_char();
                    frame = match self.scratch.pop() {
                        Some(frame) => frame,
                        None => return Ok(()),
                    };
                    accept_comma = true;
                }
    
                if frame == b'{' {
                    match tri!(self.parse_whitespace()) {
                        Some(b'"') => self.eat_char(),
                        Some(_) => return Err(self.peek_error(ErrorCode::KeyMustBeAString)),
                        None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),
                    }
                    tri!(self.read.ignore_str());
                    match tri!(self.parse_whitespace()) {
                        Some(b':') => self.eat_char(),
                        Some(_) => return Err(self.peek_error(ErrorCode::ExpectedColon)),
                        None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),
                    }
                }
    
                enclosing = Some(frame);
            }
        }
    *)
    Definition ignore_value
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_ignore_value :
      Notations.DoubleColon Self "ignore_value" := {
      Notations.double_colon := ignore_value;
    }.
    
    (*
        fn ignore_integer(&mut self) -> Result<()> {
            match tri!(self.next_char_or_null()) {
                b'0' => {
                    // There can be only one leading '0'.
                    if let b'0'..=b'9' = tri!(self.peek_or_null()) {
                        return Err(self.peek_error(ErrorCode::InvalidNumber));
                    }
                }
                b'1'..=b'9' => {
                    while let b'0'..=b'9' = tri!(self.peek_or_null()) {
                        self.eat_char();
                    }
                }
                _ => {
                    return Err(self.error(ErrorCode::InvalidNumber));
                }
            }
    
            match tri!(self.peek_or_null()) {
                b'.' => self.ignore_decimal(),
                b'e' | b'E' => self.ignore_exponent(),
                _ => Ok(()),
            }
        }
    *)
    Definition ignore_integer
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_ignore_integer :
      Notations.DoubleColon Self "ignore_integer" := {
      Notations.double_colon := ignore_integer;
    }.
    
    (*
        fn ignore_decimal(&mut self) -> Result<()> {
            self.eat_char();
    
            let mut at_least_one_digit = false;
            while let b'0'..=b'9' = tri!(self.peek_or_null()) {
                self.eat_char();
                at_least_one_digit = true;
            }
    
            if !at_least_one_digit {
                return Err(self.peek_error(ErrorCode::InvalidNumber));
            }
    
            match tri!(self.peek_or_null()) {
                b'e' | b'E' => self.ignore_exponent(),
                _ => Ok(()),
            }
        }
    *)
    Definition ignore_decimal
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_ignore_decimal :
      Notations.DoubleColon Self "ignore_decimal" := {
      Notations.double_colon := ignore_decimal;
    }.
    
    (*
        fn ignore_exponent(&mut self) -> Result<()> {
            self.eat_char();
    
            match tri!(self.peek_or_null()) {
                b'+' | b'-' => self.eat_char(),
                _ => {}
            }
    
            // Make sure a digit follows the exponent place.
            match tri!(self.next_char_or_null()) {
                b'0'..=b'9' => {}
                _ => {
                    return Err(self.error(ErrorCode::InvalidNumber));
                }
            }
    
            while let b'0'..=b'9' = tri!(self.peek_or_null()) {
                self.eat_char();
            }
    
            Ok(())
        }
    *)
    Definition ignore_exponent
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_ignore_exponent :
      Notations.DoubleColon Self "ignore_exponent" := {
      Notations.double_colon := ignore_exponent;
    }.
  End Impl_serde_json_de_Deserializer_t_R_2.
  End Impl_serde_json_de_Deserializer_t_R_2.
  
  Module  Impl_core_str_traits_FromStr_for_serde_json_number_Number_t.
  Section Impl_core_str_traits_FromStr_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        type Err = Error;
    *)
    Definition Err : Set := serde_json.error.Error.t.
    
    (*
        fn from_str(s: &str) -> result::Result<Self, Self::Err> {
            Deserializer::from_str(s)
                .parse_any_signed_number()
                .map(Into::into)
        }
    *)
    Definition from_str (s : ref str.t) : M (core.result.Result.t Self Err) :=
      let* s := M.alloc s in
      M.read foo.
    
    Global Instance AssociatedFunction_from_str :
      Notations.DoubleColon Self "from_str" := {
      Notations.double_colon := from_str;
    }.
    
    Global Instance ℐ : core.str.traits.FromStr.Trait Self := {
      core.str.traits.FromStr.Err := Err;
      core.str.traits.FromStr.from_str := from_str;
    }.
  End Impl_core_str_traits_FromStr_for_serde_json_number_Number_t.
  End Impl_core_str_traits_FromStr_for_serde_json_number_Number_t.
  
  Definition POW10 : M.Val (ref (array f64.t)) := M.run (M.alloc foo).
  
  Module  Impl_serde_de_Deserializer_for_mut_ref_serde_json_de_Deserializer_t_R.
  Section Impl_serde_de_Deserializer_for_mut_ref_serde_json_de_Deserializer_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := mut_ref (serde_json.de.Deserializer.t R).
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'n' => {
                    self.eat_char();
                    tri!(self.parse_ident(b"ull"));
                    visitor.visit_unit()
                }
                b't' => {
                    self.eat_char();
                    tri!(self.parse_ident(b"rue"));
                    visitor.visit_bool(true)
                }
                b'f' => {
                    self.eat_char();
                    tri!(self.parse_ident(b"alse"));
                    visitor.visit_bool(false)
                }
                b'-' => {
                    self.eat_char();
                    tri!(self.parse_any_number(false)).visit(visitor)
                }
                b'0'..=b'9' => tri!(self.parse_any_number(true)).visit(visitor),
                b'"' => {
                    self.eat_char();
                    self.scratch.clear();
                    match tri!(self.read.parse_str(&mut self.scratch)) {
                        Reference::Borrowed(s) => visitor.visit_borrowed_str(s),
                        Reference::Copied(s) => visitor.visit_str(s),
                    }
                }
                b'[' => {
                    check_recursion! {
                        self.eat_char();
                        let ret = visitor.visit_seq(SeqAccess::new(self));
                    }
    
                    match (ret, self.end_seq()) {
                        (Ok(ret), Ok(())) => Ok(ret),
                        (Err(err), _) | (_, Err(err)) => Err(err),
                    }
                }
                b'{' => {
                    check_recursion! {
                        self.eat_char();
                        let ret = visitor.visit_map(MapAccess::new(self));
                    }
    
                    match (ret, self.end_map()) {
                        (Ok(ret), Ok(())) => Ok(ret),
                        (Err(err), _) | (_, Err(err)) => Err(err),
                    }
                }
                _ => Err(self.peek_error(ErrorCode::ExpectedSomeValue)),
            };
    
            match value {
                Ok(value) => Ok(value),
                // The de::Error impl creates errors with unknown line and column.
                // Fill in the position here by looking at the current index in the
                // input. There is no way to tell whether this should call `error`
                // or `peek_error` so pick the one that seems correct more often.
                // Worst case, the position is off by one character.
                Err(err) => Err(self.fix_position(err)),
            }
        }
    "
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
        fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b't' => {
                    self.eat_char();
                    tri!(self.parse_ident(b"rue"));
                    visitor.visit_bool(true)
                }
                b'f' => {
                    self.eat_char();
                    tri!(self.parse_ident(b"alse"));
                    visitor.visit_bool(false)
                }
                _ => Err(self.peek_invalid_type(&visitor)),
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.$using(visitor)
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
        fn deserialize_char<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.deserialize_str(visitor)
        }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
        fn deserialize_str<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'"' => {
                    self.eat_char();
                    self.scratch.clear();
                    match tri!(self.read.parse_str(&mut self.scratch)) {
                        Reference::Borrowed(s) => visitor.visit_borrowed_str(s),
                        Reference::Copied(s) => visitor.visit_str(s),
                    }
                }
                _ => Err(self.peek_invalid_type(&visitor)),
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    "
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
        fn deserialize_string<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.deserialize_str(visitor)
        }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
        fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'"' => {
                    self.eat_char();
                    self.scratch.clear();
                    match tri!(self.read.parse_str_raw(&mut self.scratch)) {
                        Reference::Borrowed(b) => visitor.visit_borrowed_bytes(b),
                        Reference::Copied(b) => visitor.visit_bytes(b),
                    }
                }
                b'[' => self.deserialize_seq(visitor),
                _ => Err(self.peek_invalid_type(&visitor)),
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    "
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
        fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.deserialize_bytes(visitor)
        }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            match tri!(self.parse_whitespace()) {
                Some(b'n') => {
                    self.eat_char();
                    tri!(self.parse_ident(b"ull"));
                    visitor.visit_none()
                }
                _ => visitor.visit_some(self),
            }
        }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
        fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'n' => {
                    self.eat_char();
                    tri!(self.parse_ident(b"ull"));
                    visitor.visit_unit()
                }
                _ => Err(self.peek_invalid_type(&visitor)),
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
        fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.deserialize_unit(visitor)
        }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
        fn deserialize_newtype_struct<V>(self, name: &str, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            #[cfg(feature = "raw_value")]
            {
                if name == crate::raw::TOKEN {
                    return self.deserialize_raw_value(visitor);
                }
            }
    
            let _ = name;
            visitor.visit_newtype_struct(self)
        }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
        fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'[' => {
                    check_recursion! {
                        self.eat_char();
                        let ret = visitor.visit_seq(SeqAccess::new(self));
                    }
    
                    match (ret, self.end_seq()) {
                        (Ok(ret), Ok(())) => Ok(ret),
                        (Err(err), _) | (_, Err(err)) => Err(err),
                    }
                }
                _ => Err(self.peek_invalid_type(&visitor)),
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
        fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.deserialize_seq(visitor)
        }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
        fn deserialize_tuple_struct<V>(
            self,
            _name: &'static str,
            _len: usize,
            visitor: V,
        ) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.deserialize_seq(visitor)
        }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_len : usize.t)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
        fn deserialize_map<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'{' => {
                    check_recursion! {
                        self.eat_char();
                        let ret = visitor.visit_map(MapAccess::new(self));
                    }
    
                    match (ret, self.end_map()) {
                        (Ok(ret), Ok(())) => Ok(ret),
                        (Err(err), _) | (_, Err(err)) => Err(err),
                    }
                }
                _ => Err(self.peek_invalid_type(&visitor)),
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
        fn deserialize_struct<V>(
            self,
            _name: &'static str,
            _fields: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            let peek = match tri!(self.parse_whitespace()) {
                Some(b) => b,
                None => {
                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b'[' => {
                    check_recursion! {
                        self.eat_char();
                        let ret = visitor.visit_seq(SeqAccess::new(self));
                    }
    
                    match (ret, self.end_seq()) {
                        (Ok(ret), Ok(())) => Ok(ret),
                        (Err(err), _) | (_, Err(err)) => Err(err),
                    }
                }
                b'{' => {
                    check_recursion! {
                        self.eat_char();
                        let ret = visitor.visit_map(MapAccess::new(self));
                    }
    
                    match (ret, self.end_map()) {
                        (Ok(ret), Ok(())) => Ok(ret),
                        (Err(err), _) | (_, Err(err)) => Err(err),
                    }
                }
                _ => Err(self.peek_invalid_type(&visitor)),
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.fix_position(err)),
            }
        }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_fields : ref (slice (ref str.t)))
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _fields := M.alloc _fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
        fn deserialize_enum<V>(
            self,
            _name: &str,
            _variants: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            match tri!(self.parse_whitespace()) {
                Some(b'{') => {
                    check_recursion! {
                        self.eat_char();
                        let value = tri!(visitor.visit_enum(VariantAccess::new(self)));
                    }
    
                    match tri!(self.parse_whitespace()) {
                        Some(b'}') => {
                            self.eat_char();
                            Ok(value)
                        }
                        Some(_) => Err(self.error(ErrorCode::ExpectedSomeValue)),
                        None => Err(self.error(ErrorCode::EofWhileParsingObject)),
                    }
                }
                Some(b'"') => visitor.visit_enum(UnitVariantAccess::new(self)),
                Some(_) => Err(self.peek_error(ErrorCode::ExpectedSomeValue)),
                None => Err(self.peek_error(ErrorCode::EofWhileParsingValue)),
            }
        }
    "
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_variants : ref (slice (ref str.t)))
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variants := M.alloc _variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
        fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.deserialize_str(visitor)
        }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
        fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            tri!(self.ignore_value());
            visitor.visit_unit()
        }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_mut_ref_serde_json_de_Deserializer_t_R.
  End Impl_serde_de_Deserializer_for_mut_ref_serde_json_de_Deserializer_t_R.
  
  Module  SeqAccess.
  Section SeqAccess.
    Context (R : Set).
    
    Record t : Set := {
      de : mut_ref (serde_json.de.Deserializer.t R);
      first : bool.t;
    }.
    
    Definition Get_de :=
      Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
    Definition Get_first :=
      Ref.map (fun α => Some α.(first)) (fun β α => Some (α <| first := β |>)).
  End SeqAccess.
  End SeqAccess.
  
  Module  Impl_serde_json_de_SeqAccess_t_R.
  Section Impl_serde_json_de_SeqAccess_t_R.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.de.SeqAccess.t R.
    
    (*
        fn new(de: &'a mut Deserializer<R>) -> Self {
            SeqAccess { de, first: true }
        }
    *)
    Definition new (de : mut_ref (serde_json.de.Deserializer.t R)) : M Self :=
      let* de := M.alloc de in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_de_SeqAccess_t_R.
  End Impl_serde_json_de_SeqAccess_t_R.
  
  Module  Impl_serde_de_SeqAccess_for_serde_json_de_SeqAccess_t_R.
  Section Impl_serde_de_SeqAccess_for_serde_json_de_SeqAccess_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := serde_json.de.SeqAccess.t R.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>
        where
            T: de::DeserializeSeed<'de>,
        {
            let peek = match tri!(self.de.parse_whitespace()) {
                Some(b']') => {
                    return Ok(None);
                }
                Some(b',') if !self.first => {
                    self.de.eat_char();
                    tri!(self.de.parse_whitespace())
                }
                Some(b) => {
                    if self.first {
                        self.first = false;
                        Some(b)
                    } else {
                        return Err(self.de.peek_error(ErrorCode::ExpectedListCommaOrEnd));
                    }
                }
                None => {
                    return Err(self.de.peek_error(ErrorCode::EofWhileParsingList));
                }
            };
    
            match peek {
                Some(b']') => Err(self.de.peek_error(ErrorCode::TrailingComma)),
                Some(_) => Ok(Some(tri!(seed.deserialize(&mut *self.de)))),
                None => Err(self.de.peek_error(ErrorCode::EofWhileParsingValue)),
            }
        }
    *)
    Definition next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : mut_ref Self)
        (seed : T)
        :
          M
            ltac:(serde_json.error.Result
              (core.option.Option.t T::type["Value"].t)) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "next_element_seed" := {
      Notations.double_colon := next_element_seed (T := T);
    }.
    
    Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
      serde.de.SeqAccess.Error := Error;
      serde.de.SeqAccess.next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        next_element_seed (T := T);
      serde.de.SeqAccess.next_element := Datatypes.None;
      serde.de.SeqAccess.size_hint := Datatypes.None;
    }.
  End Impl_serde_de_SeqAccess_for_serde_json_de_SeqAccess_t_R.
  End Impl_serde_de_SeqAccess_for_serde_json_de_SeqAccess_t_R.
  
  Module  MapAccess.
  Section MapAccess.
    Context (R : Set).
    
    Record t : Set := {
      de : mut_ref (serde_json.de.Deserializer.t R);
      first : bool.t;
    }.
    
    Definition Get_de :=
      Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
    Definition Get_first :=
      Ref.map (fun α => Some α.(first)) (fun β α => Some (α <| first := β |>)).
  End MapAccess.
  End MapAccess.
  
  Module  Impl_serde_json_de_MapAccess_t_R.
  Section Impl_serde_json_de_MapAccess_t_R.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.de.MapAccess.t R.
    
    (*
        fn new(de: &'a mut Deserializer<R>) -> Self {
            MapAccess { de, first: true }
        }
    *)
    Definition new (de : mut_ref (serde_json.de.Deserializer.t R)) : M Self :=
      let* de := M.alloc de in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_de_MapAccess_t_R.
  End Impl_serde_json_de_MapAccess_t_R.
  
  Module  Impl_serde_de_MapAccess_for_serde_json_de_MapAccess_t_R.
  Section Impl_serde_de_MapAccess_for_serde_json_de_MapAccess_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := serde_json.de.MapAccess.t R.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>
        where
            K: de::DeserializeSeed<'de>,
        {
            let peek = match tri!(self.de.parse_whitespace()) {
                Some(b'}') => {
                    return Ok(None);
                }
                Some(b',') if !self.first => {
                    self.de.eat_char();
                    tri!(self.de.parse_whitespace())
                }
                Some(b) => {
                    if self.first {
                        self.first = false;
                        Some(b)
                    } else {
                        return Err(self.de.peek_error(ErrorCode::ExpectedObjectCommaOrEnd));
                    }
                }
                None => {
                    return Err(self.de.peek_error(ErrorCode::EofWhileParsingObject));
                }
            };
    
            match peek {
                Some(b'"') => seed.deserialize(MapKey { de: &mut *self.de }).map(Some),
                Some(b'}') => Err(self.de.peek_error(ErrorCode::TrailingComma)),
                Some(_) => Err(self.de.peek_error(ErrorCode::KeyMustBeAString)),
                None => Err(self.de.peek_error(ErrorCode::EofWhileParsingValue)),
            }
        }
    "
    *)
    Definition next_key_seed
        {K : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait K}
        (self : mut_ref Self)
        (seed : K)
        :
          M
            ltac:(serde_json.error.Result
              (core.option.Option.t K::type["Value"].t)) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_key_seed
        {K : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait K} :
      Notations.DoubleColon Self "next_key_seed" := {
      Notations.double_colon := next_key_seed (K := K);
    }.
    
    (*
        fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>
        where
            V: de::DeserializeSeed<'de>,
        {
            tri!(self.de.parse_object_colon());
    
            seed.deserialize(&mut *self.de)
        }
    *)
    Definition next_value_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V}
        (self : mut_ref Self)
        (seed : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_value_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
      Notations.DoubleColon Self "next_value_seed" := {
      Notations.double_colon := next_value_seed (V := V);
    }.
    
    Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
      serde.de.MapAccess.Error := Error;
      serde.de.MapAccess.next_key_seed
        {K : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait K} :=
        next_key_seed (K := K);
      serde.de.MapAccess.next_value_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
        next_value_seed (V := V);
      serde.de.MapAccess.next_entry_seed := Datatypes.None;
      serde.de.MapAccess.next_key := Datatypes.None;
      serde.de.MapAccess.next_value := Datatypes.None;
      serde.de.MapAccess.next_entry := Datatypes.None;
      serde.de.MapAccess.size_hint := Datatypes.None;
    }.
  End Impl_serde_de_MapAccess_for_serde_json_de_MapAccess_t_R.
  End Impl_serde_de_MapAccess_for_serde_json_de_MapAccess_t_R.
  
  Module  VariantAccess.
  Section VariantAccess.
    Context (R : Set).
    
    Record t : Set := {
      de : mut_ref (serde_json.de.Deserializer.t R);
    }.
    
    Definition Get_de :=
      Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
  End VariantAccess.
  End VariantAccess.
  
  Module  Impl_serde_json_de_VariantAccess_t_R.
  Section Impl_serde_json_de_VariantAccess_t_R.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.de.VariantAccess.t R.
    
    (*
        fn new(de: &'a mut Deserializer<R>) -> Self {
            VariantAccess { de }
        }
    *)
    Definition new (de : mut_ref (serde_json.de.Deserializer.t R)) : M Self :=
      let* de := M.alloc de in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_de_VariantAccess_t_R.
  End Impl_serde_json_de_VariantAccess_t_R.
  
  Module  Impl_serde_de_EnumAccess_for_serde_json_de_VariantAccess_t_R.
  Section Impl_serde_de_EnumAccess_for_serde_json_de_VariantAccess_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := serde_json.de.VariantAccess.t R.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        type Variant = Self;
    *)
    Definition Variant : Set := Self.
    
    (*
        fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>
        where
            V: de::DeserializeSeed<'de>,
        {
            let val = tri!(seed.deserialize(&mut *self.de));
            tri!(self.de.parse_object_colon());
            Ok((val, self))
        }
    *)
    Definition variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V}
        (self : Self)
        (seed : V)
        : M ltac:(serde_json.error.Result (V::type["Value"].t * Self)) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
      Notations.DoubleColon Self "variant_seed" := {
      Notations.double_colon := variant_seed (V := V);
    }.
    
    Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
      serde.de.EnumAccess.Error := Error;
      serde.de.EnumAccess.Variant := Variant;
      serde.de.EnumAccess.variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
        variant_seed (V := V);
      serde.de.EnumAccess.variant := Datatypes.None;
    }.
  End Impl_serde_de_EnumAccess_for_serde_json_de_VariantAccess_t_R.
  End Impl_serde_de_EnumAccess_for_serde_json_de_VariantAccess_t_R.
  
  Module  Impl_serde_de_VariantAccess_for_serde_json_de_VariantAccess_t_R.
  Section Impl_serde_de_VariantAccess_for_serde_json_de_VariantAccess_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := serde_json.de.VariantAccess.t R.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn unit_variant(self) -> Result<()> {
            de::Deserialize::deserialize(self.de)
        }
    *)
    Definition unit_variant
        (self : Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_unit_variant :
      Notations.DoubleColon Self "unit_variant" := {
      Notations.double_colon := unit_variant;
    }.
    
    (*
        fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value>
        where
            T: de::DeserializeSeed<'de>,
        {
            seed.deserialize(self.de)
        }
    *)
    Definition newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : Self)
        (seed : T)
        : M ltac:(serde_json.error.Result T::type["Value"].t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "newtype_variant_seed" := {
      Notations.double_colon := newtype_variant_seed (T := T);
    }.
    
    (*
        fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            de::Deserializer::deserialize_seq(self.de, visitor)
        }
    *)
    Definition tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "tuple_variant" := {
      Notations.double_colon := tuple_variant (V := V);
    }.
    
    (*
        fn struct_variant<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            de::Deserializer::deserialize_struct(self.de, "", fields, visitor)
        }
    *)
    Definition struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (fields : ref (slice (ref str.t)))
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* fields := M.alloc fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "struct_variant" := {
      Notations.double_colon := struct_variant (V := V);
    }.
    
    Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
      serde.de.VariantAccess.Error := Error;
      serde.de.VariantAccess.unit_variant := unit_variant;
      serde.de.VariantAccess.newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        newtype_variant_seed (T := T);
      serde.de.VariantAccess.tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        tuple_variant (V := V);
      serde.de.VariantAccess.struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        struct_variant (V := V);
      serde.de.VariantAccess.newtype_variant := Datatypes.None;
    }.
  End Impl_serde_de_VariantAccess_for_serde_json_de_VariantAccess_t_R.
  End Impl_serde_de_VariantAccess_for_serde_json_de_VariantAccess_t_R.
  
  Module  UnitVariantAccess.
  Section UnitVariantAccess.
    Context (R : Set).
    
    Record t : Set := {
      de : mut_ref (serde_json.de.Deserializer.t R);
    }.
    
    Definition Get_de :=
      Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
  End UnitVariantAccess.
  End UnitVariantAccess.
  
  Module  Impl_serde_json_de_UnitVariantAccess_t_R.
  Section Impl_serde_json_de_UnitVariantAccess_t_R.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.de.UnitVariantAccess.t R.
    
    (*
        fn new(de: &'a mut Deserializer<R>) -> Self {
            UnitVariantAccess { de }
        }
    *)
    Definition new (de : mut_ref (serde_json.de.Deserializer.t R)) : M Self :=
      let* de := M.alloc de in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_de_UnitVariantAccess_t_R.
  End Impl_serde_json_de_UnitVariantAccess_t_R.
  
  Module  Impl_serde_de_EnumAccess_for_serde_json_de_UnitVariantAccess_t_R.
  Section Impl_serde_de_EnumAccess_for_serde_json_de_UnitVariantAccess_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := serde_json.de.UnitVariantAccess.t R.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        type Variant = Self;
    *)
    Definition Variant : Set := Self.
    
    (*
        fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>
        where
            V: de::DeserializeSeed<'de>,
        {
            let variant = tri!(seed.deserialize(&mut *self.de));
            Ok((variant, self))
        }
    *)
    Definition variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V}
        (self : Self)
        (seed : V)
        : M ltac:(serde_json.error.Result (V::type["Value"].t * Self)) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
      Notations.DoubleColon Self "variant_seed" := {
      Notations.double_colon := variant_seed (V := V);
    }.
    
    Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
      serde.de.EnumAccess.Error := Error;
      serde.de.EnumAccess.Variant := Variant;
      serde.de.EnumAccess.variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
        variant_seed (V := V);
      serde.de.EnumAccess.variant := Datatypes.None;
    }.
  End Impl_serde_de_EnumAccess_for_serde_json_de_UnitVariantAccess_t_R.
  End Impl_serde_de_EnumAccess_for_serde_json_de_UnitVariantAccess_t_R.
  
  Module  Impl_serde_de_VariantAccess_for_serde_json_de_UnitVariantAccess_t_R.
  Section Impl_serde_de_VariantAccess_for_serde_json_de_UnitVariantAccess_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := serde_json.de.UnitVariantAccess.t R.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn unit_variant(self) -> Result<()> {
            Ok(())
        }
    *)
    Definition unit_variant
        (self : Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_unit_variant :
      Notations.DoubleColon Self "unit_variant" := {
      Notations.double_colon := unit_variant;
    }.
    
    (*
        fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value>
        where
            T: de::DeserializeSeed<'de>,
        {
            Err(de::Error::invalid_type(
                Unexpected::UnitVariant,
                &"newtype variant",
            ))
        }
    *)
    Definition newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : Self)
        (_seed : T)
        : M ltac:(serde_json.error.Result T::type["Value"].t) :=
      let* self := M.alloc self in
      let* _seed := M.alloc _seed in
      M.read foo.
    
    Global Instance AssociatedFunction_newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "newtype_variant_seed" := {
      Notations.double_colon := newtype_variant_seed (T := T);
    }.
    
    (*
        fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            Err(de::Error::invalid_type(
                Unexpected::UnitVariant,
                &"tuple variant",
            ))
        }
    *)
    Definition tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (_visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "tuple_variant" := {
      Notations.double_colon := tuple_variant (V := V);
    }.
    
    (*
        fn struct_variant<V>(self, _fields: &'static [&'static str], _visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            Err(de::Error::invalid_type(
                Unexpected::UnitVariant,
                &"struct variant",
            ))
        }
    *)
    Definition struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_fields : ref (slice (ref str.t)))
        (_visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* _fields := M.alloc _fields in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "struct_variant" := {
      Notations.double_colon := struct_variant (V := V);
    }.
    
    Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
      serde.de.VariantAccess.Error := Error;
      serde.de.VariantAccess.unit_variant := unit_variant;
      serde.de.VariantAccess.newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        newtype_variant_seed (T := T);
      serde.de.VariantAccess.tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        tuple_variant (V := V);
      serde.de.VariantAccess.struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        struct_variant (V := V);
      serde.de.VariantAccess.newtype_variant := Datatypes.None;
    }.
  End Impl_serde_de_VariantAccess_for_serde_json_de_UnitVariantAccess_t_R.
  End Impl_serde_de_VariantAccess_for_serde_json_de_UnitVariantAccess_t_R.
  
  Module  MapKey.
  Section MapKey.
    Context (R : Set).
    
    Record t : Set := {
      de : mut_ref (serde_json.de.Deserializer.t R);
    }.
    
    Definition Get_de :=
      Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
  End MapKey.
  End MapKey.
  
  Module  Impl_serde_json_de_MapKey_t_R.
  Section Impl_serde_json_de_MapKey_t_R.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.de.MapKey.t R.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.de.eat_char();
    
                match tri!(self.de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),
                }
    
                let value = tri!(self.de.$delegate(visitor));
    
                match tri!(self.de.peek()) {
                    Some(b'"') => self.de.eat_char(),
                    _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),
                }
    
                Ok(value)
            }
    "
    *)
    Definition deserialize_number
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_number
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_number" := {
      Notations.double_colon := deserialize_number (V := V);
    }.
  End Impl_serde_json_de_MapKey_t_R.
  End Impl_serde_json_de_MapKey_t_R.
  
  Module  Impl_serde_de_Deserializer_for_serde_json_de_MapKey_t_R.
  Section Impl_serde_de_Deserializer_for_serde_json_de_MapKey_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := serde_json.de.MapKey.t R.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.de.eat_char();
            self.de.scratch.clear();
            match tri!(self.de.read.parse_str(&mut self.de.scratch)) {
                Reference::Borrowed(s) => visitor.visit_borrowed_str(s),
                Reference::Copied(s) => visitor.visit_str(s),
            }
        }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.de.eat_char();
    
                match tri!(self.de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),
                }
    
                let value = tri!(self.de.$delegate(visitor));
    
                match tri!(self.de.peek()) {
                    Some(b'"') => self.de.eat_char(),
                    _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),
                }
    
                Ok(value)
            }
    "
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.de.eat_char();
    
                match tri!(self.de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),
                }
    
                let value = tri!(self.de.$delegate(visitor));
    
                match tri!(self.de.peek()) {
                    Some(b'"') => self.de.eat_char(),
                    _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),
                }
    
                Ok(value)
            }
    "
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value>
            where
                V: de::Visitor<'de>,
            {
                self.deserialize_number(visitor)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
        fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.de.eat_char();
    
            let peek = match tri!(self.de.next_char()) {
                Some(b) => b,
                None => {
                    return Err(self.de.peek_error(ErrorCode::EofWhileParsingValue));
                }
            };
    
            let value = match peek {
                b't' => {
                    tri!(self.de.parse_ident(b"rue\""));
                    visitor.visit_bool(true)
                }
                b'f' => {
                    tri!(self.de.parse_ident(b"alse\""));
                    visitor.visit_bool(false)
                }
                _ => {
                    self.de.scratch.clear();
                    let s = tri!(self.de.read.parse_str(&mut self.de.scratch));
                    Err(de::Error::invalid_type(Unexpected::Str(&s), &visitor))
                }
            };
    
            match value {
                Ok(value) => Ok(value),
                Err(err) => Err(self.de.fix_position(err)),
            }
        }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            // Map keys cannot be null.
            visitor.visit_some(self)
        }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
        fn deserialize_newtype_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            #[cfg(feature = "raw_value")]
            {
                if name == crate::raw::TOKEN {
                    return self.de.deserialize_raw_value(visitor);
                }
            }
    
            let _ = name;
            visitor.visit_newtype_struct(self)
        }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
        fn deserialize_enum<V>(
            self,
            name: &'static str,
            variants: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.de.deserialize_enum(name, variants, visitor)
        }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (variants : ref (slice (ref str.t)))
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* variants := M.alloc variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
        fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.de.deserialize_bytes(visitor)
        }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
        fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>
        where
            V: de::Visitor<'de>,
        {
            self.de.deserialize_bytes(visitor)
        }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M ltac:(serde_json.error.Result V::type["Value"].t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (fields : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* fields := M.alloc fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_serde_json_de_MapKey_t_R.
  End Impl_serde_de_Deserializer_for_serde_json_de_MapKey_t_R.
  
  Module  StreamDeserializer.
  Section StreamDeserializer.
    Context (R T : Set).
    
    Record t : Set := {
      de : serde_json.de.Deserializer.t R;
      offset : usize.t;
      failed : bool.t;
      output : core.marker.PhantomData.t T;
      lifetime : core.marker.PhantomData.t (ref unit);
    }.
    
    Definition Get_de :=
      Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
    Definition Get_offset :=
      Ref.map
        (fun α => Some α.(offset))
        (fun β α => Some (α <| offset := β |>)).
    Definition Get_failed :=
      Ref.map
        (fun α => Some α.(failed))
        (fun β α => Some (α <| failed := β |>)).
    Definition Get_output :=
      Ref.map
        (fun α => Some α.(output))
        (fun β α => Some (α <| output := β |>)).
    Definition Get_lifetime :=
      Ref.map
        (fun α => Some α.(lifetime))
        (fun β α => Some (α <| lifetime := β |>)).
  End StreamDeserializer.
  End StreamDeserializer.
  
  Module  Impl_serde_json_de_StreamDeserializer_t_R_T.
  Section Impl_serde_json_de_StreamDeserializer_t_R_T.
    Context {R T : Set}.
    
    Definition Self : Set := serde_json.de.StreamDeserializer.t R T.
    
    (*
        pub fn new(read: R) -> Self {
            let offset = read.byte_offset();
            StreamDeserializer {
                de: Deserializer::new(read),
                offset,
                failed: false,
                output: PhantomData,
                lifetime: PhantomData,
            }
        }
    *)
    Definition new (read : R) : M Self :=
      let* read := M.alloc read in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        pub fn byte_offset(&self) -> usize {
            self.offset
        }
    *)
    Definition byte_offset (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_byte_offset :
      Notations.DoubleColon Self "byte_offset" := {
      Notations.double_colon := byte_offset;
    }.
    
    (*
        fn peek_end_of_value(&mut self) -> Result<()> {
            match tri!(self.de.peek()) {
                Some(b' ' | b'\n' | b'\t' | b'\r' | b'"' | b'[' | b']' | b'{' | b'}' | b',' | b':')
                | None => Ok(()),
                Some(_) => {
                    let position = self.de.read.peek_position();
                    Err(Error::syntax(
                        ErrorCode::TrailingCharacters,
                        position.line,
                        position.column,
                    ))
                }
            }
        }
    "
    *)
    Definition peek_end_of_value
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek_end_of_value :
      Notations.DoubleColon Self "peek_end_of_value" := {
      Notations.double_colon := peek_end_of_value;
    }.
  End Impl_serde_json_de_StreamDeserializer_t_R_T.
  End Impl_serde_json_de_StreamDeserializer_t_R_T.
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_de_StreamDeserializer_t_R_T.
  Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_de_StreamDeserializer_t_R_T.
    Context {R T : Set}.
    
    Context
      {ℋ_0 : serde_json.read.Read.Trait R}
      {ℋ_1 : serde.de.Deserialize.Trait T}.
    
    Definition Self : Set := serde_json.de.StreamDeserializer.t R T.
    
    (*
        type Item = Result<T>;
    *)
    Definition Item : Set := ltac:(serde_json.error.Result T).
    
    (*
        fn next(&mut self) -> Option<Result<T>> {
            if R::should_early_return_if_failed && self.failed {
                return None;
            }
    
            // skip whitespaces, if any
            // this helps with trailing whitespaces, since whitespaces between
            // values are handled for us.
            match self.de.parse_whitespace() {
                Ok(None) => {
                    self.offset = self.de.read.byte_offset();
                    None
                }
                Ok(Some(b)) => {
                    // If the value does not have a clear way to show the end of the value
                    // (like numbers, null, true etc.) we have to look for whitespace or
                    // the beginning of a self-delineated value.
                    let self_delineated_value = match b {
                        b'[' | b'"' | b'{' => true,
                        _ => false,
                    };
                    self.offset = self.de.read.byte_offset();
                    let result = de::Deserialize::deserialize(&mut self.de);
    
                    Some(match result {
                        Ok(value) => {
                            self.offset = self.de.read.byte_offset();
                            if self_delineated_value {
                                Ok(value)
                            } else {
                                self.peek_end_of_value().map(|()| value)
                            }
                        }
                        Err(e) => {
                            self.de.read.set_failed(&mut self.failed);
                            Err(e)
                        }
                    })
                }
                Err(e) => {
                    self.de.read.set_failed(&mut self.failed);
                    Some(Err(e))
                }
            }
        }
    "
    *)
    Definition next
        (self : mut_ref Self)
        : M (core.option.Option.t ltac:(serde_json.error.Result T)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_de_StreamDeserializer_t_R_T.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_de_StreamDeserializer_t_R_T.
  
  Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_de_StreamDeserializer_t_R_T.
  Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_de_StreamDeserializer_t_R_T.
    Context {R T : Set}.
    
    Context
      {ℋ_0 : serde_json.read.Read.Trait R}
      {ℋ_1 : serde_json.read.Fused.Trait R}
      {ℋ_2 : serde.de.Deserialize.Trait T}.
    
    Definition Self : Set := serde_json.de.StreamDeserializer.t R T.
    
    Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
    }.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_de_StreamDeserializer_t_R_T.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_de_StreamDeserializer_t_R_T.
  
  (*
  fn from_trait<'de, R, T>(read: R) -> Result<T>
  where
      R: Read<'de>,
      T: de::Deserialize<'de>,
  {
      let mut de = Deserializer::new(read);
      let value = tri!(de::Deserialize::deserialize(&mut de));
  
      // Make sure the whole stream has been consumed.
      tri!(de.end());
      Ok(value)
  }
  *)
  Definition from_trait
      {R T : Set}
      {ℋ_0 : serde_json.read.Read.Trait R}
      {ℋ_1 : serde.de.Deserialize.Trait T}
      (read : R)
      : M ltac:(serde_json.error.Result T) :=
    let* read := M.alloc read in
    M.read foo.
  
  (*
  pub fn from_reader<R, T>(rdr: R) -> Result<T>
  where
      R: crate::io::Read,
      T: de::DeserializeOwned,
  {
      from_trait(read::IoRead::new(rdr))
  }
  *)
  Definition from_reader
      {R T : Set}
      {ℋ_0 : std.io.Read.Trait R}
      {ℋ_1 : serde.de.DeserializeOwned.Trait T}
      (rdr : R)
      : M ltac:(serde_json.error.Result T) :=
    let* rdr := M.alloc rdr in
    M.read foo.
  
  (*
  pub fn from_slice<'a, T>(v: &'a [u8]) -> Result<T>
  where
      T: de::Deserialize<'a>,
  {
      from_trait(read::SliceRead::new(v))
  }
  *)
  Definition from_slice
      {T : Set}
      {ℋ_0 : serde.de.Deserialize.Trait T}
      (v : ref (slice u8.t))
      : M ltac:(serde_json.error.Result T) :=
    let* v := M.alloc v in
    M.read foo.
  
  (*
  pub fn from_str<'a, T>(s: &'a str) -> Result<T>
  where
      T: de::Deserialize<'a>,
  {
      from_trait(read::StrRead::new(s))
  }
  *)
  Definition from_str
      {T : Set}
      {ℋ_0 : serde.de.Deserialize.Trait T}
      (s : ref str.t)
      : M ltac:(serde_json.error.Result T) :=
    let* s := M.alloc s in
    M.read foo.
End de.

Module  Deserializer.
Section Deserializer.
  Context (R : Set).
  
  Record t : Set := {
    read : R;
    scratch : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A;
    remaining_depth : u8.t;
  }.
  
  Definition Get_read :=
    Ref.map (fun α => Some α.(read)) (fun β α => Some (α <| read := β |>)).
  Definition Get_scratch :=
    Ref.map
      (fun α => Some α.(scratch))
      (fun β α => Some (α <| scratch := β |>)).
  Definition Get_remaining_depth :=
    Ref.map
      (fun α => Some α.(remaining_depth))
      (fun β α => Some (α <| remaining_depth := β |>)).
End Deserializer.
End Deserializer.

Module  Impl_serde_json_de_Deserializer_t_R_3.
Section Impl_serde_json_de_Deserializer_t_R_3.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.de.Deserializer.t R.
  
  (*
      pub fn new(read: R) -> Self {
          Deserializer {
              read,
              scratch: Vec::new(),
              remaining_depth: 128,
              #[cfg(feature = "float_roundtrip")]
              single_precision: false,
              #[cfg(feature = "unbounded_depth")]
              disable_recursion_limit: false,
          }
      }
  *)
  Definition new (read : R) : M Self :=
    let* read := M.alloc read in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_de_Deserializer_t_R_3.
End Impl_serde_json_de_Deserializer_t_R_3.

Module  Impl_serde_json_de_Deserializer_t_serde_json_read_IoRead_t_R_2.
Section Impl_serde_json_de_Deserializer_t_serde_json_read_IoRead_t_R_2.
  Context {R : Set}.
  
  Definition Self : Set :=
    serde_json.de.Deserializer.t (serde_json.read.IoRead.t R).
  
  (*
      pub fn from_reader(reader: R) -> Self {
          Deserializer::new(read::IoRead::new(reader))
      }
  *)
  Definition from_reader (reader : R) : M Self :=
    let* reader := M.alloc reader in
    M.read foo.
  
  Global Instance AssociatedFunction_from_reader :
    Notations.DoubleColon Self "from_reader" := {
    Notations.double_colon := from_reader;
  }.
End Impl_serde_json_de_Deserializer_t_serde_json_read_IoRead_t_R_2.
End Impl_serde_json_de_Deserializer_t_serde_json_read_IoRead_t_R_2.

Module  Impl_serde_json_de_Deserializer_t_serde_json_read_SliceRead_t_2.
Section Impl_serde_json_de_Deserializer_t_serde_json_read_SliceRead_t_2.
  Definition Self : Set :=
    serde_json.de.Deserializer.t serde_json.read.SliceRead.t.
  
  (*
      pub fn from_slice(bytes: &'a [u8]) -> Self {
          Deserializer::new(read::SliceRead::new(bytes))
      }
  *)
  Definition from_slice (bytes : ref (slice u8.t)) : M Self :=
    let* bytes := M.alloc bytes in
    M.read foo.
  
  Global Instance AssociatedFunction_from_slice :
    Notations.DoubleColon Self "from_slice" := {
    Notations.double_colon := from_slice;
  }.
End Impl_serde_json_de_Deserializer_t_serde_json_read_SliceRead_t_2.
End Impl_serde_json_de_Deserializer_t_serde_json_read_SliceRead_t_2.

Module  Impl_serde_json_de_Deserializer_t_serde_json_read_StrRead_t_2.
Section Impl_serde_json_de_Deserializer_t_serde_json_read_StrRead_t_2.
  Definition Self : Set :=
    serde_json.de.Deserializer.t serde_json.read.StrRead.t.
  
  (*
      pub fn from_str(s: &'a str) -> Self {
          Deserializer::new(read::StrRead::new(s))
      }
  *)
  Definition from_str (s : ref str.t) : M Self :=
    let* s := M.alloc s in
    M.read foo.
  
  Global Instance AssociatedFunction_from_str :
    Notations.DoubleColon Self "from_str" := {
    Notations.double_colon := from_str;
  }.
End Impl_serde_json_de_Deserializer_t_serde_json_read_StrRead_t_2.
End Impl_serde_json_de_Deserializer_t_serde_json_read_StrRead_t_2.

Module ParserNumber.
  Inductive t : Set :=
  | F64 (_ : f64.t)
  | U64 (_ : u64.t)
  | I64 (_ : i64.t).
  
  Definition Get_F64_0 :=
    Ref.map
      (fun α => match α with | F64 α0 => Some α0 | _ => None end)
      (fun β α => match α with | F64 _ => Some (F64 β) | _ => None end).
  
  Definition Get_U64_0 :=
    Ref.map
      (fun α => match α with | U64 α0 => Some α0 | _ => None end)
      (fun β α => match α with | U64 _ => Some (U64 β) | _ => None end).
  
  Definition Get_I64_0 :=
    Ref.map
      (fun α => match α with | I64 α0 => Some α0 | _ => None end)
      (fun β α => match α with | I64 _ => Some (I64 β) | _ => None end).
End ParserNumber.

Module  Impl_serde_json_de_ParserNumber_t_2.
Section Impl_serde_json_de_ParserNumber_t_2.
  Definition Self : Set := serde_json.de.ParserNumber.t.
  
  (*
      fn visit<'de, V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          match self {
              ParserNumber::F64(x) => visitor.visit_f64(x),
              ParserNumber::U64(x) => visitor.visit_u64(x),
              ParserNumber::I64(x) => visitor.visit_i64(x),
              #[cfg(feature = "arbitrary_precision")]
              ParserNumber::String(x) => visitor.visit_map(NumberDeserializer { number: x.into() }),
          }
      }
  *)
  Definition visit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_visit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "visit" := {
    Notations.double_colon := visit (V := V);
  }.
  
  (*
      fn invalid_type(self, exp: &dyn Expected) -> Error {
          match self {
              ParserNumber::F64(x) => de::Error::invalid_type(Unexpected::Float(x), exp),
              ParserNumber::U64(x) => de::Error::invalid_type(Unexpected::Unsigned(x), exp),
              ParserNumber::I64(x) => de::Error::invalid_type(Unexpected::Signed(x), exp),
              #[cfg(feature = "arbitrary_precision")]
              ParserNumber::String(_) => de::Error::invalid_type(Unexpected::Other("number"), exp),
          }
      }
  *)
  Definition invalid_type
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT}
      (self : Self)
      (exp : ref DynT)
      : M serde_json.error.Error.t :=
    let* self := M.alloc self in
    let* exp := M.alloc exp in
    M.read foo.
  
  Global Instance AssociatedFunction_invalid_type
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :
    Notations.DoubleColon Self "invalid_type" := {
    Notations.double_colon := invalid_type (DynT := DynT);
  }.
End Impl_serde_json_de_ParserNumber_t_2.
End Impl_serde_json_de_ParserNumber_t_2.

Module  Impl_serde_json_de_Deserializer_t_R_4.
Section Impl_serde_json_de_Deserializer_t_R_4.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.de.Deserializer.t R.
  
  (*
      pub fn end(&mut self) -> Result<()> {
          match tri!(self.parse_whitespace()) {
              Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),
              None => Ok(()),
          }
      }
  *)
  Definition end_
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  (*
      pub fn into_iter<T>(self) -> StreamDeserializer<'de, R, T>
      where
          T: de::Deserialize<'de>,
      {
          // This cannot be an implementation of std::iter::IntoIterator because
          // we need the caller to choose what T is.
          let offset = self.read.byte_offset();
          StreamDeserializer {
              de: self,
              offset,
              failed: false,
              output: PhantomData,
              lifetime: PhantomData,
          }
      }
  *)
  Definition into_iter
      {T : Set}
      {ℋ_0 : serde.de.Deserialize.Trait T}
      (self : Self)
      : M (serde_json.de.StreamDeserializer.t R T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_iter
      {T : Set}
      {ℋ_0 : serde.de.Deserialize.Trait T} :
    Notations.DoubleColon Self "into_iter" := {
    Notations.double_colon := into_iter (T := T);
  }.
  
  (*
      pub(crate) fn peek(&mut self) -> Result<Option<u8>> {
          self.read.peek()
      }
  *)
  Definition peek
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
      fn peek_or_null(&mut self) -> Result<u8> {
          Ok(tri!(self.peek()).unwrap_or(b'\x00'))
      }
  *)
  Definition peek_or_null
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result u8.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek_or_null :
    Notations.DoubleColon Self "peek_or_null" := {
    Notations.double_colon := peek_or_null;
  }.
  
  (*
      fn eat_char(&mut self) {
          self.read.discard();
      }
  *)
  Definition eat_char (self : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_eat_char :
    Notations.DoubleColon Self "eat_char" := {
    Notations.double_colon := eat_char;
  }.
  
  (*
      fn next_char(&mut self) -> Result<Option<u8>> {
          self.read.next()
      }
  *)
  Definition next_char
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_char :
    Notations.DoubleColon Self "next_char" := {
    Notations.double_colon := next_char;
  }.
  
  (*
      fn next_char_or_null(&mut self) -> Result<u8> {
          Ok(tri!(self.next_char()).unwrap_or(b'\x00'))
      }
  *)
  Definition next_char_or_null
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result u8.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_char_or_null :
    Notations.DoubleColon Self "next_char_or_null" := {
    Notations.double_colon := next_char_or_null;
  }.
  
  (*
      fn error(&self, reason: ErrorCode) -> Error {
          let position = self.read.position();
          Error::syntax(reason, position.line, position.column)
      }
  *)
  Definition error
      (self : ref Self)
      (reason : serde_json.error.ErrorCode.t)
      : M serde_json.error.Error.t :=
    let* self := M.alloc self in
    let* reason := M.alloc reason in
    M.read foo.
  
  Global Instance AssociatedFunction_error :
    Notations.DoubleColon Self "error" := {
    Notations.double_colon := error;
  }.
  
  (*
      fn peek_error(&self, reason: ErrorCode) -> Error {
          let position = self.read.peek_position();
          Error::syntax(reason, position.line, position.column)
      }
  *)
  Definition peek_error
      (self : ref Self)
      (reason : serde_json.error.ErrorCode.t)
      : M serde_json.error.Error.t :=
    let* self := M.alloc self in
    let* reason := M.alloc reason in
    M.read foo.
  
  Global Instance AssociatedFunction_peek_error :
    Notations.DoubleColon Self "peek_error" := {
    Notations.double_colon := peek_error;
  }.
  
  (*
      fn parse_whitespace(&mut self) -> Result<Option<u8>> {
          loop {
              match tri!(self.peek()) {
                  Some(b' ' | b'\n' | b'\t' | b'\r') => {
                      self.eat_char();
                  }
                  other => {
                      return Ok(other);
                  }
              }
          }
      }
  *)
  Definition parse_whitespace
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_whitespace :
    Notations.DoubleColon Self "parse_whitespace" := {
    Notations.double_colon := parse_whitespace;
  }.
  
  (*
      fn peek_invalid_type(&mut self, exp: &dyn Expected) -> Error {
          let err = match self.peek_or_null().unwrap_or(b'\x00') {
              b'n' => {
                  self.eat_char();
                  if let Err(err) = self.parse_ident(b"ull") {
                      return err;
                  }
                  de::Error::invalid_type(Unexpected::Unit, exp)
              }
              b't' => {
                  self.eat_char();
                  if let Err(err) = self.parse_ident(b"rue") {
                      return err;
                  }
                  de::Error::invalid_type(Unexpected::Bool(true), exp)
              }
              b'f' => {
                  self.eat_char();
                  if let Err(err) = self.parse_ident(b"alse") {
                      return err;
                  }
                  de::Error::invalid_type(Unexpected::Bool(false), exp)
              }
              b'-' => {
                  self.eat_char();
                  match self.parse_any_number(false) {
                      Ok(n) => n.invalid_type(exp),
                      Err(err) => return err,
                  }
              }
              b'0'..=b'9' => match self.parse_any_number(true) {
                  Ok(n) => n.invalid_type(exp),
                  Err(err) => return err,
              },
              b'"' => {
                  self.eat_char();
                  self.scratch.clear();
                  match self.read.parse_str(&mut self.scratch) {
                      Ok(s) => de::Error::invalid_type(Unexpected::Str(&s), exp),
                      Err(err) => return err,
                  }
              }
              b'[' => de::Error::invalid_type(Unexpected::Seq, exp),
              b'{' => de::Error::invalid_type(Unexpected::Map, exp),
              _ => self.peek_error(ErrorCode::ExpectedSomeValue),
          };
  
          self.fix_position(err)
      }
  "
  *)
  Definition peek_invalid_type
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT}
      (self : mut_ref Self)
      (exp : ref DynT)
      : M serde_json.error.Error.t :=
    let* self := M.alloc self in
    let* exp := M.alloc exp in
    M.read foo.
  
  Global Instance AssociatedFunction_peek_invalid_type
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :
    Notations.DoubleColon Self "peek_invalid_type" := {
    Notations.double_colon := peek_invalid_type (DynT := DynT);
  }.
  
  (*
      pub(crate) fn deserialize_number<'any, V>(&mut self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'any>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'-' => {
                  self.eat_char();
                  tri!(self.parse_integer(false)).visit(visitor)
              }
              b'0'..=b'9' => tri!(self.parse_integer(true)).visit(visitor),
              _ => Err(self.peek_invalid_type(&visitor)),
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition deserialize_number
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : mut_ref Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_number
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_number" := {
    Notations.double_colon := deserialize_number (V := V);
  }.
  
  (*
      pub(crate) fn do_deserialize_i128<'any, V>(&mut self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'any>,
      {
          let mut buf = String::new();
  
          match tri!(self.parse_whitespace()) {
              Some(b'-') => {
                  self.eat_char();
                  buf.push('-');
              }
              Some(_) => {}
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          tri!(self.scan_integer128(&mut buf));
  
          let value = match buf.parse() {
              Ok(int) => visitor.visit_i128(int),
              Err(_) => {
                  return Err(self.error(ErrorCode::NumberOutOfRange));
              }
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition do_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : mut_ref Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_do_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "do_deserialize_i128" := {
    Notations.double_colon := do_deserialize_i128 (V := V);
  }.
  
  (*
      pub(crate) fn do_deserialize_u128<'any, V>(&mut self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'any>,
      {
          match tri!(self.parse_whitespace()) {
              Some(b'-') => {
                  return Err(self.peek_error(ErrorCode::NumberOutOfRange));
              }
              Some(_) => {}
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          }
  
          let mut buf = String::new();
          tri!(self.scan_integer128(&mut buf));
  
          let value = match buf.parse() {
              Ok(int) => visitor.visit_u128(int),
              Err(_) => {
                  return Err(self.error(ErrorCode::NumberOutOfRange));
              }
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition do_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : mut_ref Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_do_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "do_deserialize_u128" := {
    Notations.double_colon := do_deserialize_u128 (V := V);
  }.
  
  (*
      fn scan_integer128(&mut self, buf: &mut String) -> Result<()> {
          match tri!(self.next_char_or_null()) {
              b'0' => {
                  buf.push('0');
                  // There can be only one leading '0'.
                  match tri!(self.peek_or_null()) {
                      b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),
                      _ => Ok(()),
                  }
              }
              c @ b'1'..=b'9' => {
                  buf.push(c as char);
                  while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {
                      self.eat_char();
                      buf.push(c as char);
                  }
                  Ok(())
              }
              _ => Err(self.error(ErrorCode::InvalidNumber)),
          }
      }
  *)
  Definition scan_integer128
      (self : mut_ref Self)
      (buf : mut_ref alloc.string.String.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_scan_integer128 :
    Notations.DoubleColon Self "scan_integer128" := {
    Notations.double_colon := scan_integer128;
  }.
  
  (*
      fn fix_position(&self, err: Error) -> Error {
          err.fix_position(move |code| self.error(code))
      }
  *)
  Definition fix_position
      (self : ref Self)
      (err : serde_json.error.Error.t)
      : M serde_json.error.Error.t :=
    let* self := M.alloc self in
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_fix_position :
    Notations.DoubleColon Self "fix_position" := {
    Notations.double_colon := fix_position;
  }.
  
  (*
      fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {
          for expected in ident {
              match tri!(self.next_char()) {
                  None => {
                      return Err(self.error(ErrorCode::EofWhileParsingValue));
                  }
                  Some(next) => {
                      if next != *expected {
                          return Err(self.error(ErrorCode::ExpectedSomeIdent));
                      }
                  }
              }
          }
  
          Ok(())
      }
  *)
  Definition parse_ident
      (self : mut_ref Self)
      (ident : ref (slice u8.t))
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* ident := M.alloc ident in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_ident :
    Notations.DoubleColon Self "parse_ident" := {
    Notations.double_colon := parse_ident;
  }.
  
  (*
      fn parse_integer(&mut self, positive: bool) -> Result<ParserNumber> {
          let next = match tri!(self.next_char()) {
              Some(b) => b,
              None => {
                  return Err(self.error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          match next {
              b'0' => {
                  // There can be only one leading '0'.
                  match tri!(self.peek_or_null()) {
                      b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),
                      _ => self.parse_number(positive, 0),
                  }
              }
              c @ b'1'..=b'9' => {
                  let mut significand = (c - b'0') as u64;
  
                  loop {
                      match tri!(self.peek_or_null()) {
                          c @ b'0'..=b'9' => {
                              let digit = (c - b'0') as u64;
  
                              // We need to be careful with overflow. If we can,
                              // try to keep the number as a `u64` until we grow
                              // too large. At that point, switch to parsing the
                              // value as a `f64`.
                              if overflow!(significand * 10 + digit, u64::max_value()) {
                                  return Ok(ParserNumber::F64(tri!(
                                      self.parse_long_integer(positive, significand),
                                  )));
                              }
  
                              self.eat_char();
                              significand = significand * 10 + digit;
                          }
                          _ => {
                              return self.parse_number(positive, significand);
                          }
                      }
                  }
              }
              _ => Err(self.error(ErrorCode::InvalidNumber)),
          }
      }
  *)
  Definition parse_integer
      (self : mut_ref Self)
      (positive : bool.t)
      : M ltac:(serde_json.error.Result serde_json.de.ParserNumber.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_integer :
    Notations.DoubleColon Self "parse_integer" := {
    Notations.double_colon := parse_integer;
  }.
  
  (*
      fn parse_number(&mut self, positive: bool, significand: u64) -> Result<ParserNumber> {
          Ok(match tri!(self.peek_or_null()) {
              b'.' => ParserNumber::F64(tri!(self.parse_decimal(positive, significand, 0))),
              b'e' | b'E' => ParserNumber::F64(tri!(self.parse_exponent(positive, significand, 0))),
              _ => {
                  if positive {
                      ParserNumber::U64(significand)
                  } else {
                      let neg = (significand as i64).wrapping_neg();
  
                      // Convert into a float if we underflow, or on `-0`.
                      if neg >= 0 {
                          ParserNumber::F64(-(significand as f64))
                      } else {
                          ParserNumber::I64(neg)
                      }
                  }
              }
          })
      }
  *)
  Definition parse_number
      (self : mut_ref Self)
      (positive : bool.t)
      (significand : u64.t)
      : M ltac:(serde_json.error.Result serde_json.de.ParserNumber.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    let* significand := M.alloc significand in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_number :
    Notations.DoubleColon Self "parse_number" := {
    Notations.double_colon := parse_number;
  }.
  
  (*
      fn parse_decimal(
          &mut self,
          positive: bool,
          mut significand: u64,
          exponent_before_decimal_point: i32,
      ) -> Result<f64> {
          self.eat_char();
  
          let mut exponent_after_decimal_point = 0;
          while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {
              let digit = (c - b'0') as u64;
  
              if overflow!(significand * 10 + digit, u64::max_value()) {
                  let exponent = exponent_before_decimal_point + exponent_after_decimal_point;
                  return self.parse_decimal_overflow(positive, significand, exponent);
              }
  
              self.eat_char();
              significand = significand * 10 + digit;
              exponent_after_decimal_point -= 1;
          }
  
          // Error if there is not at least one digit after the decimal point.
          if exponent_after_decimal_point == 0 {
              match tri!(self.peek()) {
                  Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),
                  None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),
              }
          }
  
          let exponent = exponent_before_decimal_point + exponent_after_decimal_point;
          match tri!(self.peek_or_null()) {
              b'e' | b'E' => self.parse_exponent(positive, significand, exponent),
              _ => self.f64_from_parts(positive, significand, exponent),
          }
      }
  *)
  Definition parse_decimal
      (self : mut_ref Self)
      (positive : bool.t)
      (significand : u64.t)
      (exponent_before_decimal_point : i32.t)
      : M ltac:(serde_json.error.Result f64.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    let* significand := M.alloc significand in
    let* exponent_before_decimal_point :=
      M.alloc exponent_before_decimal_point in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_decimal :
    Notations.DoubleColon Self "parse_decimal" := {
    Notations.double_colon := parse_decimal;
  }.
  
  (*
      fn parse_exponent(
          &mut self,
          positive: bool,
          significand: u64,
          starting_exp: i32,
      ) -> Result<f64> {
          self.eat_char();
  
          let positive_exp = match tri!(self.peek_or_null()) {
              b'+' => {
                  self.eat_char();
                  true
              }
              b'-' => {
                  self.eat_char();
                  false
              }
              _ => true,
          };
  
          let next = match tri!(self.next_char()) {
              Some(b) => b,
              None => {
                  return Err(self.error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          // Make sure a digit follows the exponent place.
          let mut exp = match next {
              c @ b'0'..=b'9' => (c - b'0') as i32,
              _ => {
                  return Err(self.error(ErrorCode::InvalidNumber));
              }
          };
  
          while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {
              self.eat_char();
              let digit = (c - b'0') as i32;
  
              if overflow!(exp * 10 + digit, i32::max_value()) {
                  let zero_significand = significand == 0;
                  return self.parse_exponent_overflow(positive, zero_significand, positive_exp);
              }
  
              exp = exp * 10 + digit;
          }
  
          let final_exp = if positive_exp {
              starting_exp.saturating_add(exp)
          } else {
              starting_exp.saturating_sub(exp)
          };
  
          self.f64_from_parts(positive, significand, final_exp)
      }
  *)
  Definition parse_exponent
      (self : mut_ref Self)
      (positive : bool.t)
      (significand : u64.t)
      (starting_exp : i32.t)
      : M ltac:(serde_json.error.Result f64.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    let* significand := M.alloc significand in
    let* starting_exp := M.alloc starting_exp in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_exponent :
    Notations.DoubleColon Self "parse_exponent" := {
    Notations.double_colon := parse_exponent;
  }.
  
  (*
      fn f64_from_parts(
          &mut self,
          positive: bool,
          significand: u64,
          mut exponent: i32,
      ) -> Result<f64> {
          let mut f = significand as f64;
          loop {
              match POW10.get(exponent.wrapping_abs() as usize) {
                  Some(&pow) => {
                      if exponent >= 0 {
                          f *= pow;
                          if f.is_infinite() {
                              return Err(self.error(ErrorCode::NumberOutOfRange));
                          }
                      } else {
                          f /= pow;
                      }
                      break;
                  }
                  None => {
                      if f == 0.0 {
                          break;
                      }
                      if exponent >= 0 {
                          return Err(self.error(ErrorCode::NumberOutOfRange));
                      }
                      f /= 1e308;
                      exponent += 308;
                  }
              }
          }
          Ok(if positive { f } else { -f })
      }
  *)
  Definition f64_from_parts
      (self : mut_ref Self)
      (positive : bool.t)
      (significand : u64.t)
      (exponent : i32.t)
      : M ltac:(serde_json.error.Result f64.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    let* significand := M.alloc significand in
    let* exponent := M.alloc exponent in
    M.read foo.
  
  Global Instance AssociatedFunction_f64_from_parts :
    Notations.DoubleColon Self "f64_from_parts" := {
    Notations.double_colon := f64_from_parts;
  }.
  
  (*
      fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {
          let mut exponent = 0;
          loop {
              match tri!(self.peek_or_null()) {
                  b'0'..=b'9' => {
                      self.eat_char();
                      // This could overflow... if your integer is gigabytes long.
                      // Ignore that possibility.
                      exponent += 1;
                  }
                  b'.' => {
                      return self.parse_decimal(positive, significand, exponent);
                  }
                  b'e' | b'E' => {
                      return self.parse_exponent(positive, significand, exponent);
                  }
                  _ => {
                      return self.f64_from_parts(positive, significand, exponent);
                  }
              }
          }
      }
  *)
  Definition parse_long_integer
      (self : mut_ref Self)
      (positive : bool.t)
      (significand : u64.t)
      : M ltac:(serde_json.error.Result f64.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    let* significand := M.alloc significand in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_long_integer :
    Notations.DoubleColon Self "parse_long_integer" := {
    Notations.double_colon := parse_long_integer;
  }.
  
  (*
      fn parse_decimal_overflow(
          &mut self,
          positive: bool,
          significand: u64,
          exponent: i32,
      ) -> Result<f64> {
          // The next multiply/add would overflow, so just ignore all further
          // digits.
          while let b'0'..=b'9' = tri!(self.peek_or_null()) {
              self.eat_char();
          }
  
          match tri!(self.peek_or_null()) {
              b'e' | b'E' => self.parse_exponent(positive, significand, exponent),
              _ => self.f64_from_parts(positive, significand, exponent),
          }
      }
  *)
  Definition parse_decimal_overflow
      (self : mut_ref Self)
      (positive : bool.t)
      (significand : u64.t)
      (exponent : i32.t)
      : M ltac:(serde_json.error.Result f64.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    let* significand := M.alloc significand in
    let* exponent := M.alloc exponent in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_decimal_overflow :
    Notations.DoubleColon Self "parse_decimal_overflow" := {
    Notations.double_colon := parse_decimal_overflow;
  }.
  
  (*
      fn parse_exponent_overflow(
          &mut self,
          positive: bool,
          zero_significand: bool,
          positive_exp: bool,
      ) -> Result<f64> {
          // Error instead of +/- infinity.
          if !zero_significand && positive_exp {
              return Err(self.error(ErrorCode::NumberOutOfRange));
          }
  
          while let b'0'..=b'9' = tri!(self.peek_or_null()) {
              self.eat_char();
          }
          Ok(if positive { 0.0 } else { -0.0 })
      }
  *)
  Definition parse_exponent_overflow
      (self : mut_ref Self)
      (positive : bool.t)
      (zero_significand : bool.t)
      (positive_exp : bool.t)
      : M ltac:(serde_json.error.Result f64.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    let* zero_significand := M.alloc zero_significand in
    let* positive_exp := M.alloc positive_exp in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_exponent_overflow :
    Notations.DoubleColon Self "parse_exponent_overflow" := {
    Notations.double_colon := parse_exponent_overflow;
  }.
  
  (*
      fn parse_any_signed_number(&mut self) -> Result<ParserNumber> {
          let peek = match tri!(self.peek()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'-' => {
                  self.eat_char();
                  self.parse_any_number(false)
              }
              b'0'..=b'9' => self.parse_any_number(true),
              _ => Err(self.peek_error(ErrorCode::InvalidNumber)),
          };
  
          let value = match tri!(self.peek()) {
              Some(_) => Err(self.peek_error(ErrorCode::InvalidNumber)),
              None => value,
          };
  
          match value {
              Ok(value) => Ok(value),
              // The de::Error impl creates errors with unknown line and column.
              // Fill in the position here by looking at the current index in the
              // input. There is no way to tell whether this should call `error`
              // or `peek_error` so pick the one that seems correct more often.
              // Worst case, the position is off by one character.
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition parse_any_signed_number
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result serde_json.de.ParserNumber.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_any_signed_number :
    Notations.DoubleColon Self "parse_any_signed_number" := {
    Notations.double_colon := parse_any_signed_number;
  }.
  
  (*
      fn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber> {
          self.parse_integer(positive)
      }
  *)
  Definition parse_any_number
      (self : mut_ref Self)
      (positive : bool.t)
      : M ltac:(serde_json.error.Result serde_json.de.ParserNumber.t) :=
    let* self := M.alloc self in
    let* positive := M.alloc positive in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_any_number :
    Notations.DoubleColon Self "parse_any_number" := {
    Notations.double_colon := parse_any_number;
  }.
  
  (*
      fn parse_object_colon(&mut self) -> Result<()> {
          match tri!(self.parse_whitespace()) {
              Some(b':') => {
                  self.eat_char();
                  Ok(())
              }
              Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),
              None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),
          }
      }
  *)
  Definition parse_object_colon
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_object_colon :
    Notations.DoubleColon Self "parse_object_colon" := {
    Notations.double_colon := parse_object_colon;
  }.
  
  (*
      fn end_seq(&mut self) -> Result<()> {
          match tri!(self.parse_whitespace()) {
              Some(b']') => {
                  self.eat_char();
                  Ok(())
              }
              Some(b',') => {
                  self.eat_char();
                  match self.parse_whitespace() {
                      Ok(Some(b']')) => Err(self.peek_error(ErrorCode::TrailingComma)),
                      _ => Err(self.peek_error(ErrorCode::TrailingCharacters)),
                  }
              }
              Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),
              None => Err(self.peek_error(ErrorCode::EofWhileParsingList)),
          }
      }
  *)
  Definition end_seq
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_seq :
    Notations.DoubleColon Self "end_seq" := {
    Notations.double_colon := end_seq;
  }.
  
  (*
      fn end_map(&mut self) -> Result<()> {
          match tri!(self.parse_whitespace()) {
              Some(b'}') => {
                  self.eat_char();
                  Ok(())
              }
              Some(b',') => Err(self.peek_error(ErrorCode::TrailingComma)),
              Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),
              None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),
          }
      }
  *)
  Definition end_map
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_map :
    Notations.DoubleColon Self "end_map" := {
    Notations.double_colon := end_map;
  }.
  
  (*
      fn ignore_value(&mut self) -> Result<()> {
          self.scratch.clear();
          let mut enclosing = None;
  
          loop {
              let peek = match tri!(self.parse_whitespace()) {
                  Some(b) => b,
                  None => {
                      return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
                  }
              };
  
              let frame = match peek {
                  b'n' => {
                      self.eat_char();
                      tri!(self.parse_ident(b"ull"));
                      None
                  }
                  b't' => {
                      self.eat_char();
                      tri!(self.parse_ident(b"rue"));
                      None
                  }
                  b'f' => {
                      self.eat_char();
                      tri!(self.parse_ident(b"alse"));
                      None
                  }
                  b'-' => {
                      self.eat_char();
                      tri!(self.ignore_integer());
                      None
                  }
                  b'0'..=b'9' => {
                      tri!(self.ignore_integer());
                      None
                  }
                  b'"' => {
                      self.eat_char();
                      tri!(self.read.ignore_str());
                      None
                  }
                  frame @ (b'[' | b'{') => {
                      self.scratch.extend(enclosing.take());
                      self.eat_char();
                      Some(frame)
                  }
                  _ => return Err(self.peek_error(ErrorCode::ExpectedSomeValue)),
              };
  
              let (mut accept_comma, mut frame) = match frame {
                  Some(frame) => (false, frame),
                  None => match enclosing.take() {
                      Some(frame) => (true, frame),
                      None => match self.scratch.pop() {
                          Some(frame) => (true, frame),
                          None => return Ok(()),
                      },
                  },
              };
  
              loop {
                  match tri!(self.parse_whitespace()) {
                      Some(b',') if accept_comma => {
                          self.eat_char();
                          break;
                      }
                      Some(b']') if frame == b'[' => {}
                      Some(b'}') if frame == b'{' => {}
                      Some(_) => {
                          if accept_comma {
                              return Err(self.peek_error(match frame {
                                  b'[' => ErrorCode::ExpectedListCommaOrEnd,
                                  b'{' => ErrorCode::ExpectedObjectCommaOrEnd,
                                  _ => unreachable!(),
                              }));
                          } else {
                              break;
                          }
                      }
                      None => {
                          return Err(self.peek_error(match frame {
                              b'[' => ErrorCode::EofWhileParsingList,
                              b'{' => ErrorCode::EofWhileParsingObject,
                              _ => unreachable!(),
                          }));
                      }
                  }
  
                  self.eat_char();
                  frame = match self.scratch.pop() {
                      Some(frame) => frame,
                      None => return Ok(()),
                  };
                  accept_comma = true;
              }
  
              if frame == b'{' {
                  match tri!(self.parse_whitespace()) {
                      Some(b'"') => self.eat_char(),
                      Some(_) => return Err(self.peek_error(ErrorCode::KeyMustBeAString)),
                      None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),
                  }
                  tri!(self.read.ignore_str());
                  match tri!(self.parse_whitespace()) {
                      Some(b':') => self.eat_char(),
                      Some(_) => return Err(self.peek_error(ErrorCode::ExpectedColon)),
                      None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),
                  }
              }
  
              enclosing = Some(frame);
          }
      }
  *)
  Definition ignore_value
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_ignore_value :
    Notations.DoubleColon Self "ignore_value" := {
    Notations.double_colon := ignore_value;
  }.
  
  (*
      fn ignore_integer(&mut self) -> Result<()> {
          match tri!(self.next_char_or_null()) {
              b'0' => {
                  // There can be only one leading '0'.
                  if let b'0'..=b'9' = tri!(self.peek_or_null()) {
                      return Err(self.peek_error(ErrorCode::InvalidNumber));
                  }
              }
              b'1'..=b'9' => {
                  while let b'0'..=b'9' = tri!(self.peek_or_null()) {
                      self.eat_char();
                  }
              }
              _ => {
                  return Err(self.error(ErrorCode::InvalidNumber));
              }
          }
  
          match tri!(self.peek_or_null()) {
              b'.' => self.ignore_decimal(),
              b'e' | b'E' => self.ignore_exponent(),
              _ => Ok(()),
          }
      }
  *)
  Definition ignore_integer
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_ignore_integer :
    Notations.DoubleColon Self "ignore_integer" := {
    Notations.double_colon := ignore_integer;
  }.
  
  (*
      fn ignore_decimal(&mut self) -> Result<()> {
          self.eat_char();
  
          let mut at_least_one_digit = false;
          while let b'0'..=b'9' = tri!(self.peek_or_null()) {
              self.eat_char();
              at_least_one_digit = true;
          }
  
          if !at_least_one_digit {
              return Err(self.peek_error(ErrorCode::InvalidNumber));
          }
  
          match tri!(self.peek_or_null()) {
              b'e' | b'E' => self.ignore_exponent(),
              _ => Ok(()),
          }
      }
  *)
  Definition ignore_decimal
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_ignore_decimal :
    Notations.DoubleColon Self "ignore_decimal" := {
    Notations.double_colon := ignore_decimal;
  }.
  
  (*
      fn ignore_exponent(&mut self) -> Result<()> {
          self.eat_char();
  
          match tri!(self.peek_or_null()) {
              b'+' | b'-' => self.eat_char(),
              _ => {}
          }
  
          // Make sure a digit follows the exponent place.
          match tri!(self.next_char_or_null()) {
              b'0'..=b'9' => {}
              _ => {
                  return Err(self.error(ErrorCode::InvalidNumber));
              }
          }
  
          while let b'0'..=b'9' = tri!(self.peek_or_null()) {
              self.eat_char();
          }
  
          Ok(())
      }
  *)
  Definition ignore_exponent
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_ignore_exponent :
    Notations.DoubleColon Self "ignore_exponent" := {
    Notations.double_colon := ignore_exponent;
  }.
End Impl_serde_json_de_Deserializer_t_R_4.
End Impl_serde_json_de_Deserializer_t_R_4.

Module  Impl_core_str_traits_FromStr_for_serde_json_number_Number_t.
Section Impl_core_str_traits_FromStr_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      type Err = Error;
  *)
  Definition Err : Set := serde_json.error.Error.t.
  
  (*
      fn from_str(s: &str) -> result::Result<Self, Self::Err> {
          Deserializer::from_str(s)
              .parse_any_signed_number()
              .map(Into::into)
      }
  *)
  Definition from_str (s : ref str.t) : M (core.result.Result.t Self Err) :=
    let* s := M.alloc s in
    M.read foo.
  
  Global Instance AssociatedFunction_from_str :
    Notations.DoubleColon Self "from_str" := {
    Notations.double_colon := from_str;
  }.
  
  Global Instance ℐ : core.str.traits.FromStr.Trait Self := {
    core.str.traits.FromStr.Err := Err;
    core.str.traits.FromStr.from_str := from_str;
  }.
End Impl_core_str_traits_FromStr_for_serde_json_number_Number_t.
End Impl_core_str_traits_FromStr_for_serde_json_number_Number_t.

Definition POW10 : M.Val (ref (array f64.t)) := M.run (M.alloc foo).

Module  Impl_serde_de_Deserializer_for_mut_ref_serde_json_de_Deserializer_t_R.
Section Impl_serde_de_Deserializer_for_mut_ref_serde_json_de_Deserializer_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := mut_ref (serde_json.de.Deserializer.t R).
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'n' => {
                  self.eat_char();
                  tri!(self.parse_ident(b"ull"));
                  visitor.visit_unit()
              }
              b't' => {
                  self.eat_char();
                  tri!(self.parse_ident(b"rue"));
                  visitor.visit_bool(true)
              }
              b'f' => {
                  self.eat_char();
                  tri!(self.parse_ident(b"alse"));
                  visitor.visit_bool(false)
              }
              b'-' => {
                  self.eat_char();
                  tri!(self.parse_any_number(false)).visit(visitor)
              }
              b'0'..=b'9' => tri!(self.parse_any_number(true)).visit(visitor),
              b'"' => {
                  self.eat_char();
                  self.scratch.clear();
                  match tri!(self.read.parse_str(&mut self.scratch)) {
                      Reference::Borrowed(s) => visitor.visit_borrowed_str(s),
                      Reference::Copied(s) => visitor.visit_str(s),
                  }
              }
              b'[' => {
                  check_recursion! {
                      self.eat_char();
                      let ret = visitor.visit_seq(SeqAccess::new(self));
                  }
  
                  match (ret, self.end_seq()) {
                      (Ok(ret), Ok(())) => Ok(ret),
                      (Err(err), _) | (_, Err(err)) => Err(err),
                  }
              }
              b'{' => {
                  check_recursion! {
                      self.eat_char();
                      let ret = visitor.visit_map(MapAccess::new(self));
                  }
  
                  match (ret, self.end_map()) {
                      (Ok(ret), Ok(())) => Ok(ret),
                      (Err(err), _) | (_, Err(err)) => Err(err),
                  }
              }
              _ => Err(self.peek_error(ErrorCode::ExpectedSomeValue)),
          };
  
          match value {
              Ok(value) => Ok(value),
              // The de::Error impl creates errors with unknown line and column.
              // Fill in the position here by looking at the current index in the
              // input. There is no way to tell whether this should call `error`
              // or `peek_error` so pick the one that seems correct more often.
              // Worst case, the position is off by one character.
              Err(err) => Err(self.fix_position(err)),
          }
      }
  "
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
      fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b't' => {
                  self.eat_char();
                  tri!(self.parse_ident(b"rue"));
                  visitor.visit_bool(true)
              }
              b'f' => {
                  self.eat_char();
                  tri!(self.parse_ident(b"alse"));
                  visitor.visit_bool(false)
              }
              _ => Err(self.peek_invalid_type(&visitor)),
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.$using(visitor)
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
      fn deserialize_char<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.deserialize_str(visitor)
      }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
      fn deserialize_str<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'"' => {
                  self.eat_char();
                  self.scratch.clear();
                  match tri!(self.read.parse_str(&mut self.scratch)) {
                      Reference::Borrowed(s) => visitor.visit_borrowed_str(s),
                      Reference::Copied(s) => visitor.visit_str(s),
                  }
              }
              _ => Err(self.peek_invalid_type(&visitor)),
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  "
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
      fn deserialize_string<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.deserialize_str(visitor)
      }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
      fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'"' => {
                  self.eat_char();
                  self.scratch.clear();
                  match tri!(self.read.parse_str_raw(&mut self.scratch)) {
                      Reference::Borrowed(b) => visitor.visit_borrowed_bytes(b),
                      Reference::Copied(b) => visitor.visit_bytes(b),
                  }
              }
              b'[' => self.deserialize_seq(visitor),
              _ => Err(self.peek_invalid_type(&visitor)),
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  "
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
      fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.deserialize_bytes(visitor)
      }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
      fn deserialize_option<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          match tri!(self.parse_whitespace()) {
              Some(b'n') => {
                  self.eat_char();
                  tri!(self.parse_ident(b"ull"));
                  visitor.visit_none()
              }
              _ => visitor.visit_some(self),
          }
      }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
      fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'n' => {
                  self.eat_char();
                  tri!(self.parse_ident(b"ull"));
                  visitor.visit_unit()
              }
              _ => Err(self.peek_invalid_type(&visitor)),
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
      fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.deserialize_unit(visitor)
      }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
      fn deserialize_newtype_struct<V>(self, name: &str, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          #[cfg(feature = "raw_value")]
          {
              if name == crate::raw::TOKEN {
                  return self.deserialize_raw_value(visitor);
              }
          }
  
          let _ = name;
          visitor.visit_newtype_struct(self)
      }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
      fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'[' => {
                  check_recursion! {
                      self.eat_char();
                      let ret = visitor.visit_seq(SeqAccess::new(self));
                  }
  
                  match (ret, self.end_seq()) {
                      (Ok(ret), Ok(())) => Ok(ret),
                      (Err(err), _) | (_, Err(err)) => Err(err),
                  }
              }
              _ => Err(self.peek_invalid_type(&visitor)),
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
      fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.deserialize_seq(visitor)
      }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
      fn deserialize_tuple_struct<V>(
          self,
          _name: &'static str,
          _len: usize,
          visitor: V,
      ) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.deserialize_seq(visitor)
      }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_len : usize.t)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
      fn deserialize_map<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'{' => {
                  check_recursion! {
                      self.eat_char();
                      let ret = visitor.visit_map(MapAccess::new(self));
                  }
  
                  match (ret, self.end_map()) {
                      (Ok(ret), Ok(())) => Ok(ret),
                      (Err(err), _) | (_, Err(err)) => Err(err),
                  }
              }
              _ => Err(self.peek_invalid_type(&visitor)),
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
      fn deserialize_struct<V>(
          self,
          _name: &'static str,
          _fields: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          let peek = match tri!(self.parse_whitespace()) {
              Some(b) => b,
              None => {
                  return Err(self.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b'[' => {
                  check_recursion! {
                      self.eat_char();
                      let ret = visitor.visit_seq(SeqAccess::new(self));
                  }
  
                  match (ret, self.end_seq()) {
                      (Ok(ret), Ok(())) => Ok(ret),
                      (Err(err), _) | (_, Err(err)) => Err(err),
                  }
              }
              b'{' => {
                  check_recursion! {
                      self.eat_char();
                      let ret = visitor.visit_map(MapAccess::new(self));
                  }
  
                  match (ret, self.end_map()) {
                      (Ok(ret), Ok(())) => Ok(ret),
                      (Err(err), _) | (_, Err(err)) => Err(err),
                  }
              }
              _ => Err(self.peek_invalid_type(&visitor)),
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.fix_position(err)),
          }
      }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_fields : ref (slice (ref str.t)))
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _fields := M.alloc _fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
      fn deserialize_enum<V>(
          self,
          _name: &str,
          _variants: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          match tri!(self.parse_whitespace()) {
              Some(b'{') => {
                  check_recursion! {
                      self.eat_char();
                      let value = tri!(visitor.visit_enum(VariantAccess::new(self)));
                  }
  
                  match tri!(self.parse_whitespace()) {
                      Some(b'}') => {
                          self.eat_char();
                          Ok(value)
                      }
                      Some(_) => Err(self.error(ErrorCode::ExpectedSomeValue)),
                      None => Err(self.error(ErrorCode::EofWhileParsingObject)),
                  }
              }
              Some(b'"') => visitor.visit_enum(UnitVariantAccess::new(self)),
              Some(_) => Err(self.peek_error(ErrorCode::ExpectedSomeValue)),
              None => Err(self.peek_error(ErrorCode::EofWhileParsingValue)),
          }
      }
  "
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_variants : ref (slice (ref str.t)))
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variants := M.alloc _variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
      fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.deserialize_str(visitor)
      }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
      fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          tri!(self.ignore_value());
          visitor.visit_unit()
      }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_mut_ref_serde_json_de_Deserializer_t_R.
End Impl_serde_de_Deserializer_for_mut_ref_serde_json_de_Deserializer_t_R.

Module  SeqAccess.
Section SeqAccess.
  Context (R : Set).
  
  Record t : Set := {
    de : mut_ref (serde_json.de.Deserializer.t R);
    first : bool.t;
  }.
  
  Definition Get_de :=
    Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
  Definition Get_first :=
    Ref.map (fun α => Some α.(first)) (fun β α => Some (α <| first := β |>)).
End SeqAccess.
End SeqAccess.

Module  Impl_serde_json_de_SeqAccess_t_R_2.
Section Impl_serde_json_de_SeqAccess_t_R_2.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.de.SeqAccess.t R.
  
  (*
      fn new(de: &'a mut Deserializer<R>) -> Self {
          SeqAccess { de, first: true }
      }
  *)
  Definition new (de : mut_ref (serde_json.de.Deserializer.t R)) : M Self :=
    let* de := M.alloc de in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_de_SeqAccess_t_R_2.
End Impl_serde_json_de_SeqAccess_t_R_2.

Module  Impl_serde_de_SeqAccess_for_serde_json_de_SeqAccess_t_R.
Section Impl_serde_de_SeqAccess_for_serde_json_de_SeqAccess_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := serde_json.de.SeqAccess.t R.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>
      where
          T: de::DeserializeSeed<'de>,
      {
          let peek = match tri!(self.de.parse_whitespace()) {
              Some(b']') => {
                  return Ok(None);
              }
              Some(b',') if !self.first => {
                  self.de.eat_char();
                  tri!(self.de.parse_whitespace())
              }
              Some(b) => {
                  if self.first {
                      self.first = false;
                      Some(b)
                  } else {
                      return Err(self.de.peek_error(ErrorCode::ExpectedListCommaOrEnd));
                  }
              }
              None => {
                  return Err(self.de.peek_error(ErrorCode::EofWhileParsingList));
              }
          };
  
          match peek {
              Some(b']') => Err(self.de.peek_error(ErrorCode::TrailingComma)),
              Some(_) => Ok(Some(tri!(seed.deserialize(&mut *self.de)))),
              None => Err(self.de.peek_error(ErrorCode::EofWhileParsingValue)),
          }
      }
  *)
  Definition next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      :
        M
          ltac:(serde_json.error.Result
            (core.option.Option.t T::type["Value"].t)) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_element_seed" := {
    Notations.double_colon := next_element_seed (T := T);
  }.
  
  Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
    serde.de.SeqAccess.Error := Error;
    serde.de.SeqAccess.next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_element_seed (T := T);
    serde.de.SeqAccess.next_element := Datatypes.None;
    serde.de.SeqAccess.size_hint := Datatypes.None;
  }.
End Impl_serde_de_SeqAccess_for_serde_json_de_SeqAccess_t_R.
End Impl_serde_de_SeqAccess_for_serde_json_de_SeqAccess_t_R.

Module  MapAccess.
Section MapAccess.
  Context (R : Set).
  
  Record t : Set := {
    de : mut_ref (serde_json.de.Deserializer.t R);
    first : bool.t;
  }.
  
  Definition Get_de :=
    Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
  Definition Get_first :=
    Ref.map (fun α => Some α.(first)) (fun β α => Some (α <| first := β |>)).
End MapAccess.
End MapAccess.

Module  Impl_serde_json_de_MapAccess_t_R_2.
Section Impl_serde_json_de_MapAccess_t_R_2.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.de.MapAccess.t R.
  
  (*
      fn new(de: &'a mut Deserializer<R>) -> Self {
          MapAccess { de, first: true }
      }
  *)
  Definition new (de : mut_ref (serde_json.de.Deserializer.t R)) : M Self :=
    let* de := M.alloc de in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_de_MapAccess_t_R_2.
End Impl_serde_json_de_MapAccess_t_R_2.

Module  Impl_serde_de_MapAccess_for_serde_json_de_MapAccess_t_R.
Section Impl_serde_de_MapAccess_for_serde_json_de_MapAccess_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := serde_json.de.MapAccess.t R.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>
      where
          K: de::DeserializeSeed<'de>,
      {
          let peek = match tri!(self.de.parse_whitespace()) {
              Some(b'}') => {
                  return Ok(None);
              }
              Some(b',') if !self.first => {
                  self.de.eat_char();
                  tri!(self.de.parse_whitespace())
              }
              Some(b) => {
                  if self.first {
                      self.first = false;
                      Some(b)
                  } else {
                      return Err(self.de.peek_error(ErrorCode::ExpectedObjectCommaOrEnd));
                  }
              }
              None => {
                  return Err(self.de.peek_error(ErrorCode::EofWhileParsingObject));
              }
          };
  
          match peek {
              Some(b'"') => seed.deserialize(MapKey { de: &mut *self.de }).map(Some),
              Some(b'}') => Err(self.de.peek_error(ErrorCode::TrailingComma)),
              Some(_) => Err(self.de.peek_error(ErrorCode::KeyMustBeAString)),
              None => Err(self.de.peek_error(ErrorCode::EofWhileParsingValue)),
          }
      }
  "
  *)
  Definition next_key_seed
      {K : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait K}
      (self : mut_ref Self)
      (seed : K)
      :
        M
          ltac:(serde_json.error.Result
            (core.option.Option.t K::type["Value"].t)) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_key_seed
      {K : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait K} :
    Notations.DoubleColon Self "next_key_seed" := {
    Notations.double_colon := next_key_seed (K := K);
  }.
  
  (*
      fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>
      where
          V: de::DeserializeSeed<'de>,
      {
          tri!(self.de.parse_object_colon());
  
          seed.deserialize(&mut *self.de)
      }
  *)
  Definition next_value_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V}
      (self : mut_ref Self)
      (seed : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_value_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
    Notations.DoubleColon Self "next_value_seed" := {
    Notations.double_colon := next_value_seed (V := V);
  }.
  
  Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
    serde.de.MapAccess.Error := Error;
    serde.de.MapAccess.next_key_seed
      {K : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait K} :=
      next_key_seed (K := K);
    serde.de.MapAccess.next_value_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
      next_value_seed (V := V);
    serde.de.MapAccess.next_entry_seed := Datatypes.None;
    serde.de.MapAccess.next_key := Datatypes.None;
    serde.de.MapAccess.next_value := Datatypes.None;
    serde.de.MapAccess.next_entry := Datatypes.None;
    serde.de.MapAccess.size_hint := Datatypes.None;
  }.
End Impl_serde_de_MapAccess_for_serde_json_de_MapAccess_t_R.
End Impl_serde_de_MapAccess_for_serde_json_de_MapAccess_t_R.

Module  VariantAccess.
Section VariantAccess.
  Context (R : Set).
  
  Record t : Set := {
    de : mut_ref (serde_json.de.Deserializer.t R);
  }.
  
  Definition Get_de :=
    Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
End VariantAccess.
End VariantAccess.

Module  Impl_serde_json_de_VariantAccess_t_R_2.
Section Impl_serde_json_de_VariantAccess_t_R_2.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.de.VariantAccess.t R.
  
  (*
      fn new(de: &'a mut Deserializer<R>) -> Self {
          VariantAccess { de }
      }
  *)
  Definition new (de : mut_ref (serde_json.de.Deserializer.t R)) : M Self :=
    let* de := M.alloc de in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_de_VariantAccess_t_R_2.
End Impl_serde_json_de_VariantAccess_t_R_2.

Module  Impl_serde_de_EnumAccess_for_serde_json_de_VariantAccess_t_R.
Section Impl_serde_de_EnumAccess_for_serde_json_de_VariantAccess_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := serde_json.de.VariantAccess.t R.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      type Variant = Self;
  *)
  Definition Variant : Set := Self.
  
  (*
      fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>
      where
          V: de::DeserializeSeed<'de>,
      {
          let val = tri!(seed.deserialize(&mut *self.de));
          tri!(self.de.parse_object_colon());
          Ok((val, self))
      }
  *)
  Definition variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V}
      (self : Self)
      (seed : V)
      : M ltac:(serde_json.error.Result (V::type["Value"].t * Self)) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
    Notations.DoubleColon Self "variant_seed" := {
    Notations.double_colon := variant_seed (V := V);
  }.
  
  Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
    serde.de.EnumAccess.Error := Error;
    serde.de.EnumAccess.Variant := Variant;
    serde.de.EnumAccess.variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
      variant_seed (V := V);
    serde.de.EnumAccess.variant := Datatypes.None;
  }.
End Impl_serde_de_EnumAccess_for_serde_json_de_VariantAccess_t_R.
End Impl_serde_de_EnumAccess_for_serde_json_de_VariantAccess_t_R.

Module  Impl_serde_de_VariantAccess_for_serde_json_de_VariantAccess_t_R.
Section Impl_serde_de_VariantAccess_for_serde_json_de_VariantAccess_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := serde_json.de.VariantAccess.t R.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn unit_variant(self) -> Result<()> {
          de::Deserialize::deserialize(self.de)
      }
  *)
  Definition unit_variant
      (self : Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_unit_variant :
    Notations.DoubleColon Self "unit_variant" := {
    Notations.double_colon := unit_variant;
  }.
  
  (*
      fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value>
      where
          T: de::DeserializeSeed<'de>,
      {
          seed.deserialize(self.de)
      }
  *)
  Definition newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : Self)
      (seed : T)
      : M ltac:(serde_json.error.Result T::type["Value"].t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "newtype_variant_seed" := {
    Notations.double_colon := newtype_variant_seed (T := T);
  }.
  
  (*
      fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          de::Deserializer::deserialize_seq(self.de, visitor)
      }
  *)
  Definition tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "tuple_variant" := {
    Notations.double_colon := tuple_variant (V := V);
  }.
  
  (*
      fn struct_variant<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          de::Deserializer::deserialize_struct(self.de, "", fields, visitor)
      }
  *)
  Definition struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (fields : ref (slice (ref str.t)))
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* fields := M.alloc fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "struct_variant" := {
    Notations.double_colon := struct_variant (V := V);
  }.
  
  Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
    serde.de.VariantAccess.Error := Error;
    serde.de.VariantAccess.unit_variant := unit_variant;
    serde.de.VariantAccess.newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      newtype_variant_seed (T := T);
    serde.de.VariantAccess.tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      tuple_variant (V := V);
    serde.de.VariantAccess.struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      struct_variant (V := V);
    serde.de.VariantAccess.newtype_variant := Datatypes.None;
  }.
End Impl_serde_de_VariantAccess_for_serde_json_de_VariantAccess_t_R.
End Impl_serde_de_VariantAccess_for_serde_json_de_VariantAccess_t_R.

Module  UnitVariantAccess.
Section UnitVariantAccess.
  Context (R : Set).
  
  Record t : Set := {
    de : mut_ref (serde_json.de.Deserializer.t R);
  }.
  
  Definition Get_de :=
    Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
End UnitVariantAccess.
End UnitVariantAccess.

Module  Impl_serde_json_de_UnitVariantAccess_t_R_2.
Section Impl_serde_json_de_UnitVariantAccess_t_R_2.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.de.UnitVariantAccess.t R.
  
  (*
      fn new(de: &'a mut Deserializer<R>) -> Self {
          UnitVariantAccess { de }
      }
  *)
  Definition new (de : mut_ref (serde_json.de.Deserializer.t R)) : M Self :=
    let* de := M.alloc de in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_de_UnitVariantAccess_t_R_2.
End Impl_serde_json_de_UnitVariantAccess_t_R_2.

Module  Impl_serde_de_EnumAccess_for_serde_json_de_UnitVariantAccess_t_R.
Section Impl_serde_de_EnumAccess_for_serde_json_de_UnitVariantAccess_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := serde_json.de.UnitVariantAccess.t R.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      type Variant = Self;
  *)
  Definition Variant : Set := Self.
  
  (*
      fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>
      where
          V: de::DeserializeSeed<'de>,
      {
          let variant = tri!(seed.deserialize(&mut *self.de));
          Ok((variant, self))
      }
  *)
  Definition variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V}
      (self : Self)
      (seed : V)
      : M ltac:(serde_json.error.Result (V::type["Value"].t * Self)) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
    Notations.DoubleColon Self "variant_seed" := {
    Notations.double_colon := variant_seed (V := V);
  }.
  
  Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
    serde.de.EnumAccess.Error := Error;
    serde.de.EnumAccess.Variant := Variant;
    serde.de.EnumAccess.variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
      variant_seed (V := V);
    serde.de.EnumAccess.variant := Datatypes.None;
  }.
End Impl_serde_de_EnumAccess_for_serde_json_de_UnitVariantAccess_t_R.
End Impl_serde_de_EnumAccess_for_serde_json_de_UnitVariantAccess_t_R.

Module  Impl_serde_de_VariantAccess_for_serde_json_de_UnitVariantAccess_t_R.
Section Impl_serde_de_VariantAccess_for_serde_json_de_UnitVariantAccess_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := serde_json.de.UnitVariantAccess.t R.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn unit_variant(self) -> Result<()> {
          Ok(())
      }
  *)
  Definition unit_variant
      (self : Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_unit_variant :
    Notations.DoubleColon Self "unit_variant" := {
    Notations.double_colon := unit_variant;
  }.
  
  (*
      fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value>
      where
          T: de::DeserializeSeed<'de>,
      {
          Err(de::Error::invalid_type(
              Unexpected::UnitVariant,
              &"newtype variant",
          ))
      }
  *)
  Definition newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : Self)
      (_seed : T)
      : M ltac:(serde_json.error.Result T::type["Value"].t) :=
    let* self := M.alloc self in
    let* _seed := M.alloc _seed in
    M.read foo.
  
  Global Instance AssociatedFunction_newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "newtype_variant_seed" := {
    Notations.double_colon := newtype_variant_seed (T := T);
  }.
  
  (*
      fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          Err(de::Error::invalid_type(
              Unexpected::UnitVariant,
              &"tuple variant",
          ))
      }
  *)
  Definition tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (_visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "tuple_variant" := {
    Notations.double_colon := tuple_variant (V := V);
  }.
  
  (*
      fn struct_variant<V>(self, _fields: &'static [&'static str], _visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          Err(de::Error::invalid_type(
              Unexpected::UnitVariant,
              &"struct variant",
          ))
      }
  *)
  Definition struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_fields : ref (slice (ref str.t)))
      (_visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* _fields := M.alloc _fields in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "struct_variant" := {
    Notations.double_colon := struct_variant (V := V);
  }.
  
  Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
    serde.de.VariantAccess.Error := Error;
    serde.de.VariantAccess.unit_variant := unit_variant;
    serde.de.VariantAccess.newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      newtype_variant_seed (T := T);
    serde.de.VariantAccess.tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      tuple_variant (V := V);
    serde.de.VariantAccess.struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      struct_variant (V := V);
    serde.de.VariantAccess.newtype_variant := Datatypes.None;
  }.
End Impl_serde_de_VariantAccess_for_serde_json_de_UnitVariantAccess_t_R.
End Impl_serde_de_VariantAccess_for_serde_json_de_UnitVariantAccess_t_R.

Module  MapKey.
Section MapKey.
  Context (R : Set).
  
  Record t : Set := {
    de : mut_ref (serde_json.de.Deserializer.t R);
  }.
  
  Definition Get_de :=
    Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
End MapKey.
End MapKey.

Module  Impl_serde_json_de_MapKey_t_R_2.
Section Impl_serde_json_de_MapKey_t_R_2.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.de.MapKey.t R.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.de.eat_char();
  
              match tri!(self.de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),
              }
  
              let value = tri!(self.de.$delegate(visitor));
  
              match tri!(self.de.peek()) {
                  Some(b'"') => self.de.eat_char(),
                  _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),
              }
  
              Ok(value)
          }
  "
  *)
  Definition deserialize_number
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_number
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_number" := {
    Notations.double_colon := deserialize_number (V := V);
  }.
End Impl_serde_json_de_MapKey_t_R_2.
End Impl_serde_json_de_MapKey_t_R_2.

Module  Impl_serde_de_Deserializer_for_serde_json_de_MapKey_t_R.
Section Impl_serde_de_Deserializer_for_serde_json_de_MapKey_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := serde_json.de.MapKey.t R.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.de.eat_char();
          self.de.scratch.clear();
          match tri!(self.de.read.parse_str(&mut self.de.scratch)) {
              Reference::Borrowed(s) => visitor.visit_borrowed_str(s),
              Reference::Copied(s) => visitor.visit_str(s),
          }
      }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.de.eat_char();
  
              match tri!(self.de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),
              }
  
              let value = tri!(self.de.$delegate(visitor));
  
              match tri!(self.de.peek()) {
                  Some(b'"') => self.de.eat_char(),
                  _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),
              }
  
              Ok(value)
          }
  "
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.de.eat_char();
  
              match tri!(self.de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(self.de.error(ErrorCode::ExpectedNumericKey)),
              }
  
              let value = tri!(self.de.$delegate(visitor));
  
              match tri!(self.de.peek()) {
                  Some(b'"') => self.de.eat_char(),
                  _ => return Err(self.de.peek_error(ErrorCode::ExpectedDoubleQuote)),
              }
  
              Ok(value)
          }
  "
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value>
          where
              V: de::Visitor<'de>,
          {
              self.deserialize_number(visitor)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
      fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.de.eat_char();
  
          let peek = match tri!(self.de.next_char()) {
              Some(b) => b,
              None => {
                  return Err(self.de.peek_error(ErrorCode::EofWhileParsingValue));
              }
          };
  
          let value = match peek {
              b't' => {
                  tri!(self.de.parse_ident(b"rue\""));
                  visitor.visit_bool(true)
              }
              b'f' => {
                  tri!(self.de.parse_ident(b"alse\""));
                  visitor.visit_bool(false)
              }
              _ => {
                  self.de.scratch.clear();
                  let s = tri!(self.de.read.parse_str(&mut self.de.scratch));
                  Err(de::Error::invalid_type(Unexpected::Str(&s), &visitor))
              }
          };
  
          match value {
              Ok(value) => Ok(value),
              Err(err) => Err(self.de.fix_position(err)),
          }
      }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
      fn deserialize_option<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          // Map keys cannot be null.
          visitor.visit_some(self)
      }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
      fn deserialize_newtype_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          #[cfg(feature = "raw_value")]
          {
              if name == crate::raw::TOKEN {
                  return self.de.deserialize_raw_value(visitor);
              }
          }
  
          let _ = name;
          visitor.visit_newtype_struct(self)
      }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
      fn deserialize_enum<V>(
          self,
          name: &'static str,
          variants: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.de.deserialize_enum(name, variants, visitor)
      }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (variants : ref (slice (ref str.t)))
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* variants := M.alloc variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
      fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.de.deserialize_bytes(visitor)
      }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
      fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>
      where
          V: de::Visitor<'de>,
      {
          self.de.deserialize_bytes(visitor)
      }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M ltac:(serde_json.error.Result V::type["Value"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* fields := M.alloc fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_serde_json_de_MapKey_t_R.
End Impl_serde_de_Deserializer_for_serde_json_de_MapKey_t_R.

Module  StreamDeserializer.
Section StreamDeserializer.
  Context (R T : Set).
  
  Record t : Set := {
    de : serde_json.de.Deserializer.t R;
    offset : usize.t;
    failed : bool.t;
    output : core.marker.PhantomData.t T;
    lifetime : core.marker.PhantomData.t (ref unit);
  }.
  
  Definition Get_de :=
    Ref.map (fun α => Some α.(de)) (fun β α => Some (α <| de := β |>)).
  Definition Get_offset :=
    Ref.map (fun α => Some α.(offset)) (fun β α => Some (α <| offset := β |>)).
  Definition Get_failed :=
    Ref.map (fun α => Some α.(failed)) (fun β α => Some (α <| failed := β |>)).
  Definition Get_output :=
    Ref.map (fun α => Some α.(output)) (fun β α => Some (α <| output := β |>)).
  Definition Get_lifetime :=
    Ref.map
      (fun α => Some α.(lifetime))
      (fun β α => Some (α <| lifetime := β |>)).
End StreamDeserializer.
End StreamDeserializer.

Module  Impl_serde_json_de_StreamDeserializer_t_R_T_2.
Section Impl_serde_json_de_StreamDeserializer_t_R_T_2.
  Context {R T : Set}.
  
  Definition Self : Set := serde_json.de.StreamDeserializer.t R T.
  
  (*
      pub fn new(read: R) -> Self {
          let offset = read.byte_offset();
          StreamDeserializer {
              de: Deserializer::new(read),
              offset,
              failed: false,
              output: PhantomData,
              lifetime: PhantomData,
          }
      }
  *)
  Definition new (read : R) : M Self :=
    let* read := M.alloc read in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn byte_offset(&self) -> usize {
          self.offset
      }
  *)
  Definition byte_offset (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_byte_offset :
    Notations.DoubleColon Self "byte_offset" := {
    Notations.double_colon := byte_offset;
  }.
  
  (*
      fn peek_end_of_value(&mut self) -> Result<()> {
          match tri!(self.de.peek()) {
              Some(b' ' | b'\n' | b'\t' | b'\r' | b'"' | b'[' | b']' | b'{' | b'}' | b',' | b':')
              | None => Ok(()),
              Some(_) => {
                  let position = self.de.read.peek_position();
                  Err(Error::syntax(
                      ErrorCode::TrailingCharacters,
                      position.line,
                      position.column,
                  ))
              }
          }
      }
  "
  *)
  Definition peek_end_of_value
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek_end_of_value :
    Notations.DoubleColon Self "peek_end_of_value" := {
    Notations.double_colon := peek_end_of_value;
  }.
End Impl_serde_json_de_StreamDeserializer_t_R_T_2.
End Impl_serde_json_de_StreamDeserializer_t_R_T_2.

Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_de_StreamDeserializer_t_R_T.
Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_de_StreamDeserializer_t_R_T.
  Context {R T : Set}.
  
  Context
    {ℋ_0 : serde_json.read.Read.Trait R}
    {ℋ_1 : serde.de.Deserialize.Trait T}.
  
  Definition Self : Set := serde_json.de.StreamDeserializer.t R T.
  
  (*
      type Item = Result<T>;
  *)
  Definition Item : Set := ltac:(serde_json.error.Result T).
  
  (*
      fn next(&mut self) -> Option<Result<T>> {
          if R::should_early_return_if_failed && self.failed {
              return None;
          }
  
          // skip whitespaces, if any
          // this helps with trailing whitespaces, since whitespaces between
          // values are handled for us.
          match self.de.parse_whitespace() {
              Ok(None) => {
                  self.offset = self.de.read.byte_offset();
                  None
              }
              Ok(Some(b)) => {
                  // If the value does not have a clear way to show the end of the value
                  // (like numbers, null, true etc.) we have to look for whitespace or
                  // the beginning of a self-delineated value.
                  let self_delineated_value = match b {
                      b'[' | b'"' | b'{' => true,
                      _ => false,
                  };
                  self.offset = self.de.read.byte_offset();
                  let result = de::Deserialize::deserialize(&mut self.de);
  
                  Some(match result {
                      Ok(value) => {
                          self.offset = self.de.read.byte_offset();
                          if self_delineated_value {
                              Ok(value)
                          } else {
                              self.peek_end_of_value().map(|()| value)
                          }
                      }
                      Err(e) => {
                          self.de.read.set_failed(&mut self.failed);
                          Err(e)
                      }
                  })
              }
              Err(e) => {
                  self.de.read.set_failed(&mut self.failed);
                  Some(Err(e))
              }
          }
      }
  "
  *)
  Definition next
      (self : mut_ref Self)
      : M (core.option.Option.t ltac:(serde_json.error.Result T)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_de_StreamDeserializer_t_R_T.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_de_StreamDeserializer_t_R_T.

Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_de_StreamDeserializer_t_R_T.
Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_de_StreamDeserializer_t_R_T.
  Context {R T : Set}.
  
  Context
    {ℋ_0 : serde_json.read.Read.Trait R}
    {ℋ_1 : serde_json.read.Fused.Trait R}
    {ℋ_2 : serde.de.Deserialize.Trait T}.
  
  Definition Self : Set := serde_json.de.StreamDeserializer.t R T.
  
  Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
  }.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_de_StreamDeserializer_t_R_T.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_de_StreamDeserializer_t_R_T.

(*
fn from_trait<'de, R, T>(read: R) -> Result<T>
where
    R: Read<'de>,
    T: de::Deserialize<'de>,
{
    let mut de = Deserializer::new(read);
    let value = tri!(de::Deserialize::deserialize(&mut de));

    // Make sure the whole stream has been consumed.
    tri!(de.end());
    Ok(value)
}
*)
Definition from_trait
    {R T : Set}
    {ℋ_0 : serde_json.read.Read.Trait R}
    {ℋ_1 : serde.de.Deserialize.Trait T}
    (read : R)
    : M ltac:(serde_json.error.Result T) :=
  let* read := M.alloc read in
  M.read foo.

(*
pub fn from_reader<R, T>(rdr: R) -> Result<T>
where
    R: crate::io::Read,
    T: de::DeserializeOwned,
{
    from_trait(read::IoRead::new(rdr))
}
*)
Definition from_reader
    {R T : Set}
    {ℋ_0 : std.io.Read.Trait R}
    {ℋ_1 : serde.de.DeserializeOwned.Trait T}
    (rdr : R)
    : M ltac:(serde_json.error.Result T) :=
  let* rdr := M.alloc rdr in
  M.read foo.

(*
pub fn from_slice<'a, T>(v: &'a [u8]) -> Result<T>
where
    T: de::Deserialize<'a>,
{
    from_trait(read::SliceRead::new(v))
}
*)
Definition from_slice
    {T : Set}
    {ℋ_0 : serde.de.Deserialize.Trait T}
    (v : ref (slice u8.t))
    : M ltac:(serde_json.error.Result T) :=
  let* v := M.alloc v in
  M.read foo.

(*
pub fn from_str<'a, T>(s: &'a str) -> Result<T>
where
    T: de::Deserialize<'a>,
{
    from_trait(read::StrRead::new(s))
}
*)
Definition from_str
    {T : Set}
    {ℋ_0 : serde.de.Deserialize.Trait T}
    (s : ref str.t)
    : M ltac:(serde_json.error.Result T) :=
  let* s := M.alloc s in
  M.read foo.

Module error.
  Module  Error.
  Section Error.
    Record t : Set := {
      err :
        alloc.boxed.Box.t
          serde_json.error.ErrorImpl.t
          alloc.boxed.Box.Default.A;
    }.
    
    Definition Get_err :=
      Ref.map (fun α => Some α.(err)) (fun β α => Some (α <| err := β |>)).
  End Error.
  End Error.
  
  Ltac Result T := exact (core.result.Result.t T serde_json.error.Error.t).
  
  Module  Impl_serde_json_error_Error_t.
  Section Impl_serde_json_error_Error_t.
    Definition Self : Set := serde_json.error.Error.t.
    
    (*
        pub fn line(&self) -> usize {
            self.err.line
        }
    *)
    Definition line (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_line :
      Notations.DoubleColon Self "line" := {
      Notations.double_colon := line;
    }.
    
    (*
        pub fn column(&self) -> usize {
            self.err.column
        }
    *)
    Definition column (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_column :
      Notations.DoubleColon Self "column" := {
      Notations.double_colon := column;
    }.
    
    (*
        pub fn classify(&self) -> Category {
            match self.err.code {
                ErrorCode::Message(_) => Category::Data,
                ErrorCode::Io(_) => Category::Io,
                ErrorCode::EofWhileParsingList
                | ErrorCode::EofWhileParsingObject
                | ErrorCode::EofWhileParsingString
                | ErrorCode::EofWhileParsingValue => Category::Eof,
                ErrorCode::ExpectedColon
                | ErrorCode::ExpectedListCommaOrEnd
                | ErrorCode::ExpectedObjectCommaOrEnd
                | ErrorCode::ExpectedSomeIdent
                | ErrorCode::ExpectedSomeValue
                | ErrorCode::ExpectedDoubleQuote
                | ErrorCode::InvalidEscape
                | ErrorCode::InvalidNumber
                | ErrorCode::NumberOutOfRange
                | ErrorCode::InvalidUnicodeCodePoint
                | ErrorCode::ControlCharacterWhileParsingString
                | ErrorCode::KeyMustBeAString
                | ErrorCode::ExpectedNumericKey
                | ErrorCode::FloatKeyMustBeFinite
                | ErrorCode::LoneLeadingSurrogateInHexEscape
                | ErrorCode::TrailingComma
                | ErrorCode::TrailingCharacters
                | ErrorCode::UnexpectedEndOfHexEscape
                | ErrorCode::RecursionLimitExceeded => Category::Syntax,
            }
        }
    *)
    Definition classify (self : ref Self) : M serde_json.error.Category.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_classify :
      Notations.DoubleColon Self "classify" := {
      Notations.double_colon := classify;
    }.
    
    (*
        pub fn is_io(&self) -> bool {
            self.classify() == Category::Io
        }
    *)
    Definition is_io (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_io :
      Notations.DoubleColon Self "is_io" := {
      Notations.double_colon := is_io;
    }.
    
    (*
        pub fn is_syntax(&self) -> bool {
            self.classify() == Category::Syntax
        }
    *)
    Definition is_syntax (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_syntax :
      Notations.DoubleColon Self "is_syntax" := {
      Notations.double_colon := is_syntax;
    }.
    
    (*
        pub fn is_data(&self) -> bool {
            self.classify() == Category::Data
        }
    *)
    Definition is_data (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_data :
      Notations.DoubleColon Self "is_data" := {
      Notations.double_colon := is_data;
    }.
    
    (*
        pub fn is_eof(&self) -> bool {
            self.classify() == Category::Eof
        }
    *)
    Definition is_eof (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_eof :
      Notations.DoubleColon Self "is_eof" := {
      Notations.double_colon := is_eof;
    }.
    
    (*
        pub fn io_error_kind(&self) -> Option<ErrorKind> {
            if let ErrorCode::Io(io_error) = &self.err.code {
                Some(io_error.kind())
            } else {
                None
            }
        }
    *)
    Definition io_error_kind
        (self : ref Self)
        : M (core.option.Option.t std.io.error.ErrorKind.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_io_error_kind :
      Notations.DoubleColon Self "io_error_kind" := {
      Notations.double_colon := io_error_kind;
    }.
  End Impl_serde_json_error_Error_t.
  End Impl_serde_json_error_Error_t.
  
  Module Category.
    Inductive t : Set :=
    | Io
    | Syntax
    | Data
    | Eof.
  End Category.
  
  Module  Impl_core_marker_Copy_for_serde_json_error_Category_t.
  Section Impl_core_marker_Copy_for_serde_json_error_Category_t.
    Definition Self : Set := serde_json.error.Category.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_serde_json_error_Category_t.
  End Impl_core_marker_Copy_for_serde_json_error_Category_t.
  
  Module  Impl_core_clone_Clone_for_serde_json_error_Category_t.
  Section Impl_core_clone_Clone_for_serde_json_error_Category_t.
    Definition Self : Set := serde_json.error.Category.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M serde_json.error.Category.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_serde_json_error_Category_t.
  End Impl_core_clone_Clone_for_serde_json_error_Category_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_serde_json_error_Category_t.
  Section Impl_core_marker_StructuralPartialEq_for_serde_json_error_Category_t.
    Definition Self : Set := serde_json.error.Category.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_serde_json_error_Category_t.
  End Impl_core_marker_StructuralPartialEq_for_serde_json_error_Category_t.
  
  Module  Impl_core_cmp_PartialEq_for_serde_json_error_Category_t.
  Section Impl_core_cmp_PartialEq_for_serde_json_error_Category_t.
    Definition Self : Set := serde_json.error.Category.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.error.Category.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_serde_json_error_Category_t.
  End Impl_core_cmp_PartialEq_for_serde_json_error_Category_t.
  
  Module  Impl_core_marker_StructuralEq_for_serde_json_error_Category_t.
  Section Impl_core_marker_StructuralEq_for_serde_json_error_Category_t.
    Definition Self : Set := serde_json.error.Category.t.
    
    Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralEq_for_serde_json_error_Category_t.
  End Impl_core_marker_StructuralEq_for_serde_json_error_Category_t.
  
  Module  Impl_core_cmp_Eq_for_serde_json_error_Category_t.
  Section Impl_core_cmp_Eq_for_serde_json_error_Category_t.
    Definition Self : Set := serde_json.error.Category.t.
    
    (*
    Eq
    *)
    Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_assert_receiver_is_total_eq :
      Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
      Notations.double_colon := assert_receiver_is_total_eq;
    }.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq :=
        Datatypes.Some assert_receiver_is_total_eq;
    }.
  End Impl_core_cmp_Eq_for_serde_json_error_Category_t.
  End Impl_core_cmp_Eq_for_serde_json_error_Category_t.
  
  Module  Impl_core_fmt_Debug_for_serde_json_error_Category_t.
  Section Impl_core_fmt_Debug_for_serde_json_error_Category_t.
    Definition Self : Set := serde_json.error.Category.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_serde_json_error_Category_t.
  End Impl_core_fmt_Debug_for_serde_json_error_Category_t.
  
  Module  Impl_core_convert_From_serde_json_error_Error_t_for_std_io_error_Error_t.
  Section Impl_core_convert_From_serde_json_error_Error_t_for_std_io_error_Error_t.
    Definition Self : Set := std.io.error.Error.t.
    
    (*
        fn from(j: Error) -> Self {
            if let ErrorCode::Io(err) = j.err.code {
                err
            } else {
                match j.classify() {
                    Category::Io => unreachable!(),
                    Category::Syntax | Category::Data => io::Error::new(ErrorKind::InvalidData, j),
                    Category::Eof => io::Error::new(ErrorKind::UnexpectedEof, j),
                }
            }
        }
    *)
    Definition from (j : serde_json.error.Error.t) : M Self :=
      let* j := M.alloc j in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := serde_json.error.Error.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_serde_json_error_Error_t_for_std_io_error_Error_t.
  End Impl_core_convert_From_serde_json_error_Error_t_for_std_io_error_Error_t.
  
  Module  ErrorImpl.
  Section ErrorImpl.
    Record t : Set := {
      code : serde_json.error.ErrorCode.t;
      line : usize.t;
      column : usize.t;
    }.
    
    Definition Get_code :=
      Ref.map (fun α => Some α.(code)) (fun β α => Some (α <| code := β |>)).
    Definition Get_line :=
      Ref.map (fun α => Some α.(line)) (fun β α => Some (α <| line := β |>)).
    Definition Get_column :=
      Ref.map
        (fun α => Some α.(column))
        (fun β α => Some (α <| column := β |>)).
  End ErrorImpl.
  End ErrorImpl.
  
  Module ErrorCode.
    Inductive t : Set :=
    | Message (_ : alloc.boxed.Box.t str.t alloc.boxed.Box.Default.A)
    | Io (_ : std.io.error.Error.t)
    | EofWhileParsingList
    | EofWhileParsingObject
    | EofWhileParsingString
    | EofWhileParsingValue
    | ExpectedColon
    | ExpectedListCommaOrEnd
    | ExpectedObjectCommaOrEnd
    | ExpectedSomeIdent
    | ExpectedSomeValue
    | ExpectedDoubleQuote
    | InvalidEscape
    | InvalidNumber
    | NumberOutOfRange
    | InvalidUnicodeCodePoint
    | ControlCharacterWhileParsingString
    | KeyMustBeAString
    | ExpectedNumericKey
    | FloatKeyMustBeFinite
    | LoneLeadingSurrogateInHexEscape
    | TrailingComma
    | TrailingCharacters
    | UnexpectedEndOfHexEscape
    | RecursionLimitExceeded.
    
    Definition Get_Message_0 :=
      Ref.map
        (fun α => match α with | Message α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | Message _ => Some (Message β) | _ => None end).
    
    Definition Get_Io_0 :=
      Ref.map
        (fun α => match α with | Io α0 => Some α0 | _ => None end)
        (fun β α => match α with | Io _ => Some (Io β) | _ => None end).
  End ErrorCode.
  
  Module  Impl_serde_json_error_Error_t_2.
  Section Impl_serde_json_error_Error_t_2.
    Definition Self : Set := serde_json.error.Error.t.
    
    (*
        pub(crate) fn syntax(code: ErrorCode, line: usize, column: usize) -> Self {
            Error {
                err: Box::new(ErrorImpl { code, line, column }),
            }
        }
    *)
    Definition syntax
        (code : serde_json.error.ErrorCode.t)
        (line : usize.t)
        (column : usize.t)
        : M Self :=
      let* code := M.alloc code in
      let* line := M.alloc line in
      let* column := M.alloc column in
      M.read foo.
    
    Global Instance AssociatedFunction_syntax :
      Notations.DoubleColon Self "syntax" := {
      Notations.double_colon := syntax;
    }.
    
    (*
        pub fn io(error: io::Error) -> Self {
            Error {
                err: Box::new(ErrorImpl {
                    code: ErrorCode::Io(error),
                    line: 0,
                    column: 0,
                }),
            }
        }
    *)
    Definition io (error : std.io.error.Error.t) : M Self :=
      let* error := M.alloc error in
      M.read foo.
    
    Global Instance AssociatedFunction_io : Notations.DoubleColon Self "io" := {
      Notations.double_colon := io;
    }.
    
    (*
        pub(crate) fn fix_position<F>(self, f: F) -> Self
        where
            F: FnOnce(ErrorCode) -> Error,
        {
            if self.err.line == 0 {
                f(self.err.code)
            } else {
                self
            }
        }
    *)
    Definition fix_position
        {F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := serde_json.error.ErrorCode.t)}
        (self : Self)
        (f : F)
        : M Self :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fix_position
        {F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := serde_json.error.ErrorCode.t)} :
      Notations.DoubleColon Self "fix_position" := {
      Notations.double_colon := fix_position (F := F);
    }.
  End Impl_serde_json_error_Error_t_2.
  End Impl_serde_json_error_Error_t_2.
  
  Module  Impl_core_fmt_Display_for_serde_json_error_ErrorCode_t.
  Section Impl_core_fmt_Display_for_serde_json_error_ErrorCode_t.
    Definition Self : Set := serde_json.error.ErrorCode.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                ErrorCode::Message(msg) => f.write_str(msg),
                ErrorCode::Io(err) => Display::fmt(err, f),
                ErrorCode::EofWhileParsingList => f.write_str("EOF while parsing a list"),
                ErrorCode::EofWhileParsingObject => f.write_str("EOF while parsing an object"),
                ErrorCode::EofWhileParsingString => f.write_str("EOF while parsing a string"),
                ErrorCode::EofWhileParsingValue => f.write_str("EOF while parsing a value"),
                ErrorCode::ExpectedColon => f.write_str("expected `:`"),
                ErrorCode::ExpectedListCommaOrEnd => f.write_str("expected `,` or `]`"),
                ErrorCode::ExpectedObjectCommaOrEnd => f.write_str("expected `,` or `}`"),
                ErrorCode::ExpectedSomeIdent => f.write_str("expected ident"),
                ErrorCode::ExpectedSomeValue => f.write_str("expected value"),
                ErrorCode::ExpectedDoubleQuote => f.write_str("expected `\"`"),
                ErrorCode::InvalidEscape => f.write_str("invalid escape"),
                ErrorCode::InvalidNumber => f.write_str("invalid number"),
                ErrorCode::NumberOutOfRange => f.write_str("number out of range"),
                ErrorCode::InvalidUnicodeCodePoint => f.write_str("invalid unicode code point"),
                ErrorCode::ControlCharacterWhileParsingString => {
                    f.write_str("control character (\\u0000-\\u001F) found while parsing a string")
                }
                ErrorCode::KeyMustBeAString => f.write_str("key must be a string"),
                ErrorCode::ExpectedNumericKey => {
                    f.write_str("invalid value: expected key to be a number in quotes")
                }
                ErrorCode::FloatKeyMustBeFinite => {
                    f.write_str("float key must be finite (got NaN or +/-inf)")
                }
                ErrorCode::LoneLeadingSurrogateInHexEscape => {
                    f.write_str("lone leading surrogate in hex escape")
                }
                ErrorCode::TrailingComma => f.write_str("trailing comma"),
                ErrorCode::TrailingCharacters => f.write_str("trailing characters"),
                ErrorCode::UnexpectedEndOfHexEscape => f.write_str("unexpected end of hex escape"),
                ErrorCode::RecursionLimitExceeded => f.write_str("recursion limit exceeded"),
            }
        }
    "
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_serde_json_error_ErrorCode_t.
  End Impl_core_fmt_Display_for_serde_json_error_ErrorCode_t.
  
  Module  Impl_core_error_Error_for_serde_json_error_Error_t.
  Section Impl_core_error_Error_for_serde_json_error_Error_t.
    Definition Self : Set := serde_json.error.Error.t.
    
    (*
        fn source(&self) -> Option<&(dyn error::Error + 'static)> {
            match &self.err.code {
                ErrorCode::Io(err) => err.source(),
                _ => None,
            }
        }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_serde_json_error_Error_t.
  End Impl_core_error_Error_for_serde_json_error_Error_t.
  
  Module  Impl_core_fmt_Display_for_serde_json_error_Error_t.
  Section Impl_core_fmt_Display_for_serde_json_error_Error_t.
    Definition Self : Set := serde_json.error.Error.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            Display::fmt(&*self.err, f)
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_serde_json_error_Error_t.
  End Impl_core_fmt_Display_for_serde_json_error_Error_t.
  
  Module  Impl_core_fmt_Display_for_serde_json_error_ErrorImpl_t.
  Section Impl_core_fmt_Display_for_serde_json_error_ErrorImpl_t.
    Definition Self : Set := serde_json.error.ErrorImpl.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            if self.line == 0 {
                Display::fmt(&self.code, f)
            } else {
                write!(
                    f,
                    "{} at line {} column {}",
                    self.code, self.line, self.column
                )
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_serde_json_error_ErrorImpl_t.
  End Impl_core_fmt_Display_for_serde_json_error_ErrorImpl_t.
  
  Module  Impl_core_fmt_Debug_for_serde_json_error_Error_t.
  Section Impl_core_fmt_Debug_for_serde_json_error_Error_t.
    Definition Self : Set := serde_json.error.Error.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(
                f,
                "Error({:?}, line: {}, column: {})",
                self.err.code.to_string(),
                self.err.line,
                self.err.column
            )
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_serde_json_error_Error_t.
  End Impl_core_fmt_Debug_for_serde_json_error_Error_t.
  
  Module  Impl_serde_de_Error_for_serde_json_error_Error_t.
  Section Impl_serde_de_Error_for_serde_json_error_Error_t.
    Definition Self : Set := serde_json.error.Error.t.
    
    (*
        fn custom<T: Display>(msg: T) -> Error {
            make_error(msg.to_string())
        }
    *)
    Definition custom
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T}
        (msg : T)
        : M serde_json.error.Error.t :=
      let* msg := M.alloc msg in
      M.read foo.
    
    Global Instance AssociatedFunction_custom
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :
      Notations.DoubleColon Self "custom" := {
      Notations.double_colon := custom (T := T);
    }.
    
    (*
        fn invalid_type(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self {
            Error::custom(format_args!(
                "invalid type: {}, expected {}",
                JsonUnexpected(unexp),
                exp,
            ))
        }
    *)
    Definition invalid_type
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT}
        (unexp : serde.de.Unexpected.t)
        (exp : ref DynT)
        : M Self :=
      let* unexp := M.alloc unexp in
      let* exp := M.alloc exp in
      M.read foo.
    
    Global Instance AssociatedFunction_invalid_type
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :
      Notations.DoubleColon Self "invalid_type" := {
      Notations.double_colon := invalid_type (DynT := DynT);
    }.
    
    (*
        fn invalid_value(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self {
            Error::custom(format_args!(
                "invalid value: {}, expected {}",
                JsonUnexpected(unexp),
                exp,
            ))
        }
    *)
    Definition invalid_value
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT}
        (unexp : serde.de.Unexpected.t)
        (exp : ref DynT)
        : M Self :=
      let* unexp := M.alloc unexp in
      let* exp := M.alloc exp in
      M.read foo.
    
    Global Instance AssociatedFunction_invalid_value
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :
      Notations.DoubleColon Self "invalid_value" := {
      Notations.double_colon := invalid_value (DynT := DynT);
    }.
    
    Global Instance ℐ : serde.de.Error.Required.Trait Self := {
      serde.de.Error.custom {T : Set} {ℋ_0 : core.fmt.Display.Trait T} :=
        custom (T := T);
      serde.de.Error.invalid_type
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :=
        Datatypes.Some (invalid_type (DynT := DynT));
      serde.de.Error.invalid_value
        {DynT : Set}
        {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :=
        Datatypes.Some (invalid_value (DynT := DynT));
      serde.de.Error.invalid_length := Datatypes.None;
      serde.de.Error.unknown_variant := Datatypes.None;
      serde.de.Error.unknown_field := Datatypes.None;
      serde.de.Error.missing_field := Datatypes.None;
      serde.de.Error.duplicate_field := Datatypes.None;
    }.
  End Impl_serde_de_Error_for_serde_json_error_Error_t.
  End Impl_serde_de_Error_for_serde_json_error_Error_t.
  
  Module  Impl_serde_ser_Error_for_serde_json_error_Error_t.
  Section Impl_serde_ser_Error_for_serde_json_error_Error_t.
    Definition Self : Set := serde_json.error.Error.t.
    
    (*
        fn custom<T: Display>(msg: T) -> Error {
            make_error(msg.to_string())
        }
    *)
    Definition custom
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T}
        (msg : T)
        : M serde_json.error.Error.t :=
      let* msg := M.alloc msg in
      M.read foo.
    
    Global Instance AssociatedFunction_custom
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :
      Notations.DoubleColon Self "custom" := {
      Notations.double_colon := custom (T := T);
    }.
    
    Global Instance ℐ : serde.ser.Error.Trait Self := {
      serde.ser.Error.custom {T : Set} {ℋ_0 : core.fmt.Display.Trait T} :=
        custom (T := T);
    }.
  End Impl_serde_ser_Error_for_serde_json_error_Error_t.
  End Impl_serde_ser_Error_for_serde_json_error_Error_t.
  
  Module  JsonUnexpected.
  Section JsonUnexpected.
    Record t : Set := {
      x0 : serde.de.Unexpected.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End JsonUnexpected.
  End JsonUnexpected.
  
  Module  Impl_core_fmt_Display_for_serde_json_error_JsonUnexpected_t.
  Section Impl_core_fmt_Display_for_serde_json_error_JsonUnexpected_t.
    Definition Self : Set := serde_json.error.JsonUnexpected.t.
    
    (*
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match self.0 {
                de::Unexpected::Unit => formatter.write_str("null"),
                de::Unexpected::Float(value) => write!(
                    formatter,
                    "floating point `{}`",
                    ryu::Buffer::new().format(value),
                ),
                unexp => Display::fmt(&unexp, formatter),
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (formatter : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* formatter := M.alloc formatter in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_serde_json_error_JsonUnexpected_t.
  End Impl_core_fmt_Display_for_serde_json_error_JsonUnexpected_t.
  
  (*
  fn make_error(mut msg: String) -> Error {
      let (line, column) = parse_line_col(&mut msg).unwrap_or((0, 0));
      Error {
          err: Box::new(ErrorImpl {
              code: ErrorCode::Message(msg.into_boxed_str()),
              line,
              column,
          }),
      }
  }
  *)
  Definition make_error
      (msg : alloc.string.String.t)
      : M serde_json.error.Error.t :=
    let* msg := M.alloc msg in
    M.read foo.
  
  (*
  fn parse_line_col(msg: &mut String) -> Option<(usize, usize)> {
      let start_of_suffix = match msg.rfind(" at line ") {
          Some(index) => index,
          None => return None,
      };
  
      // Find start and end of line number.
      let start_of_line = start_of_suffix + " at line ".len();
      let mut end_of_line = start_of_line;
      while starts_with_digit(&msg[end_of_line..]) {
          end_of_line += 1;
      }
  
      if !msg[end_of_line..].starts_with(" column ") {
          return None;
      }
  
      // Find start and end of column number.
      let start_of_column = end_of_line + " column ".len();
      let mut end_of_column = start_of_column;
      while starts_with_digit(&msg[end_of_column..]) {
          end_of_column += 1;
      }
  
      if end_of_column < msg.len() {
          return None;
      }
  
      // Parse numbers.
      let line = match usize::from_str(&msg[start_of_line..end_of_line]) {
          Ok(line) => line,
          Err(_) => return None,
      };
      let column = match usize::from_str(&msg[start_of_column..end_of_column]) {
          Ok(column) => column,
          Err(_) => return None,
      };
  
      msg.truncate(start_of_suffix);
      Some((line, column))
  }
  *)
  Definition parse_line_col
      (msg : mut_ref alloc.string.String.t)
      : M (core.option.Option.t (usize.t * usize.t)) :=
    let* msg := M.alloc msg in
    M.read foo.
  
  (*
  fn starts_with_digit(slice: &str) -> bool {
      match slice.as_bytes().first() {
          None => false,
          Some(&byte) => byte >= b'0' && byte <= b'9',
      }
  }
  *)
  Definition starts_with_digit (slice : ref str.t) : M bool.t :=
    let* slice := M.alloc slice in
    M.read foo.
End error.

Module  Error.
Section Error.
  Record t : Set := {
    err :
      alloc.boxed.Box.t serde_json.error.ErrorImpl.t alloc.boxed.Box.Default.A;
  }.
  
  Definition Get_err :=
    Ref.map (fun α => Some α.(err)) (fun β α => Some (α <| err := β |>)).
End Error.
End Error.

Ltac Result T := exact (core.result.Result.t T serde_json.error.Error.t).

Module  Impl_serde_json_error_Error_t_3.
Section Impl_serde_json_error_Error_t_3.
  Definition Self : Set := serde_json.error.Error.t.
  
  (*
      pub fn line(&self) -> usize {
          self.err.line
      }
  *)
  Definition line (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_line :
    Notations.DoubleColon Self "line" := {
    Notations.double_colon := line;
  }.
  
  (*
      pub fn column(&self) -> usize {
          self.err.column
      }
  *)
  Definition column (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_column :
    Notations.DoubleColon Self "column" := {
    Notations.double_colon := column;
  }.
  
  (*
      pub fn classify(&self) -> Category {
          match self.err.code {
              ErrorCode::Message(_) => Category::Data,
              ErrorCode::Io(_) => Category::Io,
              ErrorCode::EofWhileParsingList
              | ErrorCode::EofWhileParsingObject
              | ErrorCode::EofWhileParsingString
              | ErrorCode::EofWhileParsingValue => Category::Eof,
              ErrorCode::ExpectedColon
              | ErrorCode::ExpectedListCommaOrEnd
              | ErrorCode::ExpectedObjectCommaOrEnd
              | ErrorCode::ExpectedSomeIdent
              | ErrorCode::ExpectedSomeValue
              | ErrorCode::ExpectedDoubleQuote
              | ErrorCode::InvalidEscape
              | ErrorCode::InvalidNumber
              | ErrorCode::NumberOutOfRange
              | ErrorCode::InvalidUnicodeCodePoint
              | ErrorCode::ControlCharacterWhileParsingString
              | ErrorCode::KeyMustBeAString
              | ErrorCode::ExpectedNumericKey
              | ErrorCode::FloatKeyMustBeFinite
              | ErrorCode::LoneLeadingSurrogateInHexEscape
              | ErrorCode::TrailingComma
              | ErrorCode::TrailingCharacters
              | ErrorCode::UnexpectedEndOfHexEscape
              | ErrorCode::RecursionLimitExceeded => Category::Syntax,
          }
      }
  *)
  Definition classify (self : ref Self) : M serde_json.error.Category.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_classify :
    Notations.DoubleColon Self "classify" := {
    Notations.double_colon := classify;
  }.
  
  (*
      pub fn is_io(&self) -> bool {
          self.classify() == Category::Io
      }
  *)
  Definition is_io (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_io :
    Notations.DoubleColon Self "is_io" := {
    Notations.double_colon := is_io;
  }.
  
  (*
      pub fn is_syntax(&self) -> bool {
          self.classify() == Category::Syntax
      }
  *)
  Definition is_syntax (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_syntax :
    Notations.DoubleColon Self "is_syntax" := {
    Notations.double_colon := is_syntax;
  }.
  
  (*
      pub fn is_data(&self) -> bool {
          self.classify() == Category::Data
      }
  *)
  Definition is_data (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_data :
    Notations.DoubleColon Self "is_data" := {
    Notations.double_colon := is_data;
  }.
  
  (*
      pub fn is_eof(&self) -> bool {
          self.classify() == Category::Eof
      }
  *)
  Definition is_eof (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_eof :
    Notations.DoubleColon Self "is_eof" := {
    Notations.double_colon := is_eof;
  }.
  
  (*
      pub fn io_error_kind(&self) -> Option<ErrorKind> {
          if let ErrorCode::Io(io_error) = &self.err.code {
              Some(io_error.kind())
          } else {
              None
          }
      }
  *)
  Definition io_error_kind
      (self : ref Self)
      : M (core.option.Option.t std.io.error.ErrorKind.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_io_error_kind :
    Notations.DoubleColon Self "io_error_kind" := {
    Notations.double_colon := io_error_kind;
  }.
End Impl_serde_json_error_Error_t_3.
End Impl_serde_json_error_Error_t_3.

Module Category.
  Inductive t : Set :=
  | Io
  | Syntax
  | Data
  | Eof.
End Category.

Module  Impl_core_marker_Copy_for_serde_json_error_Category_t.
Section Impl_core_marker_Copy_for_serde_json_error_Category_t.
  Definition Self : Set := serde_json.error.Category.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_serde_json_error_Category_t.
End Impl_core_marker_Copy_for_serde_json_error_Category_t.

Module  Impl_core_clone_Clone_for_serde_json_error_Category_t.
Section Impl_core_clone_Clone_for_serde_json_error_Category_t.
  Definition Self : Set := serde_json.error.Category.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M serde_json.error.Category.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_serde_json_error_Category_t.
End Impl_core_clone_Clone_for_serde_json_error_Category_t.

Module  Impl_core_marker_StructuralPartialEq_for_serde_json_error_Category_t.
Section Impl_core_marker_StructuralPartialEq_for_serde_json_error_Category_t.
  Definition Self : Set := serde_json.error.Category.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_serde_json_error_Category_t.
End Impl_core_marker_StructuralPartialEq_for_serde_json_error_Category_t.

Module  Impl_core_cmp_PartialEq_for_serde_json_error_Category_t.
Section Impl_core_cmp_PartialEq_for_serde_json_error_Category_t.
  Definition Self : Set := serde_json.error.Category.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.error.Category.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_serde_json_error_Category_t.
End Impl_core_cmp_PartialEq_for_serde_json_error_Category_t.

Module  Impl_core_marker_StructuralEq_for_serde_json_error_Category_t.
Section Impl_core_marker_StructuralEq_for_serde_json_error_Category_t.
  Definition Self : Set := serde_json.error.Category.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_serde_json_error_Category_t.
End Impl_core_marker_StructuralEq_for_serde_json_error_Category_t.

Module  Impl_core_cmp_Eq_for_serde_json_error_Category_t.
Section Impl_core_cmp_Eq_for_serde_json_error_Category_t.
  Definition Self : Set := serde_json.error.Category.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_serde_json_error_Category_t.
End Impl_core_cmp_Eq_for_serde_json_error_Category_t.

Module  Impl_core_fmt_Debug_for_serde_json_error_Category_t.
Section Impl_core_fmt_Debug_for_serde_json_error_Category_t.
  Definition Self : Set := serde_json.error.Category.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_serde_json_error_Category_t.
End Impl_core_fmt_Debug_for_serde_json_error_Category_t.

Module  Impl_core_convert_From_serde_json_error_Error_t_for_std_io_error_Error_t.
Section Impl_core_convert_From_serde_json_error_Error_t_for_std_io_error_Error_t.
  Definition Self : Set := std.io.error.Error.t.
  
  (*
      fn from(j: Error) -> Self {
          if let ErrorCode::Io(err) = j.err.code {
              err
          } else {
              match j.classify() {
                  Category::Io => unreachable!(),
                  Category::Syntax | Category::Data => io::Error::new(ErrorKind::InvalidData, j),
                  Category::Eof => io::Error::new(ErrorKind::UnexpectedEof, j),
              }
          }
      }
  *)
  Definition from (j : serde_json.error.Error.t) : M Self :=
    let* j := M.alloc j in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := serde_json.error.Error.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_serde_json_error_Error_t_for_std_io_error_Error_t.
End Impl_core_convert_From_serde_json_error_Error_t_for_std_io_error_Error_t.

Module  ErrorImpl.
Section ErrorImpl.
  Record t : Set := {
    code : serde_json.error.ErrorCode.t;
    line : usize.t;
    column : usize.t;
  }.
  
  Definition Get_code :=
    Ref.map (fun α => Some α.(code)) (fun β α => Some (α <| code := β |>)).
  Definition Get_line :=
    Ref.map (fun α => Some α.(line)) (fun β α => Some (α <| line := β |>)).
  Definition Get_column :=
    Ref.map (fun α => Some α.(column)) (fun β α => Some (α <| column := β |>)).
End ErrorImpl.
End ErrorImpl.

Module ErrorCode.
  Inductive t : Set :=
  | Message (_ : alloc.boxed.Box.t str.t alloc.boxed.Box.Default.A)
  | Io (_ : std.io.error.Error.t)
  | EofWhileParsingList
  | EofWhileParsingObject
  | EofWhileParsingString
  | EofWhileParsingValue
  | ExpectedColon
  | ExpectedListCommaOrEnd
  | ExpectedObjectCommaOrEnd
  | ExpectedSomeIdent
  | ExpectedSomeValue
  | ExpectedDoubleQuote
  | InvalidEscape
  | InvalidNumber
  | NumberOutOfRange
  | InvalidUnicodeCodePoint
  | ControlCharacterWhileParsingString
  | KeyMustBeAString
  | ExpectedNumericKey
  | FloatKeyMustBeFinite
  | LoneLeadingSurrogateInHexEscape
  | TrailingComma
  | TrailingCharacters
  | UnexpectedEndOfHexEscape
  | RecursionLimitExceeded.
  
  Definition Get_Message_0 :=
    Ref.map
      (fun α => match α with | Message α0 => Some α0 | _ => None end)
      (fun β α => match α with | Message _ => Some (Message β) | _ => None end).
  
  Definition Get_Io_0 :=
    Ref.map
      (fun α => match α with | Io α0 => Some α0 | _ => None end)
      (fun β α => match α with | Io _ => Some (Io β) | _ => None end).
End ErrorCode.

Module  Impl_serde_json_error_Error_t_4.
Section Impl_serde_json_error_Error_t_4.
  Definition Self : Set := serde_json.error.Error.t.
  
  (*
      pub(crate) fn syntax(code: ErrorCode, line: usize, column: usize) -> Self {
          Error {
              err: Box::new(ErrorImpl { code, line, column }),
          }
      }
  *)
  Definition syntax
      (code : serde_json.error.ErrorCode.t)
      (line : usize.t)
      (column : usize.t)
      : M Self :=
    let* code := M.alloc code in
    let* line := M.alloc line in
    let* column := M.alloc column in
    M.read foo.
  
  Global Instance AssociatedFunction_syntax :
    Notations.DoubleColon Self "syntax" := {
    Notations.double_colon := syntax;
  }.
  
  (*
      pub fn io(error: io::Error) -> Self {
          Error {
              err: Box::new(ErrorImpl {
                  code: ErrorCode::Io(error),
                  line: 0,
                  column: 0,
              }),
          }
      }
  *)
  Definition io (error : std.io.error.Error.t) : M Self :=
    let* error := M.alloc error in
    M.read foo.
  
  Global Instance AssociatedFunction_io : Notations.DoubleColon Self "io" := {
    Notations.double_colon := io;
  }.
  
  (*
      pub(crate) fn fix_position<F>(self, f: F) -> Self
      where
          F: FnOnce(ErrorCode) -> Error,
      {
          if self.err.line == 0 {
              f(self.err.code)
          } else {
              self
          }
      }
  *)
  Definition fix_position
      {F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := serde_json.error.ErrorCode.t)}
      (self : Self)
      (f : F)
      : M Self :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fix_position
      {F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := serde_json.error.ErrorCode.t)} :
    Notations.DoubleColon Self "fix_position" := {
    Notations.double_colon := fix_position (F := F);
  }.
End Impl_serde_json_error_Error_t_4.
End Impl_serde_json_error_Error_t_4.

Module  Impl_core_fmt_Display_for_serde_json_error_ErrorCode_t.
Section Impl_core_fmt_Display_for_serde_json_error_ErrorCode_t.
  Definition Self : Set := serde_json.error.ErrorCode.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          match self {
              ErrorCode::Message(msg) => f.write_str(msg),
              ErrorCode::Io(err) => Display::fmt(err, f),
              ErrorCode::EofWhileParsingList => f.write_str("EOF while parsing a list"),
              ErrorCode::EofWhileParsingObject => f.write_str("EOF while parsing an object"),
              ErrorCode::EofWhileParsingString => f.write_str("EOF while parsing a string"),
              ErrorCode::EofWhileParsingValue => f.write_str("EOF while parsing a value"),
              ErrorCode::ExpectedColon => f.write_str("expected `:`"),
              ErrorCode::ExpectedListCommaOrEnd => f.write_str("expected `,` or `]`"),
              ErrorCode::ExpectedObjectCommaOrEnd => f.write_str("expected `,` or `}`"),
              ErrorCode::ExpectedSomeIdent => f.write_str("expected ident"),
              ErrorCode::ExpectedSomeValue => f.write_str("expected value"),
              ErrorCode::ExpectedDoubleQuote => f.write_str("expected `\"`"),
              ErrorCode::InvalidEscape => f.write_str("invalid escape"),
              ErrorCode::InvalidNumber => f.write_str("invalid number"),
              ErrorCode::NumberOutOfRange => f.write_str("number out of range"),
              ErrorCode::InvalidUnicodeCodePoint => f.write_str("invalid unicode code point"),
              ErrorCode::ControlCharacterWhileParsingString => {
                  f.write_str("control character (\\u0000-\\u001F) found while parsing a string")
              }
              ErrorCode::KeyMustBeAString => f.write_str("key must be a string"),
              ErrorCode::ExpectedNumericKey => {
                  f.write_str("invalid value: expected key to be a number in quotes")
              }
              ErrorCode::FloatKeyMustBeFinite => {
                  f.write_str("float key must be finite (got NaN or +/-inf)")
              }
              ErrorCode::LoneLeadingSurrogateInHexEscape => {
                  f.write_str("lone leading surrogate in hex escape")
              }
              ErrorCode::TrailingComma => f.write_str("trailing comma"),
              ErrorCode::TrailingCharacters => f.write_str("trailing characters"),
              ErrorCode::UnexpectedEndOfHexEscape => f.write_str("unexpected end of hex escape"),
              ErrorCode::RecursionLimitExceeded => f.write_str("recursion limit exceeded"),
          }
      }
  "
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_serde_json_error_ErrorCode_t.
End Impl_core_fmt_Display_for_serde_json_error_ErrorCode_t.

Module  Impl_core_error_Error_for_serde_json_error_Error_t.
Section Impl_core_error_Error_for_serde_json_error_Error_t.
  Definition Self : Set := serde_json.error.Error.t.
  
  (*
      fn source(&self) -> Option<&(dyn error::Error + 'static)> {
          match &self.err.code {
              ErrorCode::Io(err) => err.source(),
              _ => None,
          }
      }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_serde_json_error_Error_t.
End Impl_core_error_Error_for_serde_json_error_Error_t.

Module  Impl_core_fmt_Display_for_serde_json_error_Error_t.
Section Impl_core_fmt_Display_for_serde_json_error_Error_t.
  Definition Self : Set := serde_json.error.Error.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          Display::fmt(&*self.err, f)
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_serde_json_error_Error_t.
End Impl_core_fmt_Display_for_serde_json_error_Error_t.

Module  Impl_core_fmt_Display_for_serde_json_error_ErrorImpl_t.
Section Impl_core_fmt_Display_for_serde_json_error_ErrorImpl_t.
  Definition Self : Set := serde_json.error.ErrorImpl.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          if self.line == 0 {
              Display::fmt(&self.code, f)
          } else {
              write!(
                  f,
                  "{} at line {} column {}",
                  self.code, self.line, self.column
              )
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_serde_json_error_ErrorImpl_t.
End Impl_core_fmt_Display_for_serde_json_error_ErrorImpl_t.

Module  Impl_core_fmt_Debug_for_serde_json_error_Error_t.
Section Impl_core_fmt_Debug_for_serde_json_error_Error_t.
  Definition Self : Set := serde_json.error.Error.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          write!(
              f,
              "Error({:?}, line: {}, column: {})",
              self.err.code.to_string(),
              self.err.line,
              self.err.column
          )
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_serde_json_error_Error_t.
End Impl_core_fmt_Debug_for_serde_json_error_Error_t.

Module  Impl_serde_de_Error_for_serde_json_error_Error_t.
Section Impl_serde_de_Error_for_serde_json_error_Error_t.
  Definition Self : Set := serde_json.error.Error.t.
  
  (*
      fn custom<T: Display>(msg: T) -> Error {
          make_error(msg.to_string())
      }
  *)
  Definition custom
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T}
      (msg : T)
      : M serde_json.error.Error.t :=
    let* msg := M.alloc msg in
    M.read foo.
  
  Global Instance AssociatedFunction_custom
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :
    Notations.DoubleColon Self "custom" := {
    Notations.double_colon := custom (T := T);
  }.
  
  (*
      fn invalid_type(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self {
          Error::custom(format_args!(
              "invalid type: {}, expected {}",
              JsonUnexpected(unexp),
              exp,
          ))
      }
  *)
  Definition invalid_type
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT}
      (unexp : serde.de.Unexpected.t)
      (exp : ref DynT)
      : M Self :=
    let* unexp := M.alloc unexp in
    let* exp := M.alloc exp in
    M.read foo.
  
  Global Instance AssociatedFunction_invalid_type
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :
    Notations.DoubleColon Self "invalid_type" := {
    Notations.double_colon := invalid_type (DynT := DynT);
  }.
  
  (*
      fn invalid_value(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self {
          Error::custom(format_args!(
              "invalid value: {}, expected {}",
              JsonUnexpected(unexp),
              exp,
          ))
      }
  *)
  Definition invalid_value
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT}
      (unexp : serde.de.Unexpected.t)
      (exp : ref DynT)
      : M Self :=
    let* unexp := M.alloc unexp in
    let* exp := M.alloc exp in
    M.read foo.
  
  Global Instance AssociatedFunction_invalid_value
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :
    Notations.DoubleColon Self "invalid_value" := {
    Notations.double_colon := invalid_value (DynT := DynT);
  }.
  
  Global Instance ℐ : serde.de.Error.Required.Trait Self := {
    serde.de.Error.custom {T : Set} {ℋ_0 : core.fmt.Display.Trait T} :=
      custom (T := T);
    serde.de.Error.invalid_type
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :=
      Datatypes.Some (invalid_type (DynT := DynT));
    serde.de.Error.invalid_value
      {DynT : Set}
      {ℋ_0 : serde.de.Expected.Trait.Trait DynT} :=
      Datatypes.Some (invalid_value (DynT := DynT));
    serde.de.Error.invalid_length := Datatypes.None;
    serde.de.Error.unknown_variant := Datatypes.None;
    serde.de.Error.unknown_field := Datatypes.None;
    serde.de.Error.missing_field := Datatypes.None;
    serde.de.Error.duplicate_field := Datatypes.None;
  }.
End Impl_serde_de_Error_for_serde_json_error_Error_t.
End Impl_serde_de_Error_for_serde_json_error_Error_t.

Module  Impl_serde_ser_Error_for_serde_json_error_Error_t.
Section Impl_serde_ser_Error_for_serde_json_error_Error_t.
  Definition Self : Set := serde_json.error.Error.t.
  
  (*
      fn custom<T: Display>(msg: T) -> Error {
          make_error(msg.to_string())
      }
  *)
  Definition custom
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T}
      (msg : T)
      : M serde_json.error.Error.t :=
    let* msg := M.alloc msg in
    M.read foo.
  
  Global Instance AssociatedFunction_custom
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :
    Notations.DoubleColon Self "custom" := {
    Notations.double_colon := custom (T := T);
  }.
  
  Global Instance ℐ : serde.ser.Error.Trait Self := {
    serde.ser.Error.custom {T : Set} {ℋ_0 : core.fmt.Display.Trait T} :=
      custom (T := T);
  }.
End Impl_serde_ser_Error_for_serde_json_error_Error_t.
End Impl_serde_ser_Error_for_serde_json_error_Error_t.

Module  JsonUnexpected.
Section JsonUnexpected.
  Record t : Set := {
    x0 : serde.de.Unexpected.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End JsonUnexpected.
End JsonUnexpected.

Module  Impl_core_fmt_Display_for_serde_json_error_JsonUnexpected_t.
Section Impl_core_fmt_Display_for_serde_json_error_JsonUnexpected_t.
  Definition Self : Set := serde_json.error.JsonUnexpected.t.
  
  (*
      fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
          match self.0 {
              de::Unexpected::Unit => formatter.write_str("null"),
              de::Unexpected::Float(value) => write!(
                  formatter,
                  "floating point `{}`",
                  ryu::Buffer::new().format(value),
              ),
              unexp => Display::fmt(&unexp, formatter),
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_serde_json_error_JsonUnexpected_t.
End Impl_core_fmt_Display_for_serde_json_error_JsonUnexpected_t.

(*
fn make_error(mut msg: String) -> Error {
    let (line, column) = parse_line_col(&mut msg).unwrap_or((0, 0));
    Error {
        err: Box::new(ErrorImpl {
            code: ErrorCode::Message(msg.into_boxed_str()),
            line,
            column,
        }),
    }
}
*)
Definition make_error
    (msg : alloc.string.String.t)
    : M serde_json.error.Error.t :=
  let* msg := M.alloc msg in
  M.read foo.

(*
fn parse_line_col(msg: &mut String) -> Option<(usize, usize)> {
    let start_of_suffix = match msg.rfind(" at line ") {
        Some(index) => index,
        None => return None,
    };

    // Find start and end of line number.
    let start_of_line = start_of_suffix + " at line ".len();
    let mut end_of_line = start_of_line;
    while starts_with_digit(&msg[end_of_line..]) {
        end_of_line += 1;
    }

    if !msg[end_of_line..].starts_with(" column ") {
        return None;
    }

    // Find start and end of column number.
    let start_of_column = end_of_line + " column ".len();
    let mut end_of_column = start_of_column;
    while starts_with_digit(&msg[end_of_column..]) {
        end_of_column += 1;
    }

    if end_of_column < msg.len() {
        return None;
    }

    // Parse numbers.
    let line = match usize::from_str(&msg[start_of_line..end_of_line]) {
        Ok(line) => line,
        Err(_) => return None,
    };
    let column = match usize::from_str(&msg[start_of_column..end_of_column]) {
        Ok(column) => column,
        Err(_) => return None,
    };

    msg.truncate(start_of_suffix);
    Some((line, column))
}
*)
Definition parse_line_col
    (msg : mut_ref alloc.string.String.t)
    : M (core.option.Option.t (usize.t * usize.t)) :=
  let* msg := M.alloc msg in
  M.read foo.

(*
fn starts_with_digit(slice: &str) -> bool {
    match slice.as_bytes().first() {
        None => false,
        Some(&byte) => byte >= b'0' && byte <= b'9',
    }
}
*)
Definition starts_with_digit (slice : ref str.t) : M bool.t :=
  let* slice := M.alloc slice in
  M.read foo.

Module map.
  Module  Map.
  Section Map.
    Context (K V : Set).
    
    Record t : Set := {
      map : ltac:(serde_json.map.MapImpl K V);
    }.
    
    Definition Get_map :=
      Ref.map (fun α => Some α.(map)) (fun β α => Some (α <| map := β |>)).
  End Map.
  End Map.
  
  Ltac MapImpl K V :=
    exact
      (alloc.collections.btree.map.BTreeMap.t
        K
        V
        alloc.collections.btree.map.BTreeMap.Default.A).
  
  Module  Impl_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        pub fn new() -> Self {
            Map {
                map: MapImpl::new(),
            }
        }
    *)
    Definition new : M Self := M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        pub fn with_capacity(capacity: usize) -> Self {
            Map {
                #[cfg(not(feature = "preserve_order"))]
                map: {
                    // does not support with_capacity
                    let _ = capacity;
                    BTreeMap::new()
                },
                #[cfg(feature = "preserve_order")]
                map: IndexMap::with_capacity(capacity),
            }
        }
    *)
    Definition with_capacity (capacity : usize.t) : M Self :=
      let* capacity := M.alloc capacity in
      M.read foo.
    
    Global Instance AssociatedFunction_with_capacity :
      Notations.DoubleColon Self "with_capacity" := {
      Notations.double_colon := with_capacity;
    }.
    
    (*
        pub fn clear(&mut self) {
            self.map.clear();
        }
    *)
    Definition clear (self : mut_ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clear :
      Notations.DoubleColon Self "clear" := {
      Notations.double_colon := clear;
    }.
    
    (*
        pub fn get<Q>(&self, key: &Q) -> Option<&Value>
        where
            String: Borrow<Q>,
            Q: ?Sized + Ord + Eq + Hash,
        {
            self.map.get(key)
        }
    *)
    Definition get
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q}
        (self : ref Self)
        (key : ref Q)
        : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_get
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q} :
      Notations.DoubleColon Self "get" := {
      Notations.double_colon := get (Q := Q);
    }.
    
    (*
        pub fn contains_key<Q>(&self, key: &Q) -> bool
        where
            String: Borrow<Q>,
            Q: ?Sized + Ord + Eq + Hash,
        {
            self.map.contains_key(key)
        }
    *)
    Definition contains_key
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q}
        (self : ref Self)
        (key : ref Q)
        : M bool.t :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_contains_key
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q} :
      Notations.DoubleColon Self "contains_key" := {
      Notations.double_colon := contains_key (Q := Q);
    }.
    
    (*
        pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut Value>
        where
            String: Borrow<Q>,
            Q: ?Sized + Ord + Eq + Hash,
        {
            self.map.get_mut(key)
        }
    *)
    Definition get_mut
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q}
        (self : mut_ref Self)
        (key : ref Q)
        : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_get_mut
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q} :
      Notations.DoubleColon Self "get_mut" := {
      Notations.double_colon := get_mut (Q := Q);
    }.
    
    (*
        pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&String, &Value)>
        where
            String: Borrow<Q>,
            Q: ?Sized + Ord + Eq + Hash,
        {
            self.map.get_key_value(key)
        }
    *)
    Definition get_key_value
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q}
        (self : ref Self)
        (key : ref Q)
        :
          M
            (core.option.Option.t
              ((ref alloc.string.String.t) * (ref serde_json.value.Value.t))) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_get_key_value
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q} :
      Notations.DoubleColon Self "get_key_value" := {
      Notations.double_colon := get_key_value (Q := Q);
    }.
    
    (*
        pub fn insert(&mut self, k: String, v: Value) -> Option<Value> {
            self.map.insert(k, v)
        }
    *)
    Definition insert
        (self : mut_ref Self)
        (k : alloc.string.String.t)
        (v : serde_json.value.Value.t)
        : M (core.option.Option.t serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* k := M.alloc k in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_insert :
      Notations.DoubleColon Self "insert" := {
      Notations.double_colon := insert;
    }.
    
    (*
        pub fn remove<Q>(&mut self, key: &Q) -> Option<Value>
        where
            String: Borrow<Q>,
            Q: ?Sized + Ord + Eq + Hash,
        {
            #[cfg(feature = "preserve_order")]
            return self.map.swap_remove(key);
            #[cfg(not(feature = "preserve_order"))]
            return self.map.remove(key);
        }
    *)
    Definition remove
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q}
        (self : mut_ref Self)
        (key : ref Q)
        : M (core.option.Option.t serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_remove
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q} :
      Notations.DoubleColon Self "remove" := {
      Notations.double_colon := remove (Q := Q);
    }.
    
    (*
        pub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(String, Value)>
        where
            String: Borrow<Q>,
            Q: ?Sized + Ord + Eq + Hash,
        {
            self.map.remove_entry(key)
        }
    *)
    Definition remove_entry
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q}
        (self : mut_ref Self)
        (key : ref Q)
        :
          M
            (core.option.Option.t
              (alloc.string.String.t * serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_remove_entry
        {Q : Set}
        {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
        {ℋ_1 : core.cmp.Ord.Trait Q}
        {ℋ_2 : core.cmp.Eq.Trait Q}
        {ℋ_3 : core.hash.Hash.Trait Q} :
      Notations.DoubleColon Self "remove_entry" := {
      Notations.double_colon := remove_entry (Q := Q);
    }.
    
    (*
        pub fn append(&mut self, other: &mut Self) {
            #[cfg(feature = "preserve_order")]
            self.map
                .extend(mem::replace(&mut other.map, MapImpl::default()));
            #[cfg(not(feature = "preserve_order"))]
            self.map.append(&mut other.map);
        }
    *)
    Definition append (self : mut_ref Self) (other : mut_ref Self) : M unit :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_append :
      Notations.DoubleColon Self "append" := {
      Notations.double_colon := append;
    }.
    
    (*
        pub fn entry<S>(&mut self, key: S) -> Entry
        where
            S: Into<String>,
        {
            #[cfg(not(feature = "preserve_order"))]
            use alloc::collections::btree_map::Entry as EntryImpl;
            #[cfg(feature = "preserve_order")]
            use indexmap::map::Entry as EntryImpl;
    
            match self.map.entry(key.into()) {
                EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),
                EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),
            }
        }
    *)
    Definition entry
        {S : Set}
        {ℋ_0 : core.convert.Into.Trait S (T := alloc.string.String.t)}
        (self : mut_ref Self)
        (key : S)
        : M serde_json.map.Entry.t :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_entry
        {S : Set}
        {ℋ_0 : core.convert.Into.Trait S (T := alloc.string.String.t)} :
      Notations.DoubleColon Self "entry" := {
      Notations.double_colon := entry (S := S);
    }.
    
    (*
        pub fn len(&self) -> usize {
            self.map.len()
        }
    *)
    Definition len (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_len :
      Notations.DoubleColon Self "len" := {
      Notations.double_colon := len;
    }.
    
    (*
        pub fn is_empty(&self) -> bool {
            self.map.is_empty()
        }
    *)
    Definition is_empty (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_empty :
      Notations.DoubleColon Self "is_empty" := {
      Notations.double_colon := is_empty;
    }.
    
    (*
        pub fn iter(&self) -> Iter {
            Iter {
                iter: self.map.iter(),
            }
        }
    *)
    Definition iter (self : ref Self) : M serde_json.map.Iter.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_iter :
      Notations.DoubleColon Self "iter" := {
      Notations.double_colon := iter;
    }.
    
    (*
        pub fn iter_mut(&mut self) -> IterMut {
            IterMut {
                iter: self.map.iter_mut(),
            }
        }
    *)
    Definition iter_mut (self : mut_ref Self) : M serde_json.map.IterMut.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_iter_mut :
      Notations.DoubleColon Self "iter_mut" := {
      Notations.double_colon := iter_mut;
    }.
    
    (*
        pub fn keys(&self) -> Keys {
            Keys {
                iter: self.map.keys(),
            }
        }
    *)
    Definition keys (self : ref Self) : M serde_json.map.Keys.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_keys :
      Notations.DoubleColon Self "keys" := {
      Notations.double_colon := keys;
    }.
    
    (*
        pub fn values(&self) -> Values {
            Values {
                iter: self.map.values(),
            }
        }
    *)
    Definition values (self : ref Self) : M serde_json.map.Values.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_values :
      Notations.DoubleColon Self "values" := {
      Notations.double_colon := values;
    }.
    
    (*
        pub fn values_mut(&mut self) -> ValuesMut {
            ValuesMut {
                iter: self.map.values_mut(),
            }
        }
    *)
    Definition values_mut
        (self : mut_ref Self)
        : M serde_json.map.ValuesMut.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_values_mut :
      Notations.DoubleColon Self "values_mut" := {
      Notations.double_colon := values_mut;
    }.
    
    (*
        pub fn retain<F>(&mut self, f: F)
        where
            F: FnMut(&String, &mut Value) -> bool,
        {
            self.map.retain(f);
        }
    *)
    Definition retain
        {F : Set}
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (ref alloc.string.String.t)
            *
            (mut_ref serde_json.value.Value.t))}
        (self : mut_ref Self)
        (f : F)
        : M unit :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_retain
        {F : Set}
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (ref alloc.string.String.t)
            *
            (mut_ref serde_json.value.Value.t))} :
      Notations.DoubleColon Self "retain" := {
      Notations.double_colon := retain (F := F);
    }.
  End Impl_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_default_Default_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_default_Default_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn default() -> Self {
            Map {
                map: MapImpl::new(),
            }
        }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_default_Default_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_clone_Clone_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_clone_Clone_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn clone(&self) -> Self {
            Map {
                map: self.map.clone(),
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    (*
        fn clone_from(&mut self, source: &Self) {
            self.map.clone_from(&source.map);
        }
    *)
    Definition clone_from (self : mut_ref Self) (source : ref Self) : M unit :=
      let* self := M.alloc self in
      let* source := M.alloc source in
      M.read foo.
    
    Global Instance AssociatedFunction_clone_from :
      Notations.DoubleColon Self "clone_from" := {
      Notations.double_colon := clone_from;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.Some clone_from;
    }.
  End Impl_core_clone_Clone_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_clone_Clone_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn eq(&self, other: &Self) -> bool {
            self.map.eq(&other.map)
        }
    *)
    Definition eq (self : ref Self) (other : ref Self) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_Eq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_cmp_Eq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
    }.
  End Impl_core_cmp_Eq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_cmp_Eq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_ops_index_Index_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_ops_index_Index_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Context {Q : Set}.
    
    Context
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q}.
    
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        type Output = Value;
    *)
    Definition Output : Set := serde_json.value.Value.t.
    
    (*
        fn index(&self, index: &Q) -> &Value {
            self.map.index(index)
        }
    *)
    Definition index
        (self : ref Self)
        (index : ref Q)
        : M (ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* index := M.alloc index in
      M.read foo.
    
    Global Instance AssociatedFunction_index :
      Notations.DoubleColon Self "index" := {
      Notations.double_colon := index;
    }.
    
    Global Instance ℐ : core.ops.index.Index.Trait Self (Idx := ref Q) := {
      core.ops.index.Index.Output := Output;
      core.ops.index.Index.index := index;
    }.
  End Impl_core_ops_index_Index_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_ops_index_Index_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_ops_index_IndexMut_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_ops_index_IndexMut_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Context {Q : Set}.
    
    Context
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q}.
    
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn index_mut(&mut self, index: &Q) -> &mut Value {
            self.map.get_mut(index).expect("no entry found for key")
        }
    *)
    Definition index_mut
        (self : mut_ref Self)
        (index : ref Q)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* index := M.alloc index in
      M.read foo.
    
    Global Instance AssociatedFunction_index_mut :
      Notations.DoubleColon Self "index_mut" := {
      Notations.double_colon := index_mut;
    }.
    
    Global Instance ℐ : core.ops.index.IndexMut.Trait Self (Idx := ref Q) := {
      core.ops.index.IndexMut.index_mut := index_mut;
    }.
  End Impl_core_ops_index_IndexMut_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_ops_index_IndexMut_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_fmt_Debug_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_fmt_Debug_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {
            self.map.fmt(formatter)
        }
    *)
    Definition fmt
        (self : ref Self)
        (formatter : mut_ref core.fmt.Formatter.t)
        : M (core.result.Result.t unit core.fmt.Error.t) :=
      let* self := M.alloc self in
      let* formatter := M.alloc formatter in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_fmt_Debug_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_serde_ser_Serialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_serde_ser_Serialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            let mut map = tri!(serializer.serialize_map(Some(self.len())));
            for (k, v) in self {
                tri!(map.serialize_entry(k, v));
            }
            map.end()
        }
    *)
    Definition serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S}
        (self : ref Self)
        (serializer : S)
        : M (core.result.Result.t S::type["Ok"].t S::type["Error"].t) :=
      let* self := M.alloc self in
      let* serializer := M.alloc serializer in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S} :
      Notations.DoubleColon Self "serialize" := {
      Notations.double_colon := serialize (S := S);
    }.
    
    Global Instance ℐ : serde.ser.Serialize.Trait Self := {
      serde.ser.Serialize.serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S} :=
        serialize (S := S);
    }.
  End Impl_serde_ser_Serialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_serde_ser_Serialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_serde_de_Deserialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_serde_de_Deserialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: de::Deserializer<'de>,
        {
            struct Visitor;
    
            impl<'de> de::Visitor<'de> for Visitor {
                type Value = Map<String, Value>;
    
                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("a map")
                }
    
                #[inline]
                fn visit_unit<E>(self) -> Result<Self::Value, E>
                where
                    E: de::Error,
                {
                    Ok(Map::new())
                }
    
                #[cfg(any(feature = "std", feature = "alloc"))]
                #[inline]
                fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
                where
                    V: de::MapAccess<'de>,
                {
                    let mut values = Map::new();
    
                    while let Some((key, value)) = tri!(visitor.next_entry()) {
                        values.insert(key, value);
                    }
    
                    Ok(values)
                }
            }
    
            deserializer.deserialize_map(Visitor)
        }
    *)
    Definition deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D}
        (deserializer : D)
        : M (core.result.Result.t Self D::type["Error"].t) :=
      let* deserializer := M.alloc deserializer in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D} :
      Notations.DoubleColon Self "deserialize" := {
      Notations.double_colon := deserialize (D := D);
    }.
    
    Global Instance ℐ : serde.de.Deserialize.Required.Trait Self := {
      serde.de.Deserialize.deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D} :=
        deserialize (D := D);
      serde.de.Deserialize.deserialize_in_place := Datatypes.None;
    }.
  End Impl_serde_de_Deserialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_serde_de_Deserialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_iter_traits_collect_FromIterator_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_iter_traits_collect_FromIterator_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn from_iter<T>(iter: T) -> Self
        where
            T: IntoIterator<Item = (String, Value)>,
        {
            Map {
                map: FromIterator::from_iter(iter),
            }
        }
    *)
    Definition from_iter
        {T : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T}
        (iter : T)
        : M Self :=
      let* iter := M.alloc iter in
      M.read foo.
    
    Global Instance AssociatedFunction_from_iter
        {T : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T} :
      Notations.DoubleColon Self "from_iter" := {
      Notations.double_colon := from_iter (T := T);
    }.
    
    Global Instance ℐ :
      core.iter.traits.collect.FromIterator.Trait Self
        (A := alloc.string.String.t * serde_json.value.Value.t) := {
      core.iter.traits.collect.FromIterator.from_iter
        {T : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T} :=
        from_iter (T := T);
    }.
  End Impl_core_iter_traits_collect_FromIterator_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_iter_traits_collect_FromIterator_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Impl_core_iter_traits_collect_Extend_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_iter_traits_collect_Extend_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        fn extend<T>(&mut self, iter: T)
        where
            T: IntoIterator<Item = (String, Value)>,
        {
            self.map.extend(iter);
        }
    *)
    Definition extend
        {T : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T}
        (self : mut_ref Self)
        (iter : T)
        : M unit :=
      let* self := M.alloc self in
      let* iter := M.alloc iter in
      M.read foo.
    
    Global Instance AssociatedFunction_extend
        {T : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T} :
      Notations.DoubleColon Self "extend" := {
      Notations.double_colon := extend (T := T);
    }.
    
    Global Instance ℐ :
      core.iter.traits.collect.Extend.Required.Trait Self
        (A := alloc.string.String.t * serde_json.value.Value.t) := {
      core.iter.traits.collect.Extend.extend
        {T : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T} :=
        extend (T := T);
      core.iter.traits.collect.Extend.extend_one := Datatypes.None;
      core.iter.traits.collect.Extend.extend_reserve := Datatypes.None;
    }.
  End Impl_core_iter_traits_collect_Extend_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_iter_traits_collect_Extend_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module Entry.
    Inductive t : Set :=
    | Vacant (_ : serde_json.map.VacantEntry.t)
    | Occupied (_ : serde_json.map.OccupiedEntry.t).
    
    Definition Get_Vacant_0 :=
      Ref.map
        (fun α => match α with | Vacant α0 => Some α0 | _ => None end)
        (fun β α => match α with | Vacant _ => Some (Vacant β) | _ => None end).
    
    Definition Get_Occupied_0 :=
      Ref.map
        (fun α => match α with | Occupied α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | Occupied _ => Some (Occupied β) | _ => None end).
  End Entry.
  
  Module  VacantEntry.
  Section VacantEntry.
    Record t : Set := {
      vacant : ltac:(serde_json.map.VacantEntryImpl);
    }.
    
    Definition Get_vacant :=
      Ref.map
        (fun α => Some α.(vacant))
        (fun β α => Some (α <| vacant := β |>)).
  End VacantEntry.
  End VacantEntry.
  
  Module  OccupiedEntry.
  Section OccupiedEntry.
    Record t : Set := {
      occupied : ltac:(serde_json.map.OccupiedEntryImpl);
    }.
    
    Definition Get_occupied :=
      Ref.map
        (fun α => Some α.(occupied))
        (fun β α => Some (α <| occupied := β |>)).
  End OccupiedEntry.
  End OccupiedEntry.
  
  Ltac VacantEntryImpl :=
    exact
      (alloc.collections.btree.map.entry.VacantEntry.t
        alloc.string.String.t
        serde_json.value.Value.t
        alloc.collections.btree.map.entry.VacantEntry.Default.A).
  
  Ltac OccupiedEntryImpl :=
    exact
      (alloc.collections.btree.map.entry.OccupiedEntry.t
        alloc.string.String.t
        serde_json.value.Value.t
        alloc.collections.btree.map.entry.OccupiedEntry.Default.A).
  
  Module  Impl_serde_json_map_Entry_t.
  Section Impl_serde_json_map_Entry_t.
    Definition Self : Set := serde_json.map.Entry.t.
    
    (*
        pub fn key(&self) -> &String {
            match self {
                Entry::Vacant(e) => e.key(),
                Entry::Occupied(e) => e.key(),
            }
        }
    *)
    Definition key (self : ref Self) : M (ref alloc.string.String.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_key :
      Notations.DoubleColon Self "key" := {
      Notations.double_colon := key;
    }.
    
    (*
        pub fn or_insert(self, default: Value) -> &'a mut Value {
            match self {
                Entry::Vacant(entry) => entry.insert(default),
                Entry::Occupied(entry) => entry.into_mut(),
            }
        }
    *)
    Definition or_insert
        (self : Self)
        (default : serde_json.value.Value.t)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* default := M.alloc default in
      M.read foo.
    
    Global Instance AssociatedFunction_or_insert :
      Notations.DoubleColon Self "or_insert" := {
      Notations.double_colon := or_insert;
    }.
    
    (*
        pub fn or_insert_with<F>(self, default: F) -> &'a mut Value
        where
            F: FnOnce() -> Value,
        {
            match self {
                Entry::Vacant(entry) => entry.insert(default()),
                Entry::Occupied(entry) => entry.into_mut(),
            }
        }
    *)
    Definition or_insert_with
        {F : Set}
        {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := unit)}
        (self : Self)
        (default : F)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* default := M.alloc default in
      M.read foo.
    
    Global Instance AssociatedFunction_or_insert_with
        {F : Set}
        {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := unit)} :
      Notations.DoubleColon Self "or_insert_with" := {
      Notations.double_colon := or_insert_with (F := F);
    }.
    
    (*
        pub fn and_modify<F>(self, f: F) -> Self
        where
            F: FnOnce(&mut Value),
        {
            match self {
                Entry::Occupied(mut entry) => {
                    f(entry.get_mut());
                    Entry::Occupied(entry)
                }
                Entry::Vacant(entry) => Entry::Vacant(entry),
            }
        }
    *)
    Definition and_modify
        {F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := mut_ref serde_json.value.Value.t)}
        (self : Self)
        (f : F)
        : M Self :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_and_modify
        {F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := mut_ref serde_json.value.Value.t)} :
      Notations.DoubleColon Self "and_modify" := {
      Notations.double_colon := and_modify (F := F);
    }.
  End Impl_serde_json_map_Entry_t.
  End Impl_serde_json_map_Entry_t.
  
  Module  Impl_serde_json_map_VacantEntry_t.
  Section Impl_serde_json_map_VacantEntry_t.
    Definition Self : Set := serde_json.map.VacantEntry.t.
    
    (*
        pub fn key(&self) -> &String {
            self.vacant.key()
        }
    *)
    Definition key (self : ref Self) : M (ref alloc.string.String.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_key :
      Notations.DoubleColon Self "key" := {
      Notations.double_colon := key;
    }.
    
    (*
        pub fn insert(self, value: Value) -> &'a mut Value {
            self.vacant.insert(value)
        }
    *)
    Definition insert
        (self : Self)
        (value : serde_json.value.Value.t)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_insert :
      Notations.DoubleColon Self "insert" := {
      Notations.double_colon := insert;
    }.
  End Impl_serde_json_map_VacantEntry_t.
  End Impl_serde_json_map_VacantEntry_t.
  
  Module  Impl_serde_json_map_OccupiedEntry_t.
  Section Impl_serde_json_map_OccupiedEntry_t.
    Definition Self : Set := serde_json.map.OccupiedEntry.t.
    
    (*
        pub fn key(&self) -> &String {
            self.occupied.key()
        }
    *)
    Definition key (self : ref Self) : M (ref alloc.string.String.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_key :
      Notations.DoubleColon Self "key" := {
      Notations.double_colon := key;
    }.
    
    (*
        pub fn get(&self) -> &Value {
            self.occupied.get()
        }
    *)
    Definition get (self : ref Self) : M (ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_get :
      Notations.DoubleColon Self "get" := {
      Notations.double_colon := get;
    }.
    
    (*
        pub fn get_mut(&mut self) -> &mut Value {
            self.occupied.get_mut()
        }
    *)
    Definition get_mut
        (self : mut_ref Self)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_get_mut :
      Notations.DoubleColon Self "get_mut" := {
      Notations.double_colon := get_mut;
    }.
    
    (*
        pub fn into_mut(self) -> &'a mut Value {
            self.occupied.into_mut()
        }
    *)
    Definition into_mut (self : Self) : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_mut :
      Notations.DoubleColon Self "into_mut" := {
      Notations.double_colon := into_mut;
    }.
    
    (*
        pub fn insert(&mut self, value: Value) -> Value {
            self.occupied.insert(value)
        }
    *)
    Definition insert
        (self : mut_ref Self)
        (value : serde_json.value.Value.t)
        : M serde_json.value.Value.t :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_insert :
      Notations.DoubleColon Self "insert" := {
      Notations.double_colon := insert;
    }.
    
    (*
        pub fn remove(self) -> Value {
            #[cfg(feature = "preserve_order")]
            return self.occupied.swap_remove();
            #[cfg(not(feature = "preserve_order"))]
            return self.occupied.remove();
        }
    *)
    Definition remove (self : Self) : M serde_json.value.Value.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_remove :
      Notations.DoubleColon Self "remove" := {
      Notations.double_colon := remove;
    }.
  End Impl_serde_json_map_OccupiedEntry_t.
  End Impl_serde_json_map_OccupiedEntry_t.
  
  Module  Impl_core_iter_traits_collect_IntoIterator_for_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_iter_traits_collect_IntoIterator_for_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      ref (serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t).
    
    (*
        type Item = (&'a String, &'a Value);
    *)
    Definition Item : Set :=
      (ref alloc.string.String.t) * (ref serde_json.value.Value.t).
    
    (*
        type IntoIter = Iter<'a>;
    *)
    Definition IntoIter : Set := serde_json.map.Iter.t.
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            Iter {
                iter: self.map.iter(),
            }
        }
    *)
    Definition into_iter (self : Self) : M IntoIter :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_iter :
      Notations.DoubleColon Self "into_iter" := {
      Notations.double_colon := into_iter;
    }.
    
    Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
      core.iter.traits.collect.IntoIterator.Item := Item;
      core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
      core.iter.traits.collect.IntoIterator.into_iter := into_iter;
    }.
  End Impl_core_iter_traits_collect_IntoIterator_for_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_iter_traits_collect_IntoIterator_for_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  Iter.
  Section Iter.
    Record t : Set := {
      iter : ltac:(serde_json.map.IterImpl);
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  End Iter.
  End Iter.
  
  Ltac IterImpl :=
    exact
      (alloc.collections.btree.map.Iter.t
        alloc.string.String.t
        serde_json.value.Value.t).
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Iter_t.
  Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Iter_t.
    Definition Self : Set := serde_json.map.Iter.t.
    
    (*
                type Item = $item;
    *)
    Definition Item : Set :=
      (ref alloc.string.String.t) * (ref serde_json.value.Value.t).
    
    (*
                fn next(&mut self) -> Option<Self::Item> {
                    self.iter.next()
                }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.iter.size_hint()
                }
    *)
    Definition size_hint
        (self : ref Self)
        : M (usize.t * (core.option.Option.t usize.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Iter_t.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Iter_t.
  
  Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Iter_t.
  Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Iter_t.
    Definition Self : Set := serde_json.map.Iter.t.
    
    (*
                fn next_back(&mut self) -> Option<Self::Item> {
                    self.iter.next_back()
                }
    *)
    Definition next_back
        (self : mut_ref Self)
        : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_back :
      Notations.DoubleColon Self "next_back" := {
      Notations.double_colon := next_back;
    }.
    
    Global Instance ℐ :
      core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
      core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
      core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
    }.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Iter_t.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Iter_t.
  
  Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Iter_t.
  Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Iter_t.
    Definition Self : Set := serde_json.map.Iter.t.
    
    (*
                fn len(&self) -> usize {
                    self.iter.len()
                }
    *)
    Definition len (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_len :
      Notations.DoubleColon Self "len" := {
      Notations.double_colon := len;
    }.
    
    Global Instance ℐ :
      core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
      core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
      core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
    }.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Iter_t.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Iter_t.
  
  Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Iter_t.
  Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Iter_t.
    Definition Self : Set := serde_json.map.Iter.t.
    
    Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
    }.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Iter_t.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Iter_t.
  
  Module  Impl_core_iter_traits_collect_IntoIterator_for_mut_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_iter_traits_collect_IntoIterator_for_mut_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      mut_ref
        (serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t).
    
    (*
        type Item = (&'a String, &'a mut Value);
    *)
    Definition Item : Set :=
      (ref alloc.string.String.t) * (mut_ref serde_json.value.Value.t).
    
    (*
        type IntoIter = IterMut<'a>;
    *)
    Definition IntoIter : Set := serde_json.map.IterMut.t.
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            IterMut {
                iter: self.map.iter_mut(),
            }
        }
    *)
    Definition into_iter (self : Self) : M IntoIter :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_iter :
      Notations.DoubleColon Self "into_iter" := {
      Notations.double_colon := into_iter;
    }.
    
    Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
      core.iter.traits.collect.IntoIterator.Item := Item;
      core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
      core.iter.traits.collect.IntoIterator.into_iter := into_iter;
    }.
  End Impl_core_iter_traits_collect_IntoIterator_for_mut_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_iter_traits_collect_IntoIterator_for_mut_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  IterMut.
  Section IterMut.
    Record t : Set := {
      iter : ltac:(serde_json.map.IterMutImpl);
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  End IterMut.
  End IterMut.
  
  Ltac IterMutImpl :=
    exact
      (alloc.collections.btree.map.IterMut.t
        alloc.string.String.t
        serde_json.value.Value.t).
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IterMut_t.
  Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IterMut_t.
    Definition Self : Set := serde_json.map.IterMut.t.
    
    (*
                type Item = $item;
    *)
    Definition Item : Set :=
      (ref alloc.string.String.t) * (mut_ref serde_json.value.Value.t).
    
    (*
                fn next(&mut self) -> Option<Self::Item> {
                    self.iter.next()
                }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.iter.size_hint()
                }
    *)
    Definition size_hint
        (self : ref Self)
        : M (usize.t * (core.option.Option.t usize.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IterMut_t.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IterMut_t.
  
  Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IterMut_t.
  Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IterMut_t.
    Definition Self : Set := serde_json.map.IterMut.t.
    
    (*
                fn next_back(&mut self) -> Option<Self::Item> {
                    self.iter.next_back()
                }
    *)
    Definition next_back
        (self : mut_ref Self)
        : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_back :
      Notations.DoubleColon Self "next_back" := {
      Notations.double_colon := next_back;
    }.
    
    Global Instance ℐ :
      core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
      core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
      core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
    }.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IterMut_t.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IterMut_t.
  
  Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IterMut_t.
  Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IterMut_t.
    Definition Self : Set := serde_json.map.IterMut.t.
    
    (*
                fn len(&self) -> usize {
                    self.iter.len()
                }
    *)
    Definition len (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_len :
      Notations.DoubleColon Self "len" := {
      Notations.double_colon := len;
    }.
    
    Global Instance ℐ :
      core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
      core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
      core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
    }.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IterMut_t.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IterMut_t.
  
  Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IterMut_t.
  Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IterMut_t.
    Definition Self : Set := serde_json.map.IterMut.t.
    
    Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
    }.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IterMut_t.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IterMut_t.
  
  Module  Impl_core_iter_traits_collect_IntoIterator_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Section Impl_core_iter_traits_collect_IntoIterator_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
    Definition Self : Set :=
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
    
    (*
        type Item = (String, Value);
    *)
    Definition Item : Set := alloc.string.String.t * serde_json.value.Value.t.
    
    (*
        type IntoIter = IntoIter;
    *)
    Definition IntoIter : Set := serde_json.map.IntoIter.t.
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            IntoIter {
                iter: self.map.into_iter(),
            }
        }
    *)
    Definition into_iter (self : Self) : M IntoIter :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_iter :
      Notations.DoubleColon Self "into_iter" := {
      Notations.double_colon := into_iter;
    }.
    
    Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
      core.iter.traits.collect.IntoIterator.Item := Item;
      core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
      core.iter.traits.collect.IntoIterator.into_iter := into_iter;
    }.
  End Impl_core_iter_traits_collect_IntoIterator_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  End Impl_core_iter_traits_collect_IntoIterator_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  
  Module  IntoIter.
  Section IntoIter.
    Record t : Set := {
      iter : ltac:(serde_json.map.IntoIterImpl);
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  End IntoIter.
  End IntoIter.
  
  Ltac IntoIterImpl :=
    exact
      (alloc.collections.btree.map.IntoIter.t
        alloc.string.String.t
        serde_json.value.Value.t
        alloc.collections.btree.map.IntoIter.Default.A).
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IntoIter_t.
  Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IntoIter_t.
    Definition Self : Set := serde_json.map.IntoIter.t.
    
    (*
                type Item = $item;
    *)
    Definition Item : Set := alloc.string.String.t * serde_json.value.Value.t.
    
    (*
                fn next(&mut self) -> Option<Self::Item> {
                    self.iter.next()
                }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.iter.size_hint()
                }
    *)
    Definition size_hint
        (self : ref Self)
        : M (usize.t * (core.option.Option.t usize.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IntoIter_t.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IntoIter_t.
  
  Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IntoIter_t.
  Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IntoIter_t.
    Definition Self : Set := serde_json.map.IntoIter.t.
    
    (*
                fn next_back(&mut self) -> Option<Self::Item> {
                    self.iter.next_back()
                }
    *)
    Definition next_back
        (self : mut_ref Self)
        : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_back :
      Notations.DoubleColon Self "next_back" := {
      Notations.double_colon := next_back;
    }.
    
    Global Instance ℐ :
      core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
      core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
      core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
    }.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IntoIter_t.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IntoIter_t.
  
  Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IntoIter_t.
  Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IntoIter_t.
    Definition Self : Set := serde_json.map.IntoIter.t.
    
    (*
                fn len(&self) -> usize {
                    self.iter.len()
                }
    *)
    Definition len (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_len :
      Notations.DoubleColon Self "len" := {
      Notations.double_colon := len;
    }.
    
    Global Instance ℐ :
      core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
      core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
      core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
    }.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IntoIter_t.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IntoIter_t.
  
  Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IntoIter_t.
  Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IntoIter_t.
    Definition Self : Set := serde_json.map.IntoIter.t.
    
    Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
    }.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IntoIter_t.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IntoIter_t.
  
  Module  Keys.
  Section Keys.
    Record t : Set := {
      iter : ltac:(serde_json.map.KeysImpl);
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  End Keys.
  End Keys.
  
  Ltac KeysImpl :=
    exact
      (alloc.collections.btree.map.Keys.t
        alloc.string.String.t
        serde_json.value.Value.t).
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Keys_t.
  Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Keys_t.
    Definition Self : Set := serde_json.map.Keys.t.
    
    (*
                type Item = $item;
    *)
    Definition Item : Set := ref alloc.string.String.t.
    
    (*
                fn next(&mut self) -> Option<Self::Item> {
                    self.iter.next()
                }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.iter.size_hint()
                }
    *)
    Definition size_hint
        (self : ref Self)
        : M (usize.t * (core.option.Option.t usize.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Keys_t.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Keys_t.
  
  Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Keys_t.
  Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Keys_t.
    Definition Self : Set := serde_json.map.Keys.t.
    
    (*
                fn next_back(&mut self) -> Option<Self::Item> {
                    self.iter.next_back()
                }
    *)
    Definition next_back
        (self : mut_ref Self)
        : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_back :
      Notations.DoubleColon Self "next_back" := {
      Notations.double_colon := next_back;
    }.
    
    Global Instance ℐ :
      core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
      core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
      core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
    }.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Keys_t.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Keys_t.
  
  Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Keys_t.
  Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Keys_t.
    Definition Self : Set := serde_json.map.Keys.t.
    
    (*
                fn len(&self) -> usize {
                    self.iter.len()
                }
    *)
    Definition len (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_len :
      Notations.DoubleColon Self "len" := {
      Notations.double_colon := len;
    }.
    
    Global Instance ℐ :
      core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
      core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
      core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
    }.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Keys_t.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Keys_t.
  
  Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Keys_t.
  Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Keys_t.
    Definition Self : Set := serde_json.map.Keys.t.
    
    Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
    }.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Keys_t.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Keys_t.
  
  Module  Values.
  Section Values.
    Record t : Set := {
      iter : ltac:(serde_json.map.ValuesImpl);
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  End Values.
  End Values.
  
  Ltac ValuesImpl :=
    exact
      (alloc.collections.btree.map.Values.t
        alloc.string.String.t
        serde_json.value.Value.t).
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Values_t.
  Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Values_t.
    Definition Self : Set := serde_json.map.Values.t.
    
    (*
                type Item = $item;
    *)
    Definition Item : Set := ref serde_json.value.Value.t.
    
    (*
                fn next(&mut self) -> Option<Self::Item> {
                    self.iter.next()
                }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.iter.size_hint()
                }
    *)
    Definition size_hint
        (self : ref Self)
        : M (usize.t * (core.option.Option.t usize.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Values_t.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Values_t.
  
  Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Values_t.
  Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Values_t.
    Definition Self : Set := serde_json.map.Values.t.
    
    (*
                fn next_back(&mut self) -> Option<Self::Item> {
                    self.iter.next_back()
                }
    *)
    Definition next_back
        (self : mut_ref Self)
        : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_back :
      Notations.DoubleColon Self "next_back" := {
      Notations.double_colon := next_back;
    }.
    
    Global Instance ℐ :
      core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
      core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
      core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
    }.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Values_t.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Values_t.
  
  Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Values_t.
  Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Values_t.
    Definition Self : Set := serde_json.map.Values.t.
    
    (*
                fn len(&self) -> usize {
                    self.iter.len()
                }
    *)
    Definition len (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_len :
      Notations.DoubleColon Self "len" := {
      Notations.double_colon := len;
    }.
    
    Global Instance ℐ :
      core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
      core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
      core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
    }.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Values_t.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Values_t.
  
  Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Values_t.
  Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Values_t.
    Definition Self : Set := serde_json.map.Values.t.
    
    Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
    }.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Values_t.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Values_t.
  
  Module  ValuesMut.
  Section ValuesMut.
    Record t : Set := {
      iter : ltac:(serde_json.map.ValuesMutImpl);
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  End ValuesMut.
  End ValuesMut.
  
  Ltac ValuesMutImpl :=
    exact
      (alloc.collections.btree.map.ValuesMut.t
        alloc.string.String.t
        serde_json.value.Value.t).
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_ValuesMut_t.
  Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_ValuesMut_t.
    Definition Self : Set := serde_json.map.ValuesMut.t.
    
    (*
                type Item = $item;
    *)
    Definition Item : Set := mut_ref serde_json.value.Value.t.
    
    (*
                fn next(&mut self) -> Option<Self::Item> {
                    self.iter.next()
                }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.iter.size_hint()
                }
    *)
    Definition size_hint
        (self : ref Self)
        : M (usize.t * (core.option.Option.t usize.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_ValuesMut_t.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_ValuesMut_t.
  
  Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_ValuesMut_t.
  Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_ValuesMut_t.
    Definition Self : Set := serde_json.map.ValuesMut.t.
    
    (*
                fn next_back(&mut self) -> Option<Self::Item> {
                    self.iter.next_back()
                }
    *)
    Definition next_back
        (self : mut_ref Self)
        : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_back :
      Notations.DoubleColon Self "next_back" := {
      Notations.double_colon := next_back;
    }.
    
    Global Instance ℐ :
      core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
      core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
      core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
        Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
      core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
    }.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_ValuesMut_t.
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_ValuesMut_t.
  
  Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_ValuesMut_t.
  Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_ValuesMut_t.
    Definition Self : Set := serde_json.map.ValuesMut.t.
    
    (*
                fn len(&self) -> usize {
                    self.iter.len()
                }
    *)
    Definition len (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_len :
      Notations.DoubleColon Self "len" := {
      Notations.double_colon := len;
    }.
    
    Global Instance ℐ :
      core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
      core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
      core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
    }.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_ValuesMut_t.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_ValuesMut_t.
  
  Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_ValuesMut_t.
  Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_ValuesMut_t.
    Definition Self : Set := serde_json.map.ValuesMut.t.
    
    Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
    }.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_ValuesMut_t.
  End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_ValuesMut_t.
End map.

Module  Map.
Section Map.
  Context (K V : Set).
  
  Record t : Set := {
    map : ltac:(serde_json.map.MapImpl K V);
  }.
  
  Definition Get_map :=
    Ref.map (fun α => Some α.(map)) (fun β α => Some (α <| map := β |>)).
End Map.
End Map.

Ltac MapImpl K V :=
  exact
    (alloc.collections.btree.map.BTreeMap.t
      K
      V
      alloc.collections.btree.map.BTreeMap.Default.A).

Module  Impl_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_2.
Section Impl_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_2.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      pub fn new() -> Self {
          Map {
              map: MapImpl::new(),
          }
      }
  *)
  Definition new : M Self := M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn with_capacity(capacity: usize) -> Self {
          Map {
              #[cfg(not(feature = "preserve_order"))]
              map: {
                  // does not support with_capacity
                  let _ = capacity;
                  BTreeMap::new()
              },
              #[cfg(feature = "preserve_order")]
              map: IndexMap::with_capacity(capacity),
          }
      }
  *)
  Definition with_capacity (capacity : usize.t) : M Self :=
    let* capacity := M.alloc capacity in
    M.read foo.
  
  Global Instance AssociatedFunction_with_capacity :
    Notations.DoubleColon Self "with_capacity" := {
    Notations.double_colon := with_capacity;
  }.
  
  (*
      pub fn clear(&mut self) {
          self.map.clear();
      }
  *)
  Definition clear (self : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clear :
    Notations.DoubleColon Self "clear" := {
    Notations.double_colon := clear;
  }.
  
  (*
      pub fn get<Q>(&self, key: &Q) -> Option<&Value>
      where
          String: Borrow<Q>,
          Q: ?Sized + Ord + Eq + Hash,
      {
          self.map.get(key)
      }
  *)
  Definition get
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q}
      (self : ref Self)
      (key : ref Q)
      : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_get
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q} :
    Notations.DoubleColon Self "get" := {
    Notations.double_colon := get (Q := Q);
  }.
  
  (*
      pub fn contains_key<Q>(&self, key: &Q) -> bool
      where
          String: Borrow<Q>,
          Q: ?Sized + Ord + Eq + Hash,
      {
          self.map.contains_key(key)
      }
  *)
  Definition contains_key
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q}
      (self : ref Self)
      (key : ref Q)
      : M bool.t :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_contains_key
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q} :
    Notations.DoubleColon Self "contains_key" := {
    Notations.double_colon := contains_key (Q := Q);
  }.
  
  (*
      pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut Value>
      where
          String: Borrow<Q>,
          Q: ?Sized + Ord + Eq + Hash,
      {
          self.map.get_mut(key)
      }
  *)
  Definition get_mut
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q}
      (self : mut_ref Self)
      (key : ref Q)
      : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_get_mut
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q} :
    Notations.DoubleColon Self "get_mut" := {
    Notations.double_colon := get_mut (Q := Q);
  }.
  
  (*
      pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&String, &Value)>
      where
          String: Borrow<Q>,
          Q: ?Sized + Ord + Eq + Hash,
      {
          self.map.get_key_value(key)
      }
  *)
  Definition get_key_value
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q}
      (self : ref Self)
      (key : ref Q)
      :
        M
          (core.option.Option.t
            ((ref alloc.string.String.t) * (ref serde_json.value.Value.t))) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_get_key_value
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q} :
    Notations.DoubleColon Self "get_key_value" := {
    Notations.double_colon := get_key_value (Q := Q);
  }.
  
  (*
      pub fn insert(&mut self, k: String, v: Value) -> Option<Value> {
          self.map.insert(k, v)
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (k : alloc.string.String.t)
      (v : serde_json.value.Value.t)
      : M (core.option.Option.t serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* k := M.alloc k in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      pub fn remove<Q>(&mut self, key: &Q) -> Option<Value>
      where
          String: Borrow<Q>,
          Q: ?Sized + Ord + Eq + Hash,
      {
          #[cfg(feature = "preserve_order")]
          return self.map.swap_remove(key);
          #[cfg(not(feature = "preserve_order"))]
          return self.map.remove(key);
      }
  *)
  Definition remove
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q}
      (self : mut_ref Self)
      (key : ref Q)
      : M (core.option.Option.t serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_remove
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q} :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove (Q := Q);
  }.
  
  (*
      pub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(String, Value)>
      where
          String: Borrow<Q>,
          Q: ?Sized + Ord + Eq + Hash,
      {
          self.map.remove_entry(key)
      }
  *)
  Definition remove_entry
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q}
      (self : mut_ref Self)
      (key : ref Q)
      :
        M
          (core.option.Option.t
            (alloc.string.String.t * serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_remove_entry
      {Q : Set}
      {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
      {ℋ_1 : core.cmp.Ord.Trait Q}
      {ℋ_2 : core.cmp.Eq.Trait Q}
      {ℋ_3 : core.hash.Hash.Trait Q} :
    Notations.DoubleColon Self "remove_entry" := {
    Notations.double_colon := remove_entry (Q := Q);
  }.
  
  (*
      pub fn append(&mut self, other: &mut Self) {
          #[cfg(feature = "preserve_order")]
          self.map
              .extend(mem::replace(&mut other.map, MapImpl::default()));
          #[cfg(not(feature = "preserve_order"))]
          self.map.append(&mut other.map);
      }
  *)
  Definition append (self : mut_ref Self) (other : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_append :
    Notations.DoubleColon Self "append" := {
    Notations.double_colon := append;
  }.
  
  (*
      pub fn entry<S>(&mut self, key: S) -> Entry
      where
          S: Into<String>,
      {
          #[cfg(not(feature = "preserve_order"))]
          use alloc::collections::btree_map::Entry as EntryImpl;
          #[cfg(feature = "preserve_order")]
          use indexmap::map::Entry as EntryImpl;
  
          match self.map.entry(key.into()) {
              EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),
              EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),
          }
      }
  *)
  Definition entry
      {S : Set}
      {ℋ_0 : core.convert.Into.Trait S (T := alloc.string.String.t)}
      (self : mut_ref Self)
      (key : S)
      : M serde_json.map.Entry.t :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_entry
      {S : Set}
      {ℋ_0 : core.convert.Into.Trait S (T := alloc.string.String.t)} :
    Notations.DoubleColon Self "entry" := {
    Notations.double_colon := entry (S := S);
  }.
  
  (*
      pub fn len(&self) -> usize {
          self.map.len()
      }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  (*
      pub fn is_empty(&self) -> bool {
          self.map.is_empty()
      }
  *)
  Definition is_empty (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_empty :
    Notations.DoubleColon Self "is_empty" := {
    Notations.double_colon := is_empty;
  }.
  
  (*
      pub fn iter(&self) -> Iter {
          Iter {
              iter: self.map.iter(),
          }
      }
  *)
  Definition iter (self : ref Self) : M serde_json.map.Iter.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_iter :
    Notations.DoubleColon Self "iter" := {
    Notations.double_colon := iter;
  }.
  
  (*
      pub fn iter_mut(&mut self) -> IterMut {
          IterMut {
              iter: self.map.iter_mut(),
          }
      }
  *)
  Definition iter_mut (self : mut_ref Self) : M serde_json.map.IterMut.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_iter_mut :
    Notations.DoubleColon Self "iter_mut" := {
    Notations.double_colon := iter_mut;
  }.
  
  (*
      pub fn keys(&self) -> Keys {
          Keys {
              iter: self.map.keys(),
          }
      }
  *)
  Definition keys (self : ref Self) : M serde_json.map.Keys.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_keys :
    Notations.DoubleColon Self "keys" := {
    Notations.double_colon := keys;
  }.
  
  (*
      pub fn values(&self) -> Values {
          Values {
              iter: self.map.values(),
          }
      }
  *)
  Definition values (self : ref Self) : M serde_json.map.Values.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_values :
    Notations.DoubleColon Self "values" := {
    Notations.double_colon := values;
  }.
  
  (*
      pub fn values_mut(&mut self) -> ValuesMut {
          ValuesMut {
              iter: self.map.values_mut(),
          }
      }
  *)
  Definition values_mut (self : mut_ref Self) : M serde_json.map.ValuesMut.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_values_mut :
    Notations.DoubleColon Self "values_mut" := {
    Notations.double_colon := values_mut;
  }.
  
  (*
      pub fn retain<F>(&mut self, f: F)
      where
          F: FnMut(&String, &mut Value) -> bool,
      {
          self.map.retain(f);
      }
  *)
  Definition retain
      {F : Set}
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (ref alloc.string.String.t)
          *
          (mut_ref serde_json.value.Value.t))}
      (self : mut_ref Self)
      (f : F)
      : M unit :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_retain
      {F : Set}
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (ref alloc.string.String.t)
          *
          (mut_ref serde_json.value.Value.t))} :
    Notations.DoubleColon Self "retain" := {
    Notations.double_colon := retain (F := F);
  }.
End Impl_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_2.
End Impl_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_2.

Module  Impl_core_default_Default_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_default_Default_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn default() -> Self {
          Map {
              map: MapImpl::new(),
          }
      }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_default_Default_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_core_clone_Clone_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_clone_Clone_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn clone(&self) -> Self {
          Map {
              map: self.map.clone(),
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  (*
      fn clone_from(&mut self, source: &Self) {
          self.map.clone_from(&source.map);
      }
  *)
  Definition clone_from (self : mut_ref Self) (source : ref Self) : M unit :=
    let* self := M.alloc self in
    let* source := M.alloc source in
    M.read foo.
  
  Global Instance AssociatedFunction_clone_from :
    Notations.DoubleColon Self "clone_from" := {
    Notations.double_colon := clone_from;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.Some clone_from;
  }.
End Impl_core_clone_Clone_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_clone_Clone_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn eq(&self, other: &Self) -> bool {
          self.map.eq(&other.map)
      }
  *)
  Definition eq (self : ref Self) (other : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_core_cmp_Eq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_cmp_Eq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_cmp_Eq_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_core_ops_index_Index_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_ops_index_Index_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Context {Q : Set}.
  
  Context
    {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
    {ℋ_1 : core.cmp.Ord.Trait Q}
    {ℋ_2 : core.cmp.Eq.Trait Q}
    {ℋ_3 : core.hash.Hash.Trait Q}.
  
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      type Output = Value;
  *)
  Definition Output : Set := serde_json.value.Value.t.
  
  (*
      fn index(&self, index: &Q) -> &Value {
          self.map.index(index)
      }
  *)
  Definition index
      (self : ref Self)
      (index : ref Q)
      : M (ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* index := M.alloc index in
    M.read foo.
  
  Global Instance AssociatedFunction_index :
    Notations.DoubleColon Self "index" := {
    Notations.double_colon := index;
  }.
  
  Global Instance ℐ : core.ops.index.Index.Trait Self (Idx := ref Q) := {
    core.ops.index.Index.Output := Output;
    core.ops.index.Index.index := index;
  }.
End Impl_core_ops_index_Index_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_ops_index_Index_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_core_ops_index_IndexMut_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_ops_index_IndexMut_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Context {Q : Set}.
  
  Context
    {ℋ_0 : core.borrow.Borrow.Trait alloc.string.String.t (Borrowed := Q)}
    {ℋ_1 : core.cmp.Ord.Trait Q}
    {ℋ_2 : core.cmp.Eq.Trait Q}
    {ℋ_3 : core.hash.Hash.Trait Q}.
  
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn index_mut(&mut self, index: &Q) -> &mut Value {
          self.map.get_mut(index).expect("no entry found for key")
      }
  *)
  Definition index_mut
      (self : mut_ref Self)
      (index : ref Q)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* index := M.alloc index in
    M.read foo.
  
  Global Instance AssociatedFunction_index_mut :
    Notations.DoubleColon Self "index_mut" := {
    Notations.double_colon := index_mut;
  }.
  
  Global Instance ℐ : core.ops.index.IndexMut.Trait Self (Idx := ref Q) := {
    core.ops.index.IndexMut.index_mut := index_mut;
  }.
End Impl_core_ops_index_IndexMut_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_ops_index_IndexMut_ref_Q_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_core_fmt_Debug_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_fmt_Debug_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {
          self.map.fmt(formatter)
      }
  *)
  Definition fmt
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M (core.result.Result.t unit core.fmt.Error.t) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_fmt_Debug_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_serde_ser_Serialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_serde_ser_Serialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
      where
          S: serde::ser::Serializer,
      {
          use serde::ser::SerializeMap;
          let mut map = tri!(serializer.serialize_map(Some(self.len())));
          for (k, v) in self {
              tri!(map.serialize_entry(k, v));
          }
          map.end()
      }
  *)
  Definition serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S}
      (self : ref Self)
      (serializer : S)
      : M (core.result.Result.t S::type["Ok"].t S::type["Error"].t) :=
    let* self := M.alloc self in
    let* serializer := M.alloc serializer in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S} :
    Notations.DoubleColon Self "serialize" := {
    Notations.double_colon := serialize (S := S);
  }.
  
  Global Instance ℐ : serde.ser.Serialize.Trait Self := {
    serde.ser.Serialize.serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S} :=
      serialize (S := S);
  }.
End Impl_serde_ser_Serialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_serde_ser_Serialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_serde_de_Deserialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_serde_de_Deserialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
      where
          D: de::Deserializer<'de>,
      {
          struct Visitor;
  
          impl<'de> de::Visitor<'de> for Visitor {
              type Value = Map<String, Value>;
  
              fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                  formatter.write_str("a map")
              }
  
              #[inline]
              fn visit_unit<E>(self) -> Result<Self::Value, E>
              where
                  E: de::Error,
              {
                  Ok(Map::new())
              }
  
              #[cfg(any(feature = "std", feature = "alloc"))]
              #[inline]
              fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
              where
                  V: de::MapAccess<'de>,
              {
                  let mut values = Map::new();
  
                  while let Some((key, value)) = tri!(visitor.next_entry()) {
                      values.insert(key, value);
                  }
  
                  Ok(values)
              }
          }
  
          deserializer.deserialize_map(Visitor)
      }
  *)
  Definition deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D}
      (deserializer : D)
      : M (core.result.Result.t Self D::type["Error"].t) :=
    let* deserializer := M.alloc deserializer in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :
    Notations.DoubleColon Self "deserialize" := {
    Notations.double_colon := deserialize (D := D);
  }.
  
  Global Instance ℐ : serde.de.Deserialize.Required.Trait Self := {
    serde.de.Deserialize.deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :=
      deserialize (D := D);
    serde.de.Deserialize.deserialize_in_place := Datatypes.None;
  }.
End Impl_serde_de_Deserialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_serde_de_Deserialize_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Visitor.
Section Visitor.
  Inductive t : Set := Build.
End Visitor.
End Visitor.

Module  Impl_serde_de_Visitor_for_serde_json_map_deserialize_Visitor_t.
Section Impl_serde_de_Visitor_for_serde_json_map_deserialize_Visitor_t.
  Definition Self : Set := serde_json.map.deserialize.Visitor.t.
  
  (*
              type Value = Map<String, Value>;
  *)
  Definition Value : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
              fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                  formatter.write_str("a map")
              }
  *)
  Definition expecting
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_expecting :
    Notations.DoubleColon Self "expecting" := {
    Notations.double_colon := expecting;
  }.
  
  (*
              fn visit_unit<E>(self) -> Result<Self::Value, E>
              where
                  E: de::Error,
              {
                  Ok(Map::new())
              }
  *)
  Definition visit_unit
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E}
      (self : Self)
      : M (core.result.Result.t Value E) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_unit
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E} :
    Notations.DoubleColon Self "visit_unit" := {
    Notations.double_colon := visit_unit (E := E);
  }.
  
  (*
              fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
              where
                  V: de::MapAccess<'de>,
              {
                  let mut values = Map::new();
  
                  while let Some((key, value)) = tri!(visitor.next_entry()) {
                      values.insert(key, value);
                  }
  
                  Ok(values)
              }
  *)
  Definition visit_map
      {V : Set}
      {ℋ_0 : serde.de.MapAccess.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t Value V::type["Error"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_map
      {V : Set}
      {ℋ_0 : serde.de.MapAccess.Trait V} :
    Notations.DoubleColon Self "visit_map" := {
    Notations.double_colon := visit_map (V := V);
  }.
  
  Global Instance ℐ : serde.de.Visitor.Required.Trait Self := {
    serde.de.Visitor.Value := Value;
    serde.de.Visitor.expecting := expecting;
    serde.de.Visitor.visit_unit {E : Set} {ℋ_0 : serde.de.Error.Trait E} :=
      Datatypes.Some (visit_unit (E := E));
    serde.de.Visitor.visit_map {V : Set} {ℋ_0 : serde.de.MapAccess.Trait V} :=
      Datatypes.Some (visit_map (V := V));
    serde.de.Visitor.visit_bool := Datatypes.None;
    serde.de.Visitor.visit_i8 := Datatypes.None;
    serde.de.Visitor.visit_i16 := Datatypes.None;
    serde.de.Visitor.visit_i32 := Datatypes.None;
    serde.de.Visitor.visit_i64 := Datatypes.None;
    serde.de.Visitor.visit_i128 := Datatypes.None;
    serde.de.Visitor.visit_u8 := Datatypes.None;
    serde.de.Visitor.visit_u16 := Datatypes.None;
    serde.de.Visitor.visit_u32 := Datatypes.None;
    serde.de.Visitor.visit_u64 := Datatypes.None;
    serde.de.Visitor.visit_u128 := Datatypes.None;
    serde.de.Visitor.visit_f32 := Datatypes.None;
    serde.de.Visitor.visit_f64 := Datatypes.None;
    serde.de.Visitor.visit_char := Datatypes.None;
    serde.de.Visitor.visit_str := Datatypes.None;
    serde.de.Visitor.visit_borrowed_str := Datatypes.None;
    serde.de.Visitor.visit_string := Datatypes.None;
    serde.de.Visitor.visit_bytes := Datatypes.None;
    serde.de.Visitor.visit_borrowed_bytes := Datatypes.None;
    serde.de.Visitor.visit_byte_buf := Datatypes.None;
    serde.de.Visitor.visit_none := Datatypes.None;
    serde.de.Visitor.visit_some := Datatypes.None;
    serde.de.Visitor.visit_newtype_struct := Datatypes.None;
    serde.de.Visitor.visit_seq := Datatypes.None;
    serde.de.Visitor.visit_enum := Datatypes.None;
    serde.de.Visitor.__private_visit_untagged_option := Datatypes.None;
  }.
End Impl_serde_de_Visitor_for_serde_json_map_deserialize_Visitor_t.
End Impl_serde_de_Visitor_for_serde_json_map_deserialize_Visitor_t.

Module  Impl_core_iter_traits_collect_FromIterator_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_iter_traits_collect_FromIterator_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn from_iter<T>(iter: T) -> Self
      where
          T: IntoIterator<Item = (String, Value)>,
      {
          Map {
              map: FromIterator::from_iter(iter),
          }
      }
  *)
  Definition from_iter
      {T : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T}
      (iter : T)
      : M Self :=
    let* iter := M.alloc iter in
    M.read foo.
  
  Global Instance AssociatedFunction_from_iter
      {T : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T} :
    Notations.DoubleColon Self "from_iter" := {
    Notations.double_colon := from_iter (T := T);
  }.
  
  Global Instance ℐ :
    core.iter.traits.collect.FromIterator.Trait Self
      (A := alloc.string.String.t * serde_json.value.Value.t) := {
    core.iter.traits.collect.FromIterator.from_iter
      {T : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T} :=
      from_iter (T := T);
  }.
End Impl_core_iter_traits_collect_FromIterator_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_iter_traits_collect_FromIterator_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Impl_core_iter_traits_collect_Extend_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_iter_traits_collect_Extend_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      fn extend<T>(&mut self, iter: T)
      where
          T: IntoIterator<Item = (String, Value)>,
      {
          self.map.extend(iter);
      }
  *)
  Definition extend
      {T : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T}
      (self : mut_ref Self)
      (iter : T)
      : M unit :=
    let* self := M.alloc self in
    let* iter := M.alloc iter in
    M.read foo.
  
  Global Instance AssociatedFunction_extend
      {T : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T} :
    Notations.DoubleColon Self "extend" := {
    Notations.double_colon := extend (T := T);
  }.
  
  Global Instance ℐ :
    core.iter.traits.collect.Extend.Required.Trait Self
      (A := alloc.string.String.t * serde_json.value.Value.t) := {
    core.iter.traits.collect.Extend.extend
      {T : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait T} :=
      extend (T := T);
    core.iter.traits.collect.Extend.extend_one := Datatypes.None;
    core.iter.traits.collect.Extend.extend_reserve := Datatypes.None;
  }.
End Impl_core_iter_traits_collect_Extend_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_iter_traits_collect_Extend_Tuple_alloc_string_String_t_serde_json_value_Value_t__for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module Entry.
  Inductive t : Set :=
  | Vacant (_ : serde_json.map.VacantEntry.t)
  | Occupied (_ : serde_json.map.OccupiedEntry.t).
  
  Definition Get_Vacant_0 :=
    Ref.map
      (fun α => match α with | Vacant α0 => Some α0 | _ => None end)
      (fun β α => match α with | Vacant _ => Some (Vacant β) | _ => None end).
  
  Definition Get_Occupied_0 :=
    Ref.map
      (fun α => match α with | Occupied α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Occupied _ => Some (Occupied β) | _ => None end).
End Entry.

Module  VacantEntry.
Section VacantEntry.
  Record t : Set := {
    vacant : ltac:(serde_json.map.VacantEntryImpl);
  }.
  
  Definition Get_vacant :=
    Ref.map (fun α => Some α.(vacant)) (fun β α => Some (α <| vacant := β |>)).
End VacantEntry.
End VacantEntry.

Module  OccupiedEntry.
Section OccupiedEntry.
  Record t : Set := {
    occupied : ltac:(serde_json.map.OccupiedEntryImpl);
  }.
  
  Definition Get_occupied :=
    Ref.map
      (fun α => Some α.(occupied))
      (fun β α => Some (α <| occupied := β |>)).
End OccupiedEntry.
End OccupiedEntry.

Ltac VacantEntryImpl :=
  exact
    (alloc.collections.btree.map.entry.VacantEntry.t
      alloc.string.String.t
      serde_json.value.Value.t
      alloc.collections.btree.map.entry.VacantEntry.Default.A).

Ltac OccupiedEntryImpl :=
  exact
    (alloc.collections.btree.map.entry.OccupiedEntry.t
      alloc.string.String.t
      serde_json.value.Value.t
      alloc.collections.btree.map.entry.OccupiedEntry.Default.A).

Module  Impl_serde_json_map_Entry_t_2.
Section Impl_serde_json_map_Entry_t_2.
  Definition Self : Set := serde_json.map.Entry.t.
  
  (*
      pub fn key(&self) -> &String {
          match self {
              Entry::Vacant(e) => e.key(),
              Entry::Occupied(e) => e.key(),
          }
      }
  *)
  Definition key (self : ref Self) : M (ref alloc.string.String.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_key : Notations.DoubleColon Self "key" := {
    Notations.double_colon := key;
  }.
  
  (*
      pub fn or_insert(self, default: Value) -> &'a mut Value {
          match self {
              Entry::Vacant(entry) => entry.insert(default),
              Entry::Occupied(entry) => entry.into_mut(),
          }
      }
  *)
  Definition or_insert
      (self : Self)
      (default : serde_json.value.Value.t)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* default := M.alloc default in
    M.read foo.
  
  Global Instance AssociatedFunction_or_insert :
    Notations.DoubleColon Self "or_insert" := {
    Notations.double_colon := or_insert;
  }.
  
  (*
      pub fn or_insert_with<F>(self, default: F) -> &'a mut Value
      where
          F: FnOnce() -> Value,
      {
          match self {
              Entry::Vacant(entry) => entry.insert(default()),
              Entry::Occupied(entry) => entry.into_mut(),
          }
      }
  *)
  Definition or_insert_with
      {F : Set}
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (default : F)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* default := M.alloc default in
    M.read foo.
  
  Global Instance AssociatedFunction_or_insert_with
      {F : Set}
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notations.DoubleColon Self "or_insert_with" := {
    Notations.double_colon := or_insert_with (F := F);
  }.
  
  (*
      pub fn and_modify<F>(self, f: F) -> Self
      where
          F: FnOnce(&mut Value),
      {
          match self {
              Entry::Occupied(mut entry) => {
                  f(entry.get_mut());
                  Entry::Occupied(entry)
              }
              Entry::Vacant(entry) => Entry::Vacant(entry),
          }
      }
  *)
  Definition and_modify
      {F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := mut_ref serde_json.value.Value.t)}
      (self : Self)
      (f : F)
      : M Self :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_and_modify
      {F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := mut_ref serde_json.value.Value.t)} :
    Notations.DoubleColon Self "and_modify" := {
    Notations.double_colon := and_modify (F := F);
  }.
End Impl_serde_json_map_Entry_t_2.
End Impl_serde_json_map_Entry_t_2.

Module  Impl_serde_json_map_VacantEntry_t_2.
Section Impl_serde_json_map_VacantEntry_t_2.
  Definition Self : Set := serde_json.map.VacantEntry.t.
  
  (*
      pub fn key(&self) -> &String {
          self.vacant.key()
      }
  *)
  Definition key (self : ref Self) : M (ref alloc.string.String.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_key : Notations.DoubleColon Self "key" := {
    Notations.double_colon := key;
  }.
  
  (*
      pub fn insert(self, value: Value) -> &'a mut Value {
          self.vacant.insert(value)
      }
  *)
  Definition insert
      (self : Self)
      (value : serde_json.value.Value.t)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
End Impl_serde_json_map_VacantEntry_t_2.
End Impl_serde_json_map_VacantEntry_t_2.

Module  Impl_serde_json_map_OccupiedEntry_t_2.
Section Impl_serde_json_map_OccupiedEntry_t_2.
  Definition Self : Set := serde_json.map.OccupiedEntry.t.
  
  (*
      pub fn key(&self) -> &String {
          self.occupied.key()
      }
  *)
  Definition key (self : ref Self) : M (ref alloc.string.String.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_key : Notations.DoubleColon Self "key" := {
    Notations.double_colon := key;
  }.
  
  (*
      pub fn get(&self) -> &Value {
          self.occupied.get()
      }
  *)
  Definition get (self : ref Self) : M (ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      pub fn get_mut(&mut self) -> &mut Value {
          self.occupied.get_mut()
      }
  *)
  Definition get_mut
      (self : mut_ref Self)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_get_mut :
    Notations.DoubleColon Self "get_mut" := {
    Notations.double_colon := get_mut;
  }.
  
  (*
      pub fn into_mut(self) -> &'a mut Value {
          self.occupied.into_mut()
      }
  *)
  Definition into_mut (self : Self) : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_mut :
    Notations.DoubleColon Self "into_mut" := {
    Notations.double_colon := into_mut;
  }.
  
  (*
      pub fn insert(&mut self, value: Value) -> Value {
          self.occupied.insert(value)
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (value : serde_json.value.Value.t)
      : M serde_json.value.Value.t :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      pub fn remove(self) -> Value {
          #[cfg(feature = "preserve_order")]
          return self.occupied.swap_remove();
          #[cfg(not(feature = "preserve_order"))]
          return self.occupied.remove();
      }
  *)
  Definition remove (self : Self) : M serde_json.value.Value.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
End Impl_serde_json_map_OccupiedEntry_t_2.
End Impl_serde_json_map_OccupiedEntry_t_2.

Module  Impl_core_iter_traits_collect_IntoIterator_for_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_iter_traits_collect_IntoIterator_for_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    ref (serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t).
  
  (*
      type Item = (&'a String, &'a Value);
  *)
  Definition Item : Set :=
    (ref alloc.string.String.t) * (ref serde_json.value.Value.t).
  
  (*
      type IntoIter = Iter<'a>;
  *)
  Definition IntoIter : Set := serde_json.map.Iter.t.
  
  (*
      fn into_iter(self) -> Self::IntoIter {
          Iter {
              iter: self.map.iter(),
          }
      }
  *)
  Definition into_iter (self : Self) : M IntoIter :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_iter :
    Notations.DoubleColon Self "into_iter" := {
    Notations.double_colon := into_iter;
  }.
  
  Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
    core.iter.traits.collect.IntoIterator.Item := Item;
    core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
    core.iter.traits.collect.IntoIterator.into_iter := into_iter;
  }.
End Impl_core_iter_traits_collect_IntoIterator_for_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_iter_traits_collect_IntoIterator_for_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  Iter.
Section Iter.
  Record t : Set := {
    iter : ltac:(serde_json.map.IterImpl);
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
End Iter.
End Iter.

Ltac IterImpl :=
  exact
    (alloc.collections.btree.map.Iter.t
      alloc.string.String.t
      serde_json.value.Value.t).

Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Iter_t.
Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Iter_t.
  Definition Self : Set := serde_json.map.Iter.t.
  
  (*
              type Item = $item;
  *)
  Definition Item : Set :=
    (ref alloc.string.String.t) * (ref serde_json.value.Value.t).
  
  (*
              fn next(&mut self) -> Option<Self::Item> {
                  self.iter.next()
              }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
              fn size_hint(&self) -> (usize, Option<usize>) {
                  self.iter.size_hint()
              }
  *)
  Definition size_hint
      (self : ref Self)
      : M (usize.t * (core.option.Option.t usize.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Iter_t.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Iter_t.

Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Iter_t.
Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Iter_t.
  Definition Self : Set := serde_json.map.Iter.t.
  
  (*
              fn next_back(&mut self) -> Option<Self::Item> {
                  self.iter.next_back()
              }
  *)
  Definition next_back (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_back :
    Notations.DoubleColon Self "next_back" := {
    Notations.double_colon := next_back;
  }.
  
  Global Instance ℐ :
    core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
    core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
    core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
  }.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Iter_t.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Iter_t.

Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Iter_t.
Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Iter_t.
  Definition Self : Set := serde_json.map.Iter.t.
  
  (*
              fn len(&self) -> usize {
                  self.iter.len()
              }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  Global Instance ℐ :
    core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
    core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
    core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
  }.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Iter_t.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Iter_t.

Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Iter_t.
Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Iter_t.
  Definition Self : Set := serde_json.map.Iter.t.
  
  Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
  }.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Iter_t.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Iter_t.

Module  Impl_core_iter_traits_collect_IntoIterator_for_mut_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_iter_traits_collect_IntoIterator_for_mut_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    mut_ref
      (serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t).
  
  (*
      type Item = (&'a String, &'a mut Value);
  *)
  Definition Item : Set :=
    (ref alloc.string.String.t) * (mut_ref serde_json.value.Value.t).
  
  (*
      type IntoIter = IterMut<'a>;
  *)
  Definition IntoIter : Set := serde_json.map.IterMut.t.
  
  (*
      fn into_iter(self) -> Self::IntoIter {
          IterMut {
              iter: self.map.iter_mut(),
          }
      }
  *)
  Definition into_iter (self : Self) : M IntoIter :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_iter :
    Notations.DoubleColon Self "into_iter" := {
    Notations.double_colon := into_iter;
  }.
  
  Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
    core.iter.traits.collect.IntoIterator.Item := Item;
    core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
    core.iter.traits.collect.IntoIterator.into_iter := into_iter;
  }.
End Impl_core_iter_traits_collect_IntoIterator_for_mut_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_iter_traits_collect_IntoIterator_for_mut_ref_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  IterMut.
Section IterMut.
  Record t : Set := {
    iter : ltac:(serde_json.map.IterMutImpl);
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
End IterMut.
End IterMut.

Ltac IterMutImpl :=
  exact
    (alloc.collections.btree.map.IterMut.t
      alloc.string.String.t
      serde_json.value.Value.t).

Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IterMut_t.
Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IterMut_t.
  Definition Self : Set := serde_json.map.IterMut.t.
  
  (*
              type Item = $item;
  *)
  Definition Item : Set :=
    (ref alloc.string.String.t) * (mut_ref serde_json.value.Value.t).
  
  (*
              fn next(&mut self) -> Option<Self::Item> {
                  self.iter.next()
              }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
              fn size_hint(&self) -> (usize, Option<usize>) {
                  self.iter.size_hint()
              }
  *)
  Definition size_hint
      (self : ref Self)
      : M (usize.t * (core.option.Option.t usize.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IterMut_t.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IterMut_t.

Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IterMut_t.
Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IterMut_t.
  Definition Self : Set := serde_json.map.IterMut.t.
  
  (*
              fn next_back(&mut self) -> Option<Self::Item> {
                  self.iter.next_back()
              }
  *)
  Definition next_back (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_back :
    Notations.DoubleColon Self "next_back" := {
    Notations.double_colon := next_back;
  }.
  
  Global Instance ℐ :
    core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
    core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
    core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
  }.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IterMut_t.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IterMut_t.

Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IterMut_t.
Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IterMut_t.
  Definition Self : Set := serde_json.map.IterMut.t.
  
  (*
              fn len(&self) -> usize {
                  self.iter.len()
              }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  Global Instance ℐ :
    core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
    core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
    core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
  }.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IterMut_t.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IterMut_t.

Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IterMut_t.
Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IterMut_t.
  Definition Self : Set := serde_json.map.IterMut.t.
  
  Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
  }.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IterMut_t.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IterMut_t.

Module  Impl_core_iter_traits_collect_IntoIterator_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
Section Impl_core_iter_traits_collect_IntoIterator_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
  Definition Self : Set :=
    serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t.
  
  (*
      type Item = (String, Value);
  *)
  Definition Item : Set := alloc.string.String.t * serde_json.value.Value.t.
  
  (*
      type IntoIter = IntoIter;
  *)
  Definition IntoIter : Set := serde_json.map.IntoIter.t.
  
  (*
      fn into_iter(self) -> Self::IntoIter {
          IntoIter {
              iter: self.map.into_iter(),
          }
      }
  *)
  Definition into_iter (self : Self) : M IntoIter :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_iter :
    Notations.DoubleColon Self "into_iter" := {
    Notations.double_colon := into_iter;
  }.
  
  Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
    core.iter.traits.collect.IntoIterator.Item := Item;
    core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
    core.iter.traits.collect.IntoIterator.into_iter := into_iter;
  }.
End Impl_core_iter_traits_collect_IntoIterator_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.
End Impl_core_iter_traits_collect_IntoIterator_for_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t.

Module  IntoIter.
Section IntoIter.
  Record t : Set := {
    iter : ltac:(serde_json.map.IntoIterImpl);
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
End IntoIter.
End IntoIter.

Ltac IntoIterImpl :=
  exact
    (alloc.collections.btree.map.IntoIter.t
      alloc.string.String.t
      serde_json.value.Value.t
      alloc.collections.btree.map.IntoIter.Default.A).

Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IntoIter_t.
Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IntoIter_t.
  Definition Self : Set := serde_json.map.IntoIter.t.
  
  (*
              type Item = $item;
  *)
  Definition Item : Set := alloc.string.String.t * serde_json.value.Value.t.
  
  (*
              fn next(&mut self) -> Option<Self::Item> {
                  self.iter.next()
              }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
              fn size_hint(&self) -> (usize, Option<usize>) {
                  self.iter.size_hint()
              }
  *)
  Definition size_hint
      (self : ref Self)
      : M (usize.t * (core.option.Option.t usize.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IntoIter_t.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_IntoIter_t.

Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IntoIter_t.
Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IntoIter_t.
  Definition Self : Set := serde_json.map.IntoIter.t.
  
  (*
              fn next_back(&mut self) -> Option<Self::Item> {
                  self.iter.next_back()
              }
  *)
  Definition next_back (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_back :
    Notations.DoubleColon Self "next_back" := {
    Notations.double_colon := next_back;
  }.
  
  Global Instance ℐ :
    core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
    core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
    core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
  }.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IntoIter_t.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_IntoIter_t.

Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IntoIter_t.
Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IntoIter_t.
  Definition Self : Set := serde_json.map.IntoIter.t.
  
  (*
              fn len(&self) -> usize {
                  self.iter.len()
              }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  Global Instance ℐ :
    core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
    core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
    core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
  }.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IntoIter_t.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_IntoIter_t.

Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IntoIter_t.
Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IntoIter_t.
  Definition Self : Set := serde_json.map.IntoIter.t.
  
  Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
  }.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IntoIter_t.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_IntoIter_t.

Module  Keys.
Section Keys.
  Record t : Set := {
    iter : ltac:(serde_json.map.KeysImpl);
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
End Keys.
End Keys.

Ltac KeysImpl :=
  exact
    (alloc.collections.btree.map.Keys.t
      alloc.string.String.t
      serde_json.value.Value.t).

Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Keys_t.
Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Keys_t.
  Definition Self : Set := serde_json.map.Keys.t.
  
  (*
              type Item = $item;
  *)
  Definition Item : Set := ref alloc.string.String.t.
  
  (*
              fn next(&mut self) -> Option<Self::Item> {
                  self.iter.next()
              }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
              fn size_hint(&self) -> (usize, Option<usize>) {
                  self.iter.size_hint()
              }
  *)
  Definition size_hint
      (self : ref Self)
      : M (usize.t * (core.option.Option.t usize.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Keys_t.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Keys_t.

Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Keys_t.
Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Keys_t.
  Definition Self : Set := serde_json.map.Keys.t.
  
  (*
              fn next_back(&mut self) -> Option<Self::Item> {
                  self.iter.next_back()
              }
  *)
  Definition next_back (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_back :
    Notations.DoubleColon Self "next_back" := {
    Notations.double_colon := next_back;
  }.
  
  Global Instance ℐ :
    core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
    core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
    core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
  }.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Keys_t.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Keys_t.

Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Keys_t.
Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Keys_t.
  Definition Self : Set := serde_json.map.Keys.t.
  
  (*
              fn len(&self) -> usize {
                  self.iter.len()
              }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  Global Instance ℐ :
    core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
    core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
    core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
  }.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Keys_t.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Keys_t.

Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Keys_t.
Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Keys_t.
  Definition Self : Set := serde_json.map.Keys.t.
  
  Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
  }.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Keys_t.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Keys_t.

Module  Values.
Section Values.
  Record t : Set := {
    iter : ltac:(serde_json.map.ValuesImpl);
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
End Values.
End Values.

Ltac ValuesImpl :=
  exact
    (alloc.collections.btree.map.Values.t
      alloc.string.String.t
      serde_json.value.Value.t).

Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Values_t.
Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Values_t.
  Definition Self : Set := serde_json.map.Values.t.
  
  (*
              type Item = $item;
  *)
  Definition Item : Set := ref serde_json.value.Value.t.
  
  (*
              fn next(&mut self) -> Option<Self::Item> {
                  self.iter.next()
              }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
              fn size_hint(&self) -> (usize, Option<usize>) {
                  self.iter.size_hint()
              }
  *)
  Definition size_hint
      (self : ref Self)
      : M (usize.t * (core.option.Option.t usize.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Values_t.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_Values_t.

Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Values_t.
Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Values_t.
  Definition Self : Set := serde_json.map.Values.t.
  
  (*
              fn next_back(&mut self) -> Option<Self::Item> {
                  self.iter.next_back()
              }
  *)
  Definition next_back (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_back :
    Notations.DoubleColon Self "next_back" := {
    Notations.double_colon := next_back;
  }.
  
  Global Instance ℐ :
    core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
    core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
    core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
  }.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Values_t.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_Values_t.

Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Values_t.
Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Values_t.
  Definition Self : Set := serde_json.map.Values.t.
  
  (*
              fn len(&self) -> usize {
                  self.iter.len()
              }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  Global Instance ℐ :
    core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
    core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
    core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
  }.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Values_t.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_Values_t.

Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Values_t.
Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Values_t.
  Definition Self : Set := serde_json.map.Values.t.
  
  Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
  }.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Values_t.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_Values_t.

Module  ValuesMut.
Section ValuesMut.
  Record t : Set := {
    iter : ltac:(serde_json.map.ValuesMutImpl);
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
End ValuesMut.
End ValuesMut.

Ltac ValuesMutImpl :=
  exact
    (alloc.collections.btree.map.ValuesMut.t
      alloc.string.String.t
      serde_json.value.Value.t).

Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_ValuesMut_t.
Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_ValuesMut_t.
  Definition Self : Set := serde_json.map.ValuesMut.t.
  
  (*
              type Item = $item;
  *)
  Definition Item : Set := mut_ref serde_json.value.Value.t.
  
  (*
              fn next(&mut self) -> Option<Self::Item> {
                  self.iter.next()
              }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
              fn size_hint(&self) -> (usize, Option<usize>) {
                  self.iter.size_hint()
              }
  *)
  Definition size_hint
      (self : ref Self)
      : M (usize.t * (core.option.Option.t usize.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_ValuesMut_t.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_map_ValuesMut_t.

Module  Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_ValuesMut_t.
Section Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_ValuesMut_t.
  Definition Self : Set := serde_json.map.ValuesMut.t.
  
  (*
              fn next_back(&mut self) -> Option<Self::Item> {
                  self.iter.next_back()
              }
  *)
  Definition next_back (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_back :
    Notations.DoubleColon Self "next_back" := {
    Notations.double_colon := next_back;
  }.
  
  Global Instance ℐ :
    core.iter.traits.double_ended.DoubleEndedIterator.Required.Trait Self := {
    core.iter.traits.double_ended.DoubleEndedIterator.next_back := next_back;
    core.iter.traits.double_ended.DoubleEndedIterator.advance_back_by :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.nth_back :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.try_rfold :=
      Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfold := Datatypes.None;
    core.iter.traits.double_ended.DoubleEndedIterator.rfind := Datatypes.None;
  }.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_ValuesMut_t.
End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_serde_json_map_ValuesMut_t.

Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_ValuesMut_t.
Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_ValuesMut_t.
  Definition Self : Set := serde_json.map.ValuesMut.t.
  
  (*
              fn len(&self) -> usize {
                  self.iter.len()
              }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  Global Instance ℐ :
    core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
    core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.Some len;
    core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
  }.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_ValuesMut_t.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_serde_json_map_ValuesMut_t.

Module  Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_ValuesMut_t.
Section Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_ValuesMut_t.
  Definition Self : Set := serde_json.map.ValuesMut.t.
  
  Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
  }.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_ValuesMut_t.
End Impl_core_iter_traits_marker_FusedIterator_for_serde_json_map_ValuesMut_t.

Module ser.
  Module  Serializer.
  Section Serializer.
    Context (W F : Set).
    
    Record t : Set := {
      writer : W;
      formatter : F;
    }.
    
    Definition Get_writer :=
      Ref.map
        (fun α => Some α.(writer))
        (fun β α => Some (α <| writer := β |>)).
    Definition Get_formatter :=
      Ref.map
        (fun α => Some α.(formatter))
        (fun β α => Some (α <| formatter := β |>)).
    Module Default.
      Definition F := serde_json.ser.CompactFormatter.t.
    End Default.
  End Serializer.
  End Serializer.
  
  Module  Impl_serde_json_ser_Serializer_t_W_serde_json_ser_Serializer_Default_F.
  Section Impl_serde_json_ser_Serializer_t_W_serde_json_ser_Serializer_Default_F.
    Context {W : Set}.
    
    Definition Self : Set :=
      serde_json.ser.Serializer.t W serde_json.ser.Serializer.Default.F.
    
    (*
        pub fn new(writer: W) -> Self {
            Serializer::with_formatter(writer, CompactFormatter)
        }
    *)
    Definition new (writer : W) : M Self :=
      let* writer := M.alloc writer in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_ser_Serializer_t_W_serde_json_ser_Serializer_Default_F.
  End Impl_serde_json_ser_Serializer_t_W_serde_json_ser_Serializer_Default_F.
  
  Module  Impl_serde_json_ser_Serializer_t_W_serde_json_ser_PrettyFormatter_t.
  Section Impl_serde_json_ser_Serializer_t_W_serde_json_ser_PrettyFormatter_t.
    Context {W : Set}.
    
    Definition Self : Set :=
      serde_json.ser.Serializer.t W serde_json.ser.PrettyFormatter.t.
    
    (*
        pub fn pretty(writer: W) -> Self {
            Serializer::with_formatter(writer, PrettyFormatter::new())
        }
    *)
    Definition pretty (writer : W) : M Self :=
      let* writer := M.alloc writer in
      M.read foo.
    
    Global Instance AssociatedFunction_pretty :
      Notations.DoubleColon Self "pretty" := {
      Notations.double_colon := pretty;
    }.
  End Impl_serde_json_ser_Serializer_t_W_serde_json_ser_PrettyFormatter_t.
  End Impl_serde_json_ser_Serializer_t_W_serde_json_ser_PrettyFormatter_t.
  
  Module  Impl_serde_json_ser_Serializer_t_W_F.
  Section Impl_serde_json_ser_Serializer_t_W_F.
    Context {W F : Set}.
    
    Definition Self : Set := serde_json.ser.Serializer.t W F.
    
    (*
        pub fn with_formatter(writer: W, formatter: F) -> Self {
            Serializer { writer, formatter }
        }
    *)
    Definition with_formatter (writer : W) (formatter : F) : M Self :=
      let* writer := M.alloc writer in
      let* formatter := M.alloc formatter in
      M.read foo.
    
    Global Instance AssociatedFunction_with_formatter :
      Notations.DoubleColon Self "with_formatter" := {
      Notations.double_colon := with_formatter;
    }.
    
    (*
        pub fn into_inner(self) -> W {
            self.writer
        }
    *)
    Definition into_inner (self : Self) : M W :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_inner :
      Notations.DoubleColon Self "into_inner" := {
      Notations.double_colon := into_inner;
    }.
  End Impl_serde_json_ser_Serializer_t_W_F.
  End Impl_serde_json_ser_Serializer_t_W_F.
  
  Module  Impl_serde_ser_Serializer_for_mut_ref_serde_json_ser_Serializer_t_W_F.
  Section Impl_serde_ser_Serializer_for_mut_ref_serde_json_ser_Serializer_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := mut_ref (serde_json.ser.Serializer.t W F).
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        type SerializeSeq = Compound<'a, W, F>;
    *)
    Definition SerializeSeq : Set := serde_json.ser.Compound.t W F.
    
    (*
        type SerializeTuple = Compound<'a, W, F>;
    *)
    Definition SerializeTuple : Set := serde_json.ser.Compound.t W F.
    
    (*
        type SerializeTupleStruct = Compound<'a, W, F>;
    *)
    Definition SerializeTupleStruct : Set := serde_json.ser.Compound.t W F.
    
    (*
        type SerializeTupleVariant = Compound<'a, W, F>;
    *)
    Definition SerializeTupleVariant : Set := serde_json.ser.Compound.t W F.
    
    (*
        type SerializeMap = Compound<'a, W, F>;
    *)
    Definition SerializeMap : Set := serde_json.ser.Compound.t W F.
    
    (*
        type SerializeStruct = Compound<'a, W, F>;
    *)
    Definition SerializeStruct : Set := serde_json.ser.Compound.t W F.
    
    (*
        type SerializeStructVariant = Compound<'a, W, F>;
    *)
    Definition SerializeStructVariant : Set := serde_json.ser.Compound.t W F.
    
    (*
        fn serialize_bool(self, value: bool) -> Result<()> {
            self.formatter
                .write_bool(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_bool
        (self : Self)
        (value : bool.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_bool :
      Notations.DoubleColon Self "serialize_bool" := {
      Notations.double_colon := serialize_bool;
    }.
    
    (*
        fn serialize_i8(self, value: i8) -> Result<()> {
            self.formatter
                .write_i8(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i8
        (self : Self)
        (value : i8.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i8 :
      Notations.DoubleColon Self "serialize_i8" := {
      Notations.double_colon := serialize_i8;
    }.
    
    (*
        fn serialize_i16(self, value: i16) -> Result<()> {
            self.formatter
                .write_i16(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i16
        (self : Self)
        (value : i16.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i16 :
      Notations.DoubleColon Self "serialize_i16" := {
      Notations.double_colon := serialize_i16;
    }.
    
    (*
        fn serialize_i32(self, value: i32) -> Result<()> {
            self.formatter
                .write_i32(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i32
        (self : Self)
        (value : i32.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i32 :
      Notations.DoubleColon Self "serialize_i32" := {
      Notations.double_colon := serialize_i32;
    }.
    
    (*
        fn serialize_i64(self, value: i64) -> Result<()> {
            self.formatter
                .write_i64(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i64
        (self : Self)
        (value : i64.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i64 :
      Notations.DoubleColon Self "serialize_i64" := {
      Notations.double_colon := serialize_i64;
    }.
    
    (*
        fn serialize_i128(self, value: i128) -> Result<()> {
            self.formatter
                .write_i128(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i128
        (self : Self)
        (value : i128.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i128 :
      Notations.DoubleColon Self "serialize_i128" := {
      Notations.double_colon := serialize_i128;
    }.
    
    (*
        fn serialize_u8(self, value: u8) -> Result<()> {
            self.formatter
                .write_u8(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u8
        (self : Self)
        (value : u8.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u8 :
      Notations.DoubleColon Self "serialize_u8" := {
      Notations.double_colon := serialize_u8;
    }.
    
    (*
        fn serialize_u16(self, value: u16) -> Result<()> {
            self.formatter
                .write_u16(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u16
        (self : Self)
        (value : u16.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u16 :
      Notations.DoubleColon Self "serialize_u16" := {
      Notations.double_colon := serialize_u16;
    }.
    
    (*
        fn serialize_u32(self, value: u32) -> Result<()> {
            self.formatter
                .write_u32(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u32
        (self : Self)
        (value : u32.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u32 :
      Notations.DoubleColon Self "serialize_u32" := {
      Notations.double_colon := serialize_u32;
    }.
    
    (*
        fn serialize_u64(self, value: u64) -> Result<()> {
            self.formatter
                .write_u64(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u64
        (self : Self)
        (value : u64.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u64 :
      Notations.DoubleColon Self "serialize_u64" := {
      Notations.double_colon := serialize_u64;
    }.
    
    (*
        fn serialize_u128(self, value: u128) -> Result<()> {
            self.formatter
                .write_u128(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u128
        (self : Self)
        (value : u128.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u128 :
      Notations.DoubleColon Self "serialize_u128" := {
      Notations.double_colon := serialize_u128;
    }.
    
    (*
        fn serialize_f32(self, value: f32) -> Result<()> {
            match value.classify() {
                FpCategory::Nan | FpCategory::Infinite => self
                    .formatter
                    .write_null(&mut self.writer)
                    .map_err(Error::io),
                _ => self
                    .formatter
                    .write_f32(&mut self.writer, value)
                    .map_err(Error::io),
            }
        }
    *)
    Definition serialize_f32
        (self : Self)
        (value : f32.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_f32 :
      Notations.DoubleColon Self "serialize_f32" := {
      Notations.double_colon := serialize_f32;
    }.
    
    (*
        fn serialize_f64(self, value: f64) -> Result<()> {
            match value.classify() {
                FpCategory::Nan | FpCategory::Infinite => self
                    .formatter
                    .write_null(&mut self.writer)
                    .map_err(Error::io),
                _ => self
                    .formatter
                    .write_f64(&mut self.writer, value)
                    .map_err(Error::io),
            }
        }
    *)
    Definition serialize_f64
        (self : Self)
        (value : f64.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_f64 :
      Notations.DoubleColon Self "serialize_f64" := {
      Notations.double_colon := serialize_f64;
    }.
    
    (*
        fn serialize_char(self, value: char) -> Result<()> {
            // A char encoded as UTF-8 takes 4 bytes at most.
            let mut buf = [0; 4];
            self.serialize_str(value.encode_utf8(&mut buf))
        }
    *)
    Definition serialize_char
        (self : Self)
        (value : char.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_char :
      Notations.DoubleColon Self "serialize_char" := {
      Notations.double_colon := serialize_char;
    }.
    
    (*
        fn serialize_str(self, value: &str) -> Result<()> {
            format_escaped_str(&mut self.writer, &mut self.formatter, value).map_err(Error::io)
        }
    *)
    Definition serialize_str
        (self : Self)
        (value : ref str.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_str :
      Notations.DoubleColon Self "serialize_str" := {
      Notations.double_colon := serialize_str;
    }.
    
    (*
        fn serialize_bytes(self, value: &[u8]) -> Result<()> {
            self.formatter
                .write_byte_array(&mut self.writer, value)
                .map_err(Error::io)
        }
    *)
    Definition serialize_bytes
        (self : Self)
        (value : ref (slice u8.t))
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_bytes :
      Notations.DoubleColon Self "serialize_bytes" := {
      Notations.double_colon := serialize_bytes;
    }.
    
    (*
        fn serialize_unit(self) -> Result<()> {
            self.formatter
                .write_null(&mut self.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_unit
        (self : Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit :
      Notations.DoubleColon Self "serialize_unit" := {
      Notations.double_colon := serialize_unit;
    }.
    
    (*
        fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {
            self.serialize_unit()
        }
    *)
    Definition serialize_unit_struct
        (self : Self)
        (_name : ref str.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit_struct :
      Notations.DoubleColon Self "serialize_unit_struct" := {
      Notations.double_colon := serialize_unit_struct;
    }.
    
    (*
        fn serialize_unit_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
        ) -> Result<()> {
            self.serialize_str(variant)
        }
    *)
    Definition serialize_unit_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit_variant :
      Notations.DoubleColon Self "serialize_unit_variant" := {
      Notations.double_colon := serialize_unit_variant;
    }.
    
    (*
        fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            value.serialize(self)
        }
    *)
    Definition serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_name : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_newtype_struct" := {
      Notations.double_colon := serialize_newtype_struct (T := T);
    }.
    
    (*
        fn serialize_newtype_variant<T>(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
            value: &T,
        ) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            tri!(self
                .formatter
                .begin_object(&mut self.writer)
                .map_err(Error::io));
            tri!(self
                .formatter
                .begin_object_key(&mut self.writer, true)
                .map_err(Error::io));
            tri!(self.serialize_str(variant));
            tri!(self
                .formatter
                .end_object_key(&mut self.writer)
                .map_err(Error::io));
            tri!(self
                .formatter
                .begin_object_value(&mut self.writer)
                .map_err(Error::io));
            tri!(value.serialize(&mut *self));
            tri!(self
                .formatter
                .end_object_value(&mut self.writer)
                .map_err(Error::io));
            self.formatter
                .end_object(&mut self.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_newtype_variant" := {
      Notations.double_colon := serialize_newtype_variant (T := T);
    }.
    
    (*
        fn serialize_none(self) -> Result<()> {
            self.serialize_unit()
        }
    *)
    Definition serialize_none
        (self : Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_none :
      Notations.DoubleColon Self "serialize_none" := {
      Notations.double_colon := serialize_none;
    }.
    
    (*
        fn serialize_some<T>(self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            value.serialize(self)
        }
    *)
    Definition serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_some" := {
      Notations.double_colon := serialize_some (T := T);
    }.
    
    (*
        fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {
            tri!(self
                .formatter
                .begin_array(&mut self.writer)
                .map_err(Error::io));
            if len == Some(0) {
                tri!(self
                    .formatter
                    .end_array(&mut self.writer)
                    .map_err(Error::io));
                Ok(Compound::Map {
                    ser: self,
                    state: State::Empty,
                })
            } else {
                Ok(Compound::Map {
                    ser: self,
                    state: State::First,
                })
            }
        }
    *)
    Definition serialize_seq
        (self : Self)
        (len : core.option.Option.t usize.t)
        : M ltac:(serde_json.error.Result SerializeSeq) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_seq :
      Notations.DoubleColon Self "serialize_seq" := {
      Notations.double_colon := serialize_seq;
    }.
    
    (*
        fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {
            self.serialize_seq(Some(len))
        }
    *)
    Definition serialize_tuple
        (self : Self)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTuple) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple :
      Notations.DoubleColon Self "serialize_tuple" := {
      Notations.double_colon := serialize_tuple;
    }.
    
    (*
        fn serialize_tuple_struct(
            self,
            _name: &'static str,
            len: usize,
        ) -> Result<Self::SerializeTupleStruct> {
            self.serialize_seq(Some(len))
        }
    *)
    Definition serialize_tuple_struct
        (self : Self)
        (_name : ref str.t)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple_struct :
      Notations.DoubleColon Self "serialize_tuple_struct" := {
      Notations.double_colon := serialize_tuple_struct;
    }.
    
    (*
        fn serialize_tuple_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
            len: usize,
        ) -> Result<Self::SerializeTupleVariant> {
            tri!(self
                .formatter
                .begin_object(&mut self.writer)
                .map_err(Error::io));
            tri!(self
                .formatter
                .begin_object_key(&mut self.writer, true)
                .map_err(Error::io));
            tri!(self.serialize_str(variant));
            tri!(self
                .formatter
                .end_object_key(&mut self.writer)
                .map_err(Error::io));
            tri!(self
                .formatter
                .begin_object_value(&mut self.writer)
                .map_err(Error::io));
            self.serialize_seq(Some(len))
        }
    *)
    Definition serialize_tuple_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple_variant :
      Notations.DoubleColon Self "serialize_tuple_variant" := {
      Notations.double_colon := serialize_tuple_variant;
    }.
    
    (*
        fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap> {
            tri!(self
                .formatter
                .begin_object(&mut self.writer)
                .map_err(Error::io));
            if len == Some(0) {
                tri!(self
                    .formatter
                    .end_object(&mut self.writer)
                    .map_err(Error::io));
                Ok(Compound::Map {
                    ser: self,
                    state: State::Empty,
                })
            } else {
                Ok(Compound::Map {
                    ser: self,
                    state: State::First,
                })
            }
        }
    *)
    Definition serialize_map
        (self : Self)
        (len : core.option.Option.t usize.t)
        : M ltac:(serde_json.error.Result SerializeMap) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_map :
      Notations.DoubleColon Self "serialize_map" := {
      Notations.double_colon := serialize_map;
    }.
    
    (*
        fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct> {
            match name {
                #[cfg(feature = "arbitrary_precision")]
                crate::number::TOKEN => Ok(Compound::Number { ser: self }),
                #[cfg(feature = "raw_value")]
                crate::raw::TOKEN => Ok(Compound::RawValue { ser: self }),
                _ => self.serialize_map(Some(len)),
            }
        }
    *)
    Definition serialize_struct
        (self : Self)
        (name : ref str.t)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeStruct) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_struct :
      Notations.DoubleColon Self "serialize_struct" := {
      Notations.double_colon := serialize_struct;
    }.
    
    (*
        fn serialize_struct_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
            len: usize,
        ) -> Result<Self::SerializeStructVariant> {
            tri!(self
                .formatter
                .begin_object(&mut self.writer)
                .map_err(Error::io));
            tri!(self
                .formatter
                .begin_object_key(&mut self.writer, true)
                .map_err(Error::io));
            tri!(self.serialize_str(variant));
            tri!(self
                .formatter
                .end_object_key(&mut self.writer)
                .map_err(Error::io));
            tri!(self
                .formatter
                .begin_object_value(&mut self.writer)
                .map_err(Error::io));
            self.serialize_map(Some(len))
        }
    *)
    Definition serialize_struct_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeStructVariant) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_struct_variant :
      Notations.DoubleColon Self "serialize_struct_variant" := {
      Notations.double_colon := serialize_struct_variant;
    }.
    
    (*
        fn collect_str<T>(self, value: &T) -> Result<()>
        where
            T: ?Sized + Display,
        {
            use self::fmt::Write;
    
            struct Adapter<'ser, W: 'ser, F: 'ser> {
                writer: &'ser mut W,
                formatter: &'ser mut F,
                error: Option<io::Error>,
            }
    
            impl<'ser, W, F> Write for Adapter<'ser, W, F>
            where
                W: io::Write,
                F: Formatter,
            {
                fn write_str(&mut self, s: &str) -> fmt::Result {
                    debug_assert!(self.error.is_none());
                    match format_escaped_str_contents(self.writer, self.formatter, s) {
                        Ok(()) => Ok(()),
                        Err(err) => {
                            self.error = Some(err);
                            Err(fmt::Error)
                        }
                    }
                }
            }
    
            tri!(self
                .formatter
                .begin_string(&mut self.writer)
                .map_err(Error::io));
            let mut adapter = Adapter {
                writer: &mut self.writer,
                formatter: &mut self.formatter,
                error: None,
            };
            match write!(adapter, "{}", value) {
                Ok(()) => debug_assert!(adapter.error.is_none()),
                Err(fmt::Error) => {
                    return Err(Error::io(adapter.error.expect("there should be an error")));
                }
            }
            self.formatter
                .end_string(&mut self.writer)
                .map_err(Error::io)
        }
    *)
    Definition collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T}
        (self : Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :
      Notations.DoubleColon Self "collect_str" := {
      Notations.double_colon := collect_str (T := T);
    }.
    
    Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
      serde.ser.Serializer.Ok := Ok;
      serde.ser.Serializer.Error := Error;
      serde.ser.Serializer.SerializeSeq := SerializeSeq;
      serde.ser.Serializer.SerializeTuple := SerializeTuple;
      serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
      serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
      serde.ser.Serializer.SerializeMap := SerializeMap;
      serde.ser.Serializer.SerializeStruct := SerializeStruct;
      serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
      serde.ser.Serializer.serialize_bool := serialize_bool;
      serde.ser.Serializer.serialize_i8 := serialize_i8;
      serde.ser.Serializer.serialize_i16 := serialize_i16;
      serde.ser.Serializer.serialize_i32 := serialize_i32;
      serde.ser.Serializer.serialize_i64 := serialize_i64;
      serde.ser.Serializer.serialize_i128 := Datatypes.Some serialize_i128;
      serde.ser.Serializer.serialize_u8 := serialize_u8;
      serde.ser.Serializer.serialize_u16 := serialize_u16;
      serde.ser.Serializer.serialize_u32 := serialize_u32;
      serde.ser.Serializer.serialize_u64 := serialize_u64;
      serde.ser.Serializer.serialize_u128 := Datatypes.Some serialize_u128;
      serde.ser.Serializer.serialize_f32 := serialize_f32;
      serde.ser.Serializer.serialize_f64 := serialize_f64;
      serde.ser.Serializer.serialize_char := serialize_char;
      serde.ser.Serializer.serialize_str := serialize_str;
      serde.ser.Serializer.serialize_bytes := serialize_bytes;
      serde.ser.Serializer.serialize_unit := serialize_unit;
      serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
      serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
      serde.ser.Serializer.serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_newtype_struct (T := T);
      serde.ser.Serializer.serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_newtype_variant (T := T);
      serde.ser.Serializer.serialize_none := serialize_none;
      serde.ser.Serializer.serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_some (T := T);
      serde.ser.Serializer.serialize_seq := serialize_seq;
      serde.ser.Serializer.serialize_tuple := serialize_tuple;
      serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
      serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
      serde.ser.Serializer.serialize_map := serialize_map;
      serde.ser.Serializer.serialize_struct := serialize_struct;
      serde.ser.Serializer.serialize_struct_variant := serialize_struct_variant;
      serde.ser.Serializer.collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :=
        Datatypes.Some (collect_str (T := T));
      serde.ser.Serializer.collect_seq := Datatypes.None;
      serde.ser.Serializer.collect_map := Datatypes.None;
      serde.ser.Serializer.is_human_readable := Datatypes.None;
    }.
  End Impl_serde_ser_Serializer_for_mut_ref_serde_json_ser_Serializer_t_W_F.
  End Impl_serde_ser_Serializer_for_mut_ref_serde_json_ser_Serializer_t_W_F.
  
  Module State.
    Inductive t : Set :=
    | Empty
    | First
    | Rest.
  End State.
  
  Module  Impl_core_marker_StructuralEq_for_serde_json_ser_State_t.
  Section Impl_core_marker_StructuralEq_for_serde_json_ser_State_t.
    Definition Self : Set := serde_json.ser.State.t.
    
    Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralEq_for_serde_json_ser_State_t.
  End Impl_core_marker_StructuralEq_for_serde_json_ser_State_t.
  
  Module  Impl_core_cmp_Eq_for_serde_json_ser_State_t.
  Section Impl_core_cmp_Eq_for_serde_json_ser_State_t.
    Definition Self : Set := serde_json.ser.State.t.
    
    (*
    Eq
    *)
    Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_assert_receiver_is_total_eq :
      Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
      Notations.double_colon := assert_receiver_is_total_eq;
    }.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq :=
        Datatypes.Some assert_receiver_is_total_eq;
    }.
  End Impl_core_cmp_Eq_for_serde_json_ser_State_t.
  End Impl_core_cmp_Eq_for_serde_json_ser_State_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_serde_json_ser_State_t.
  Section Impl_core_marker_StructuralPartialEq_for_serde_json_ser_State_t.
    Definition Self : Set := serde_json.ser.State.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_serde_json_ser_State_t.
  End Impl_core_marker_StructuralPartialEq_for_serde_json_ser_State_t.
  
  Module  Impl_core_cmp_PartialEq_for_serde_json_ser_State_t.
  Section Impl_core_cmp_PartialEq_for_serde_json_ser_State_t.
    Definition Self : Set := serde_json.ser.State.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.ser.State.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_serde_json_ser_State_t.
  End Impl_core_cmp_PartialEq_for_serde_json_ser_State_t.
  
  Module Compound.
    Module Map.
      Record t : Set := {
        ser : mut_ref (serde_json.ser.Serializer.t W F);
        state : serde_json.ser.State.t;
      }.
    End Map.
    
    Inductive t (W : Set) (F : Set) : Set :=
    | Map (_ : Map.t).
    
    Definition Get_Map_ser :=
      Ref.map
        (fun α => match α with | Map α => Some α.(Map.ser) end)
        (fun β α =>
          match α with | Map α => Some (Map (α <| Map.ser := β |>)) end).
    
    Definition Get_Map_state :=
      Ref.map
        (fun α => match α with | Map α => Some α.(Map.state) end)
        (fun β α =>
          match α with | Map α => Some (Map (α <| Map.state := β |>)) end).
  End Compound.
  
  Module  Impl_serde_ser_SerializeSeq_for_serde_json_ser_Compound_t_W_F.
  Section Impl_serde_ser_SerializeSeq_for_serde_json_ser_Compound_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := serde_json.ser.Compound.t W F.
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_element<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            match self {
                Compound::Map { ser, state } => {
                    tri!(ser
                        .formatter
                        .begin_array_value(&mut ser.writer, *state == State::First)
                        .map_err(Error::io));
                    *state = State::Rest;
                    tri!(value.serialize(&mut **ser));
                    ser.formatter
                        .end_array_value(&mut ser.writer)
                        .map_err(Error::io)
                }
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_element" := {
      Notations.double_colon := serialize_element (T := T);
    }.
    
    (*
        fn end(self) -> Result<()> {
            match self {
                Compound::Map { ser, state } => match state {
                    State::Empty => Ok(()),
                    _ => ser.formatter.end_array(&mut ser.writer).map_err(Error::io),
                },
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeSeq.Trait Self := {
      serde.ser.SerializeSeq.Ok := Ok;
      serde.ser.SerializeSeq.Error := Error;
      serde.ser.SerializeSeq.serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_element (T := T);
      serde.ser.SerializeSeq.end_ := end_;
    }.
  End Impl_serde_ser_SerializeSeq_for_serde_json_ser_Compound_t_W_F.
  End Impl_serde_ser_SerializeSeq_for_serde_json_ser_Compound_t_W_F.
  
  Module  Impl_serde_ser_SerializeTuple_for_serde_json_ser_Compound_t_W_F.
  Section Impl_serde_ser_SerializeTuple_for_serde_json_ser_Compound_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := serde_json.ser.Compound.t W F.
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_element<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            ser::SerializeSeq::serialize_element(self, value)
        }
    *)
    Definition serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_element" := {
      Notations.double_colon := serialize_element (T := T);
    }.
    
    (*
        fn end(self) -> Result<()> {
            ser::SerializeSeq::end(self)
        }
    *)
    Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeTuple.Trait Self := {
      serde.ser.SerializeTuple.Ok := Ok;
      serde.ser.SerializeTuple.Error := Error;
      serde.ser.SerializeTuple.serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_element (T := T);
      serde.ser.SerializeTuple.end_ := end_;
    }.
  End Impl_serde_ser_SerializeTuple_for_serde_json_ser_Compound_t_W_F.
  End Impl_serde_ser_SerializeTuple_for_serde_json_ser_Compound_t_W_F.
  
  Module  Impl_serde_ser_SerializeTupleStruct_for_serde_json_ser_Compound_t_W_F.
  Section Impl_serde_ser_SerializeTupleStruct_for_serde_json_ser_Compound_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := serde_json.ser.Compound.t W F.
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_field<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            ser::SerializeSeq::serialize_element(self, value)
        }
    *)
    Definition serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_field" := {
      Notations.double_colon := serialize_field (T := T);
    }.
    
    (*
        fn end(self) -> Result<()> {
            ser::SerializeSeq::end(self)
        }
    *)
    Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeTupleStruct.Trait Self := {
      serde.ser.SerializeTupleStruct.Ok := Ok;
      serde.ser.SerializeTupleStruct.Error := Error;
      serde.ser.SerializeTupleStruct.serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_field (T := T);
      serde.ser.SerializeTupleStruct.end_ := end_;
    }.
  End Impl_serde_ser_SerializeTupleStruct_for_serde_json_ser_Compound_t_W_F.
  End Impl_serde_ser_SerializeTupleStruct_for_serde_json_ser_Compound_t_W_F.
  
  Module  Impl_serde_ser_SerializeTupleVariant_for_serde_json_ser_Compound_t_W_F.
  Section Impl_serde_ser_SerializeTupleVariant_for_serde_json_ser_Compound_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := serde_json.ser.Compound.t W F.
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_field<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            ser::SerializeSeq::serialize_element(self, value)
        }
    *)
    Definition serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_field" := {
      Notations.double_colon := serialize_field (T := T);
    }.
    
    (*
        fn end(self) -> Result<()> {
            match self {
                Compound::Map { ser, state } => {
                    match state {
                        State::Empty => {}
                        _ => tri!(ser.formatter.end_array(&mut ser.writer).map_err(Error::io)),
                    }
                    tri!(ser
                        .formatter
                        .end_object_value(&mut ser.writer)
                        .map_err(Error::io));
                    ser.formatter.end_object(&mut ser.writer).map_err(Error::io)
                }
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeTupleVariant.Trait Self := {
      serde.ser.SerializeTupleVariant.Ok := Ok;
      serde.ser.SerializeTupleVariant.Error := Error;
      serde.ser.SerializeTupleVariant.serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_field (T := T);
      serde.ser.SerializeTupleVariant.end_ := end_;
    }.
  End Impl_serde_ser_SerializeTupleVariant_for_serde_json_ser_Compound_t_W_F.
  End Impl_serde_ser_SerializeTupleVariant_for_serde_json_ser_Compound_t_W_F.
  
  Module  Impl_serde_ser_SerializeMap_for_serde_json_ser_Compound_t_W_F.
  Section Impl_serde_ser_SerializeMap_for_serde_json_ser_Compound_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := serde_json.ser.Compound.t W F.
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_key<T>(&mut self, key: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            match self {
                Compound::Map { ser, state } => {
                    tri!(ser
                        .formatter
                        .begin_object_key(&mut ser.writer, *state == State::First)
                        .map_err(Error::io));
                    *state = State::Rest;
    
                    tri!(key.serialize(MapKeySerializer { ser: *ser }));
    
                    ser.formatter
                        .end_object_key(&mut ser.writer)
                        .map_err(Error::io)
                }
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition serialize_key
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (key : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_key
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_key" := {
      Notations.double_colon := serialize_key (T := T);
    }.
    
    (*
        fn serialize_value<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            match self {
                Compound::Map { ser, .. } => {
                    tri!(ser
                        .formatter
                        .begin_object_value(&mut ser.writer)
                        .map_err(Error::io));
                    tri!(value.serialize(&mut **ser));
                    ser.formatter
                        .end_object_value(&mut ser.writer)
                        .map_err(Error::io)
                }
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition serialize_value
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_value
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_value" := {
      Notations.double_colon := serialize_value (T := T);
    }.
    
    (*
        fn end(self) -> Result<()> {
            match self {
                Compound::Map { ser, state } => match state {
                    State::Empty => Ok(()),
                    _ => ser.formatter.end_object(&mut ser.writer).map_err(Error::io),
                },
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeMap.Required.Trait Self := {
      serde.ser.SerializeMap.Ok := Ok;
      serde.ser.SerializeMap.Error := Error;
      serde.ser.SerializeMap.serialize_key
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_key (T := T);
      serde.ser.SerializeMap.serialize_value
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_value (T := T);
      serde.ser.SerializeMap.end_ := end_;
      serde.ser.SerializeMap.serialize_entry := Datatypes.None;
    }.
  End Impl_serde_ser_SerializeMap_for_serde_json_ser_Compound_t_W_F.
  End Impl_serde_ser_SerializeMap_for_serde_json_ser_Compound_t_W_F.
  
  Module  Impl_serde_ser_SerializeStruct_for_serde_json_ser_Compound_t_W_F.
  Section Impl_serde_ser_SerializeStruct_for_serde_json_ser_Compound_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := serde_json.ser.Compound.t W F.
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            match self {
                Compound::Map { .. } => ser::SerializeMap::serialize_entry(self, key, value),
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { ser, .. } => {
                    if key == crate::number::TOKEN {
                        value.serialize(NumberStrEmitter(ser))
                    } else {
                        Err(invalid_number())
                    }
                }
                #[cfg(feature = "raw_value")]
                Compound::RawValue { ser, .. } => {
                    if key == crate::raw::TOKEN {
                        value.serialize(RawValueStrEmitter(ser))
                    } else {
                        Err(invalid_raw_value())
                    }
                }
            }
        }
    *)
    Definition serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (key : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_field" := {
      Notations.double_colon := serialize_field (T := T);
    }.
    
    (*
        fn end(self) -> Result<()> {
            match self {
                Compound::Map { .. } => ser::SerializeMap::end(self),
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => Ok(()),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => Ok(()),
            }
        }
    *)
    Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeStruct.Required.Trait Self := {
      serde.ser.SerializeStruct.Ok := Ok;
      serde.ser.SerializeStruct.Error := Error;
      serde.ser.SerializeStruct.serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_field (T := T);
      serde.ser.SerializeStruct.end_ := end_;
      serde.ser.SerializeStruct.skip_field := Datatypes.None;
    }.
  End Impl_serde_ser_SerializeStruct_for_serde_json_ser_Compound_t_W_F.
  End Impl_serde_ser_SerializeStruct_for_serde_json_ser_Compound_t_W_F.
  
  Module  Impl_serde_ser_SerializeStructVariant_for_serde_json_ser_Compound_t_W_F.
  Section Impl_serde_ser_SerializeStructVariant_for_serde_json_ser_Compound_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := serde_json.ser.Compound.t W F.
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            match *self {
                Compound::Map { .. } => ser::SerializeStruct::serialize_field(self, key, value),
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (key : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_field" := {
      Notations.double_colon := serialize_field (T := T);
    }.
    
    (*
        fn end(self) -> Result<()> {
            match self {
                Compound::Map { ser, state } => {
                    match state {
                        State::Empty => {}
                        _ => tri!(ser.formatter.end_object(&mut ser.writer).map_err(Error::io)),
                    }
                    tri!(ser
                        .formatter
                        .end_object_value(&mut ser.writer)
                        .map_err(Error::io));
                    ser.formatter.end_object(&mut ser.writer).map_err(Error::io)
                }
                #[cfg(feature = "arbitrary_precision")]
                Compound::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                Compound::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ :
      serde.ser.SerializeStructVariant.Required.Trait Self := {
      serde.ser.SerializeStructVariant.Ok := Ok;
      serde.ser.SerializeStructVariant.Error := Error;
      serde.ser.SerializeStructVariant.serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_field (T := T);
      serde.ser.SerializeStructVariant.end_ := end_;
      serde.ser.SerializeStructVariant.skip_field := Datatypes.None;
    }.
  End Impl_serde_ser_SerializeStructVariant_for_serde_json_ser_Compound_t_W_F.
  End Impl_serde_ser_SerializeStructVariant_for_serde_json_ser_Compound_t_W_F.
  
  Module  MapKeySerializer.
  Section MapKeySerializer.
    Context (W F : Set).
    
    Record t : Set := {
      ser : mut_ref (serde_json.ser.Serializer.t W F);
    }.
    
    Definition Get_ser :=
      Ref.map (fun α => Some α.(ser)) (fun β α => Some (α <| ser := β |>)).
  End MapKeySerializer.
  End MapKeySerializer.
  
  (*
  fn key_must_be_a_string() -> Error {
      Error::syntax(ErrorCode::KeyMustBeAString, 0, 0)
  }
  *)
  Definition key_must_be_a_string : M serde_json.error.Error.t := M.read foo.
  
  (*
  fn float_key_must_be_finite() -> Error {
      Error::syntax(ErrorCode::FloatKeyMustBeFinite, 0, 0)
  }
  *)
  Definition float_key_must_be_finite : M serde_json.error.Error.t :=
    M.read foo.
  
  Module  Impl_serde_ser_Serializer_for_serde_json_ser_MapKeySerializer_t_W_F.
  Section Impl_serde_ser_Serializer_for_serde_json_ser_MapKeySerializer_t_W_F.
    Context {W F : Set}.
    
    Context
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}.
    
    Definition Self : Set := serde_json.ser.MapKeySerializer.t W F.
    
    (*
        type Ok = ();
    *)
    Definition Ok : Set := unit.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_str(self, value: &str) -> Result<()> {
            self.ser.serialize_str(value)
        }
    *)
    Definition serialize_str
        (self : Self)
        (value : ref str.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_str :
      Notations.DoubleColon Self "serialize_str" := {
      Notations.double_colon := serialize_str;
    }.
    
    (*
        fn serialize_unit_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
        ) -> Result<()> {
            self.ser.serialize_str(variant)
        }
    *)
    Definition serialize_unit_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit_variant :
      Notations.DoubleColon Self "serialize_unit_variant" := {
      Notations.double_colon := serialize_unit_variant;
    }.
    
    (*
        fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            value.serialize(self)
        }
    *)
    Definition serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_name : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_newtype_struct" := {
      Notations.double_colon := serialize_newtype_struct (T := T);
    }.
    
    (*
        type SerializeSeq = Impossible<(), Error>;
    *)
    Definition SerializeSeq : Set :=
      serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
    
    (*
        type SerializeTuple = Impossible<(), Error>;
    *)
    Definition SerializeTuple : Set :=
      serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
    
    (*
        type SerializeTupleStruct = Impossible<(), Error>;
    *)
    Definition SerializeTupleStruct : Set :=
      serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
    
    (*
        type SerializeTupleVariant = Impossible<(), Error>;
    *)
    Definition SerializeTupleVariant : Set :=
      serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
    
    (*
        type SerializeMap = Impossible<(), Error>;
    *)
    Definition SerializeMap : Set :=
      serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
    
    (*
        type SerializeStruct = Impossible<(), Error>;
    *)
    Definition SerializeStruct : Set :=
      serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
    
    (*
        type SerializeStructVariant = Impossible<(), Error>;
    *)
    Definition SerializeStructVariant : Set :=
      serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
    
    (*
        fn serialize_bool(self, value: bool) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_bool(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_bool
        (self : Self)
        (value : bool.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_bool :
      Notations.DoubleColon Self "serialize_bool" := {
      Notations.double_colon := serialize_bool;
    }.
    
    (*
        fn serialize_i8(self, value: i8) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_i8(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i8
        (self : Self)
        (value : i8.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i8 :
      Notations.DoubleColon Self "serialize_i8" := {
      Notations.double_colon := serialize_i8;
    }.
    
    (*
        fn serialize_i16(self, value: i16) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_i16(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i16
        (self : Self)
        (value : i16.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i16 :
      Notations.DoubleColon Self "serialize_i16" := {
      Notations.double_colon := serialize_i16;
    }.
    
    (*
        fn serialize_i32(self, value: i32) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_i32(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i32
        (self : Self)
        (value : i32.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i32 :
      Notations.DoubleColon Self "serialize_i32" := {
      Notations.double_colon := serialize_i32;
    }.
    
    (*
        fn serialize_i64(self, value: i64) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_i64(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i64
        (self : Self)
        (value : i64.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i64 :
      Notations.DoubleColon Self "serialize_i64" := {
      Notations.double_colon := serialize_i64;
    }.
    
    (*
        fn serialize_i128(self, value: i128) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_i128(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_i128
        (self : Self)
        (value : i128.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i128 :
      Notations.DoubleColon Self "serialize_i128" := {
      Notations.double_colon := serialize_i128;
    }.
    
    (*
        fn serialize_u8(self, value: u8) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_u8(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u8
        (self : Self)
        (value : u8.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u8 :
      Notations.DoubleColon Self "serialize_u8" := {
      Notations.double_colon := serialize_u8;
    }.
    
    (*
        fn serialize_u16(self, value: u16) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_u16(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u16
        (self : Self)
        (value : u16.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u16 :
      Notations.DoubleColon Self "serialize_u16" := {
      Notations.double_colon := serialize_u16;
    }.
    
    (*
        fn serialize_u32(self, value: u32) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_u32(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u32
        (self : Self)
        (value : u32.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u32 :
      Notations.DoubleColon Self "serialize_u32" := {
      Notations.double_colon := serialize_u32;
    }.
    
    (*
        fn serialize_u64(self, value: u64) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_u64(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u64
        (self : Self)
        (value : u64.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u64 :
      Notations.DoubleColon Self "serialize_u64" := {
      Notations.double_colon := serialize_u64;
    }.
    
    (*
        fn serialize_u128(self, value: u128) -> Result<()> {
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_u128(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_u128
        (self : Self)
        (value : u128.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u128 :
      Notations.DoubleColon Self "serialize_u128" := {
      Notations.double_colon := serialize_u128;
    }.
    
    (*
        fn serialize_f32(self, value: f32) -> Result<()> {
            if !value.is_finite() {
                return Err(float_key_must_be_finite());
            }
    
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_f32(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_f32
        (self : Self)
        (value : f32.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_f32 :
      Notations.DoubleColon Self "serialize_f32" := {
      Notations.double_colon := serialize_f32;
    }.
    
    (*
        fn serialize_f64(self, value: f64) -> Result<()> {
            if !value.is_finite() {
                return Err(float_key_must_be_finite());
            }
    
            tri!(self
                .ser
                .formatter
                .begin_string(&mut self.ser.writer)
                .map_err(Error::io));
            tri!(self
                .ser
                .formatter
                .write_f64(&mut self.ser.writer, value)
                .map_err(Error::io));
            self.ser
                .formatter
                .end_string(&mut self.ser.writer)
                .map_err(Error::io)
        }
    *)
    Definition serialize_f64
        (self : Self)
        (value : f64.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_f64 :
      Notations.DoubleColon Self "serialize_f64" := {
      Notations.double_colon := serialize_f64;
    }.
    
    (*
        fn serialize_char(self, value: char) -> Result<()> {
            self.ser.serialize_str(&value.to_string())
        }
    *)
    Definition serialize_char
        (self : Self)
        (value : char.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_char :
      Notations.DoubleColon Self "serialize_char" := {
      Notations.double_colon := serialize_char;
    }.
    
    (*
        fn serialize_bytes(self, _value: &[u8]) -> Result<()> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_bytes
        (self : Self)
        (_value : ref (slice u8.t))
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _value := M.alloc _value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_bytes :
      Notations.DoubleColon Self "serialize_bytes" := {
      Notations.double_colon := serialize_bytes;
    }.
    
    (*
        fn serialize_unit(self) -> Result<()> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_unit
        (self : Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit :
      Notations.DoubleColon Self "serialize_unit" := {
      Notations.double_colon := serialize_unit;
    }.
    
    (*
        fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_unit_struct
        (self : Self)
        (_name : ref str.t)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit_struct :
      Notations.DoubleColon Self "serialize_unit_struct" := {
      Notations.double_colon := serialize_unit_struct;
    }.
    
    (*
        fn serialize_newtype_variant<T>(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _value: &T,
        ) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (_variant : ref str.t)
        (_value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* _variant := M.alloc _variant in
      let* _value := M.alloc _value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_newtype_variant" := {
      Notations.double_colon := serialize_newtype_variant (T := T);
    }.
    
    (*
        fn serialize_none(self) -> Result<()> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_none
        (self : Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_none :
      Notations.DoubleColon Self "serialize_none" := {
      Notations.double_colon := serialize_none;
    }.
    
    (*
        fn serialize_some<T>(self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            value.serialize(self)
        }
    *)
    Definition serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_some" := {
      Notations.double_colon := serialize_some (T := T);
    }.
    
    (*
        fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_seq
        (self : Self)
        (_len : core.option.Option.t usize.t)
        : M ltac:(serde_json.error.Result SerializeSeq) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_seq :
      Notations.DoubleColon Self "serialize_seq" := {
      Notations.double_colon := serialize_seq;
    }.
    
    (*
        fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_tuple
        (self : Self)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTuple) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple :
      Notations.DoubleColon Self "serialize_tuple" := {
      Notations.double_colon := serialize_tuple;
    }.
    
    (*
        fn serialize_tuple_struct(
            self,
            _name: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeTupleStruct> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_tuple_struct
        (self : Self)
        (_name : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple_struct :
      Notations.DoubleColon Self "serialize_tuple_struct" := {
      Notations.double_colon := serialize_tuple_struct;
    }.
    
    (*
        fn serialize_tuple_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeTupleVariant> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_tuple_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (_variant : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* _variant := M.alloc _variant in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple_variant :
      Notations.DoubleColon Self "serialize_tuple_variant" := {
      Notations.double_colon := serialize_tuple_variant;
    }.
    
    (*
        fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_map
        (self : Self)
        (_len : core.option.Option.t usize.t)
        : M ltac:(serde_json.error.Result SerializeMap) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_map :
      Notations.DoubleColon Self "serialize_map" := {
      Notations.double_colon := serialize_map;
    }.
    
    (*
        fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_struct
        (self : Self)
        (_name : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeStruct) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_struct :
      Notations.DoubleColon Self "serialize_struct" := {
      Notations.double_colon := serialize_struct;
    }.
    
    (*
        fn serialize_struct_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeStructVariant> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_struct_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (_variant : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeStructVariant) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* _variant := M.alloc _variant in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_struct_variant :
      Notations.DoubleColon Self "serialize_struct_variant" := {
      Notations.double_colon := serialize_struct_variant;
    }.
    
    (*
        fn collect_str<T>(self, value: &T) -> Result<()>
        where
            T: ?Sized + Display,
        {
            self.ser.collect_str(value)
        }
    *)
    Definition collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T}
        (self : Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :
      Notations.DoubleColon Self "collect_str" := {
      Notations.double_colon := collect_str (T := T);
    }.
    
    Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
      serde.ser.Serializer.Ok := Ok;
      serde.ser.Serializer.Error := Error;
      serde.ser.Serializer.serialize_str := serialize_str;
      serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
      serde.ser.Serializer.serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_newtype_struct (T := T);
      serde.ser.Serializer.SerializeSeq := SerializeSeq;
      serde.ser.Serializer.SerializeTuple := SerializeTuple;
      serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
      serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
      serde.ser.Serializer.SerializeMap := SerializeMap;
      serde.ser.Serializer.SerializeStruct := SerializeStruct;
      serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
      serde.ser.Serializer.serialize_bool := serialize_bool;
      serde.ser.Serializer.serialize_i8 := serialize_i8;
      serde.ser.Serializer.serialize_i16 := serialize_i16;
      serde.ser.Serializer.serialize_i32 := serialize_i32;
      serde.ser.Serializer.serialize_i64 := serialize_i64;
      serde.ser.Serializer.serialize_i128 := Datatypes.Some serialize_i128;
      serde.ser.Serializer.serialize_u8 := serialize_u8;
      serde.ser.Serializer.serialize_u16 := serialize_u16;
      serde.ser.Serializer.serialize_u32 := serialize_u32;
      serde.ser.Serializer.serialize_u64 := serialize_u64;
      serde.ser.Serializer.serialize_u128 := Datatypes.Some serialize_u128;
      serde.ser.Serializer.serialize_f32 := serialize_f32;
      serde.ser.Serializer.serialize_f64 := serialize_f64;
      serde.ser.Serializer.serialize_char := serialize_char;
      serde.ser.Serializer.serialize_bytes := serialize_bytes;
      serde.ser.Serializer.serialize_unit := serialize_unit;
      serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
      serde.ser.Serializer.serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_newtype_variant (T := T);
      serde.ser.Serializer.serialize_none := serialize_none;
      serde.ser.Serializer.serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_some (T := T);
      serde.ser.Serializer.serialize_seq := serialize_seq;
      serde.ser.Serializer.serialize_tuple := serialize_tuple;
      serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
      serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
      serde.ser.Serializer.serialize_map := serialize_map;
      serde.ser.Serializer.serialize_struct := serialize_struct;
      serde.ser.Serializer.serialize_struct_variant := serialize_struct_variant;
      serde.ser.Serializer.collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :=
        Datatypes.Some (collect_str (T := T));
      serde.ser.Serializer.collect_seq := Datatypes.None;
      serde.ser.Serializer.collect_map := Datatypes.None;
      serde.ser.Serializer.is_human_readable := Datatypes.None;
    }.
  End Impl_serde_ser_Serializer_for_serde_json_ser_MapKeySerializer_t_W_F.
  End Impl_serde_ser_Serializer_for_serde_json_ser_MapKeySerializer_t_W_F.
  
  Module CharEscape.
    Inductive t : Set :=
    | Quote
    | ReverseSolidus
    | Solidus
    | Backspace
    | FormFeed
    | LineFeed
    | CarriageReturn
    | Tab
    | AsciiControl (_ : u8.t).
    
    Definition Get_AsciiControl_0 :=
      Ref.map
        (fun α => match α with | AsciiControl α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | AsciiControl _ => Some (AsciiControl β)
          | _ => None
          end).
  End CharEscape.
  
  Module  Impl_serde_json_ser_CharEscape_t.
  Section Impl_serde_json_ser_CharEscape_t.
    Definition Self : Set := serde_json.ser.CharEscape.t.
    
    (*
        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {
            match escape {
                self::BB => CharEscape::Backspace,
                self::TT => CharEscape::Tab,
                self::NN => CharEscape::LineFeed,
                self::FF => CharEscape::FormFeed,
                self::RR => CharEscape::CarriageReturn,
                self::QU => CharEscape::Quote,
                self::BS => CharEscape::ReverseSolidus,
                self::UU => CharEscape::AsciiControl(byte),
                _ => unreachable!(),
            }
        }
    *)
    Definition from_escape_table
        (escape : u8.t)
        (byte : u8.t)
        : M serde_json.ser.CharEscape.t :=
      let* escape := M.alloc escape in
      let* byte := M.alloc byte in
      M.read foo.
    
    Global Instance AssociatedFunction_from_escape_table :
      Notations.DoubleColon Self "from_escape_table" := {
      Notations.double_colon := from_escape_table;
    }.
  End Impl_serde_json_ser_CharEscape_t.
  End Impl_serde_json_ser_CharEscape_t.
  
  Module  Formatter.
  Section Formatter.
    Unset Primitive Projections.
    Class Trait (Self : Set) : Type := {
    }.
    Global Set Primitive Projections.
  End Formatter.
  End Formatter.
  
  Module  CompactFormatter.
  Section CompactFormatter.
    Inductive t : Set := Build.
  End CompactFormatter.
  End CompactFormatter.
  
  Module  Impl_core_clone_Clone_for_serde_json_ser_CompactFormatter_t.
  Section Impl_core_clone_Clone_for_serde_json_ser_CompactFormatter_t.
    Definition Self : Set := serde_json.ser.CompactFormatter.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M serde_json.ser.CompactFormatter.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_serde_json_ser_CompactFormatter_t.
  End Impl_core_clone_Clone_for_serde_json_ser_CompactFormatter_t.
  
  Module  Impl_core_fmt_Debug_for_serde_json_ser_CompactFormatter_t.
  Section Impl_core_fmt_Debug_for_serde_json_ser_CompactFormatter_t.
    Definition Self : Set := serde_json.ser.CompactFormatter.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_serde_json_ser_CompactFormatter_t.
  End Impl_core_fmt_Debug_for_serde_json_ser_CompactFormatter_t.
  
  Module  Impl_serde_json_ser_Formatter_for_serde_json_ser_CompactFormatter_t.
  Section Impl_serde_json_ser_Formatter_for_serde_json_ser_CompactFormatter_t.
    Definition Self : Set := serde_json.ser.CompactFormatter.t.
    
    Global Instance ℐ : serde_json.ser.Formatter.Required.Trait Self := {
      serde_json.ser.Formatter.write_null := Datatypes.None;
      serde_json.ser.Formatter.write_bool := Datatypes.None;
      serde_json.ser.Formatter.write_i8 := Datatypes.None;
      serde_json.ser.Formatter.write_i16 := Datatypes.None;
      serde_json.ser.Formatter.write_i32 := Datatypes.None;
      serde_json.ser.Formatter.write_i64 := Datatypes.None;
      serde_json.ser.Formatter.write_i128 := Datatypes.None;
      serde_json.ser.Formatter.write_u8 := Datatypes.None;
      serde_json.ser.Formatter.write_u16 := Datatypes.None;
      serde_json.ser.Formatter.write_u32 := Datatypes.None;
      serde_json.ser.Formatter.write_u64 := Datatypes.None;
      serde_json.ser.Formatter.write_u128 := Datatypes.None;
      serde_json.ser.Formatter.write_f32 := Datatypes.None;
      serde_json.ser.Formatter.write_f64 := Datatypes.None;
      serde_json.ser.Formatter.write_number_str := Datatypes.None;
      serde_json.ser.Formatter.begin_string := Datatypes.None;
      serde_json.ser.Formatter.end_string := Datatypes.None;
      serde_json.ser.Formatter.write_string_fragment := Datatypes.None;
      serde_json.ser.Formatter.write_char_escape := Datatypes.None;
      serde_json.ser.Formatter.write_byte_array := Datatypes.None;
      serde_json.ser.Formatter.begin_array := Datatypes.None;
      serde_json.ser.Formatter.end_array := Datatypes.None;
      serde_json.ser.Formatter.begin_array_value := Datatypes.None;
      serde_json.ser.Formatter.end_array_value := Datatypes.None;
      serde_json.ser.Formatter.begin_object := Datatypes.None;
      serde_json.ser.Formatter.end_object := Datatypes.None;
      serde_json.ser.Formatter.begin_object_key := Datatypes.None;
      serde_json.ser.Formatter.end_object_key := Datatypes.None;
      serde_json.ser.Formatter.begin_object_value := Datatypes.None;
      serde_json.ser.Formatter.end_object_value := Datatypes.None;
      serde_json.ser.Formatter.write_raw_fragment := Datatypes.None;
    }.
  End Impl_serde_json_ser_Formatter_for_serde_json_ser_CompactFormatter_t.
  End Impl_serde_json_ser_Formatter_for_serde_json_ser_CompactFormatter_t.
  
  Module  PrettyFormatter.
  Section PrettyFormatter.
    Record t : Set := {
      current_indent : usize.t;
      has_value : bool.t;
      indent : ref (slice u8.t);
    }.
    
    Definition Get_current_indent :=
      Ref.map
        (fun α => Some α.(current_indent))
        (fun β α => Some (α <| current_indent := β |>)).
    Definition Get_has_value :=
      Ref.map
        (fun α => Some α.(has_value))
        (fun β α => Some (α <| has_value := β |>)).
    Definition Get_indent :=
      Ref.map
        (fun α => Some α.(indent))
        (fun β α => Some (α <| indent := β |>)).
  End PrettyFormatter.
  End PrettyFormatter.
  
  Module  Impl_core_clone_Clone_for_serde_json_ser_PrettyFormatter_t.
  Section Impl_core_clone_Clone_for_serde_json_ser_PrettyFormatter_t.
    Definition Self : Set := serde_json.ser.PrettyFormatter.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M serde_json.ser.PrettyFormatter.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_serde_json_ser_PrettyFormatter_t.
  End Impl_core_clone_Clone_for_serde_json_ser_PrettyFormatter_t.
  
  Module  Impl_core_fmt_Debug_for_serde_json_ser_PrettyFormatter_t.
  Section Impl_core_fmt_Debug_for_serde_json_ser_PrettyFormatter_t.
    Definition Self : Set := serde_json.ser.PrettyFormatter.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_serde_json_ser_PrettyFormatter_t.
  End Impl_core_fmt_Debug_for_serde_json_ser_PrettyFormatter_t.
  
  Module  Impl_serde_json_ser_PrettyFormatter_t.
  Section Impl_serde_json_ser_PrettyFormatter_t.
    Definition Self : Set := serde_json.ser.PrettyFormatter.t.
    
    (*
        pub fn new() -> Self {
            PrettyFormatter::with_indent(b"  ")
        }
    *)
    Definition new : M Self := M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        pub fn with_indent(indent: &'a [u8]) -> Self {
            PrettyFormatter {
                current_indent: 0,
                has_value: false,
                indent,
            }
        }
    *)
    Definition with_indent (indent : ref (slice u8.t)) : M Self :=
      let* indent := M.alloc indent in
      M.read foo.
    
    Global Instance AssociatedFunction_with_indent :
      Notations.DoubleColon Self "with_indent" := {
      Notations.double_colon := with_indent;
    }.
  End Impl_serde_json_ser_PrettyFormatter_t.
  End Impl_serde_json_ser_PrettyFormatter_t.
  
  Module  Impl_core_default_Default_for_serde_json_ser_PrettyFormatter_t.
  Section Impl_core_default_Default_for_serde_json_ser_PrettyFormatter_t.
    Definition Self : Set := serde_json.ser.PrettyFormatter.t.
    
    (*
        fn default() -> Self {
            PrettyFormatter::new()
        }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_serde_json_ser_PrettyFormatter_t.
  End Impl_core_default_Default_for_serde_json_ser_PrettyFormatter_t.
  
  Module  Impl_serde_json_ser_Formatter_for_serde_json_ser_PrettyFormatter_t.
  Section Impl_serde_json_ser_Formatter_for_serde_json_ser_PrettyFormatter_t.
    Definition Self : Set := serde_json.ser.PrettyFormatter.t.
    
    (*
        fn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            self.current_indent += 1;
            self.has_value = false;
            writer.write_all(b"[")
        }
    *)
    Definition begin_array
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (writer : mut_ref W)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* writer := M.alloc writer in
      M.read foo.
    
    Global Instance AssociatedFunction_begin_array
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "begin_array" := {
      Notations.double_colon := begin_array (W := W);
    }.
    
    (*
        fn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            self.current_indent -= 1;
    
            if self.has_value {
                tri!(writer.write_all(b"\n"));
                tri!(indent(writer, self.current_indent, self.indent));
            }
    
            writer.write_all(b"]")
        }
    *)
    Definition end_array
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (writer : mut_ref W)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* writer := M.alloc writer in
      M.read foo.
    
    Global Instance AssociatedFunction_end_array
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "end_array" := {
      Notations.double_colon := end_array (W := W);
    }.
    
    (*
        fn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            tri!(writer.write_all(if first { b"\n" } else { b",\n" }));
            indent(writer, self.current_indent, self.indent)
        }
    *)
    Definition begin_array_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (writer : mut_ref W)
        (first : bool.t)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* writer := M.alloc writer in
      let* first := M.alloc first in
      M.read foo.
    
    Global Instance AssociatedFunction_begin_array_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "begin_array_value" := {
      Notations.double_colon := begin_array_value (W := W);
    }.
    
    (*
        fn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            self.has_value = true;
            Ok(())
        }
    *)
    Definition end_array_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (_writer : mut_ref W)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* _writer := M.alloc _writer in
      M.read foo.
    
    Global Instance AssociatedFunction_end_array_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "end_array_value" := {
      Notations.double_colon := end_array_value (W := W);
    }.
    
    (*
        fn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            self.current_indent += 1;
            self.has_value = false;
            writer.write_all(b"{")
        }
    *)
    Definition begin_object
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (writer : mut_ref W)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* writer := M.alloc writer in
      M.read foo.
    
    Global Instance AssociatedFunction_begin_object
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "begin_object" := {
      Notations.double_colon := begin_object (W := W);
    }.
    
    (*
        fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            self.current_indent -= 1;
    
            if self.has_value {
                tri!(writer.write_all(b"\n"));
                tri!(indent(writer, self.current_indent, self.indent));
            }
    
            writer.write_all(b"}")
        }
    *)
    Definition end_object
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (writer : mut_ref W)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* writer := M.alloc writer in
      M.read foo.
    
    Global Instance AssociatedFunction_end_object
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "end_object" := {
      Notations.double_colon := end_object (W := W);
    }.
    
    (*
        fn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            tri!(writer.write_all(if first { b"\n" } else { b",\n" }));
            indent(writer, self.current_indent, self.indent)
        }
    *)
    Definition begin_object_key
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (writer : mut_ref W)
        (first : bool.t)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* writer := M.alloc writer in
      let* first := M.alloc first in
      M.read foo.
    
    Global Instance AssociatedFunction_begin_object_key
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "begin_object_key" := {
      Notations.double_colon := begin_object_key (W := W);
    }.
    
    (*
        fn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            writer.write_all(b": ")
        }
    *)
    Definition begin_object_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (writer : mut_ref W)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* writer := M.alloc writer in
      M.read foo.
    
    Global Instance AssociatedFunction_begin_object_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "begin_object_value" := {
      Notations.double_colon := begin_object_value (W := W);
    }.
    
    (*
        fn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>
        where
            W: ?Sized + io::Write,
        {
            self.has_value = true;
            Ok(())
        }
    *)
    Definition end_object_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W}
        (self : mut_ref Self)
        (_writer : mut_ref W)
        : M ltac:(std.io.error.Result unit) :=
      let* self := M.alloc self in
      let* _writer := M.alloc _writer in
      M.read foo.
    
    Global Instance AssociatedFunction_end_object_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :
      Notations.DoubleColon Self "end_object_value" := {
      Notations.double_colon := end_object_value (W := W);
    }.
    
    Global Instance ℐ : serde_json.ser.Formatter.Required.Trait Self := {
      serde_json.ser.Formatter.begin_array
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (begin_array (W := W));
      serde_json.ser.Formatter.end_array
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (end_array (W := W));
      serde_json.ser.Formatter.begin_array_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (begin_array_value (W := W));
      serde_json.ser.Formatter.end_array_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (end_array_value (W := W));
      serde_json.ser.Formatter.begin_object
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (begin_object (W := W));
      serde_json.ser.Formatter.end_object
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (end_object (W := W));
      serde_json.ser.Formatter.begin_object_key
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (begin_object_key (W := W));
      serde_json.ser.Formatter.begin_object_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (begin_object_value (W := W));
      serde_json.ser.Formatter.end_object_value
        {W : Set}
        {ℋ_0 : std.io.Write.Trait W} :=
        Datatypes.Some (end_object_value (W := W));
      serde_json.ser.Formatter.write_null := Datatypes.None;
      serde_json.ser.Formatter.write_bool := Datatypes.None;
      serde_json.ser.Formatter.write_i8 := Datatypes.None;
      serde_json.ser.Formatter.write_i16 := Datatypes.None;
      serde_json.ser.Formatter.write_i32 := Datatypes.None;
      serde_json.ser.Formatter.write_i64 := Datatypes.None;
      serde_json.ser.Formatter.write_i128 := Datatypes.None;
      serde_json.ser.Formatter.write_u8 := Datatypes.None;
      serde_json.ser.Formatter.write_u16 := Datatypes.None;
      serde_json.ser.Formatter.write_u32 := Datatypes.None;
      serde_json.ser.Formatter.write_u64 := Datatypes.None;
      serde_json.ser.Formatter.write_u128 := Datatypes.None;
      serde_json.ser.Formatter.write_f32 := Datatypes.None;
      serde_json.ser.Formatter.write_f64 := Datatypes.None;
      serde_json.ser.Formatter.write_number_str := Datatypes.None;
      serde_json.ser.Formatter.begin_string := Datatypes.None;
      serde_json.ser.Formatter.end_string := Datatypes.None;
      serde_json.ser.Formatter.write_string_fragment := Datatypes.None;
      serde_json.ser.Formatter.write_char_escape := Datatypes.None;
      serde_json.ser.Formatter.write_byte_array := Datatypes.None;
      serde_json.ser.Formatter.end_object_key := Datatypes.None;
      serde_json.ser.Formatter.write_raw_fragment := Datatypes.None;
    }.
  End Impl_serde_json_ser_Formatter_for_serde_json_ser_PrettyFormatter_t.
  End Impl_serde_json_ser_Formatter_for_serde_json_ser_PrettyFormatter_t.
  
  (*
  fn format_escaped_str<W, F>(writer: &mut W, formatter: &mut F, value: &str) -> io::Result<()>
  where
      W: ?Sized + io::Write,
      F: ?Sized + Formatter,
  {
      tri!(formatter.begin_string(writer));
      tri!(format_escaped_str_contents(writer, formatter, value));
      formatter.end_string(writer)
  }
  *)
  Definition format_escaped_str
      {W F : Set}
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}
      (writer : mut_ref W)
      (formatter : mut_ref F)
      (value : ref str.t)
      : M ltac:(std.io.error.Result unit) :=
    let* writer := M.alloc writer in
    let* formatter := M.alloc formatter in
    let* value := M.alloc value in
    M.read foo.
  
  (*
  fn format_escaped_str_contents<W, F>(
      writer: &mut W,
      formatter: &mut F,
      value: &str,
  ) -> io::Result<()>
  where
      W: ?Sized + io::Write,
      F: ?Sized + Formatter,
  {
      let bytes = value.as_bytes();
  
      let mut start = 0;
  
      for (i, &byte) in bytes.iter().enumerate() {
          let escape = ESCAPE[byte as usize];
          if escape == 0 {
              continue;
          }
  
          if start < i {
              tri!(formatter.write_string_fragment(writer, &value[start..i]));
          }
  
          let char_escape = CharEscape::from_escape_table(escape, byte);
          tri!(formatter.write_char_escape(writer, char_escape));
  
          start = i + 1;
      }
  
      if start == bytes.len() {
          return Ok(());
      }
  
      formatter.write_string_fragment(writer, &value[start..])
  }
  *)
  Definition format_escaped_str_contents
      {W F : Set}
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde_json.ser.Formatter.Trait F}
      (writer : mut_ref W)
      (formatter : mut_ref F)
      (value : ref str.t)
      : M ltac:(std.io.error.Result unit) :=
    let* writer := M.alloc writer in
    let* formatter := M.alloc formatter in
    let* value := M.alloc value in
    M.read foo.
  
  Definition BB : M.Val u8.t := M.run (M.pure foo).
  
  Definition TT : M.Val u8.t := M.run (M.pure foo).
  
  Definition NN : M.Val u8.t := M.run (M.pure foo).
  
  Definition FF : M.Val u8.t := M.run (M.pure foo).
  
  Definition RR : M.Val u8.t := M.run (M.pure foo).
  
  Definition QU : M.Val u8.t := M.run (M.pure foo).
  
  Definition BS : M.Val u8.t := M.run (M.pure foo).
  
  Definition UU : M.Val u8.t := M.run (M.pure foo).
  
  Definition __ : M.Val u8.t := M.run (M.pure foo).
  
  Definition ESCAPE : M.Val (ref (array u8.t)) := M.run (M.alloc foo).
  
  (*
  pub fn to_writer<W, T>(writer: W, value: &T) -> Result<()>
  where
      W: io::Write,
      T: ?Sized + Serialize,
  {
      let mut ser = Serializer::new(writer);
      value.serialize(&mut ser)
  }
  *)
  Definition to_writer
      {W T : Set}
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde.ser.Serialize.Trait T}
      (writer : W)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* writer := M.alloc writer in
    let* value := M.alloc value in
    M.read foo.
  
  (*
  pub fn to_writer_pretty<W, T>(writer: W, value: &T) -> Result<()>
  where
      W: io::Write,
      T: ?Sized + Serialize,
  {
      let mut ser = Serializer::pretty(writer);
      value.serialize(&mut ser)
  }
  *)
  Definition to_writer_pretty
      {W T : Set}
      {ℋ_0 : std.io.Write.Trait W}
      {ℋ_1 : serde.ser.Serialize.Trait T}
      (writer : W)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* writer := M.alloc writer in
    let* value := M.alloc value in
    M.read foo.
  
  (*
  pub fn to_vec<T>(value: &T) -> Result<Vec<u8>>
  where
      T: ?Sized + Serialize,
  {
      let mut writer = Vec::with_capacity(128);
      tri!(to_writer(&mut writer, value));
      Ok(writer)
  }
  *)
  Definition to_vec
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (value : ref T)
      :
        M
          ltac:(serde_json.error.Result
            (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)) :=
    let* value := M.alloc value in
    M.read foo.
  
  (*
  pub fn to_vec_pretty<T>(value: &T) -> Result<Vec<u8>>
  where
      T: ?Sized + Serialize,
  {
      let mut writer = Vec::with_capacity(128);
      tri!(to_writer_pretty(&mut writer, value));
      Ok(writer)
  }
  *)
  Definition to_vec_pretty
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (value : ref T)
      :
        M
          ltac:(serde_json.error.Result
            (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)) :=
    let* value := M.alloc value in
    M.read foo.
  
  (*
  pub fn to_string<T>(value: &T) -> Result<String>
  where
      T: ?Sized + Serialize,
  {
      let vec = tri!(to_vec(value));
      let string = unsafe {
          // We do not emit invalid UTF-8.
          String::from_utf8_unchecked(vec)
      };
      Ok(string)
  }
  *)
  Definition to_string
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (value : ref T)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* value := M.alloc value in
    M.read foo.
  
  (*
  pub fn to_string_pretty<T>(value: &T) -> Result<String>
  where
      T: ?Sized + Serialize,
  {
      let vec = tri!(to_vec_pretty(value));
      let string = unsafe {
          // We do not emit invalid UTF-8.
          String::from_utf8_unchecked(vec)
      };
      Ok(string)
  }
  *)
  Definition to_string_pretty
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (value : ref T)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* value := M.alloc value in
    M.read foo.
  
  (*
  fn indent<W>(wr: &mut W, n: usize, s: &[u8]) -> io::Result<()>
  where
      W: ?Sized + io::Write,
  {
      for _ in 0..n {
          tri!(wr.write_all(s));
      }
  
      Ok(())
  }
  *)
  Definition indent
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (wr : mut_ref W)
      (n : usize.t)
      (s : ref (slice u8.t))
      : M ltac:(std.io.error.Result unit) :=
    let* wr := M.alloc wr in
    let* n := M.alloc n in
    let* s := M.alloc s in
    M.read foo.
End ser.

Module  Serializer.
Section Serializer.
  Context (W F : Set).
  
  Record t : Set := {
    writer : W;
    formatter : F;
  }.
  
  Definition Get_writer :=
    Ref.map (fun α => Some α.(writer)) (fun β α => Some (α <| writer := β |>)).
  Definition Get_formatter :=
    Ref.map
      (fun α => Some α.(formatter))
      (fun β α => Some (α <| formatter := β |>)).
  Module Default.
    Definition F := serde_json.ser.CompactFormatter.t.
  End Default.
End Serializer.
End Serializer.

Module  Impl_serde_json_ser_Serializer_t_W_serde_json_ser_Serializer_Default_F_2.
Section Impl_serde_json_ser_Serializer_t_W_serde_json_ser_Serializer_Default_F_2.
  Context {W : Set}.
  
  Definition Self : Set :=
    serde_json.ser.Serializer.t W serde_json.ser.Serializer.Default.F.
  
  (*
      pub fn new(writer: W) -> Self {
          Serializer::with_formatter(writer, CompactFormatter)
      }
  *)
  Definition new (writer : W) : M Self :=
    let* writer := M.alloc writer in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_ser_Serializer_t_W_serde_json_ser_Serializer_Default_F_2.
End Impl_serde_json_ser_Serializer_t_W_serde_json_ser_Serializer_Default_F_2.

Module  Impl_serde_json_ser_Serializer_t_W_serde_json_ser_PrettyFormatter_t_2.
Section Impl_serde_json_ser_Serializer_t_W_serde_json_ser_PrettyFormatter_t_2.
  Context {W : Set}.
  
  Definition Self : Set :=
    serde_json.ser.Serializer.t W serde_json.ser.PrettyFormatter.t.
  
  (*
      pub fn pretty(writer: W) -> Self {
          Serializer::with_formatter(writer, PrettyFormatter::new())
      }
  *)
  Definition pretty (writer : W) : M Self :=
    let* writer := M.alloc writer in
    M.read foo.
  
  Global Instance AssociatedFunction_pretty :
    Notations.DoubleColon Self "pretty" := {
    Notations.double_colon := pretty;
  }.
End Impl_serde_json_ser_Serializer_t_W_serde_json_ser_PrettyFormatter_t_2.
End Impl_serde_json_ser_Serializer_t_W_serde_json_ser_PrettyFormatter_t_2.

Module  Impl_serde_json_ser_Serializer_t_W_F_2.
Section Impl_serde_json_ser_Serializer_t_W_F_2.
  Context {W F : Set}.
  
  Definition Self : Set := serde_json.ser.Serializer.t W F.
  
  (*
      pub fn with_formatter(writer: W, formatter: F) -> Self {
          Serializer { writer, formatter }
      }
  *)
  Definition with_formatter (writer : W) (formatter : F) : M Self :=
    let* writer := M.alloc writer in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_with_formatter :
    Notations.DoubleColon Self "with_formatter" := {
    Notations.double_colon := with_formatter;
  }.
  
  (*
      pub fn into_inner(self) -> W {
          self.writer
      }
  *)
  Definition into_inner (self : Self) : M W :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_inner :
    Notations.DoubleColon Self "into_inner" := {
    Notations.double_colon := into_inner;
  }.
End Impl_serde_json_ser_Serializer_t_W_F_2.
End Impl_serde_json_ser_Serializer_t_W_F_2.

Module  Impl_serde_ser_Serializer_for_mut_ref_serde_json_ser_Serializer_t_W_F.
Section Impl_serde_ser_Serializer_for_mut_ref_serde_json_ser_Serializer_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := mut_ref (serde_json.ser.Serializer.t W F).
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      type SerializeSeq = Compound<'a, W, F>;
  *)
  Definition SerializeSeq : Set := serde_json.ser.Compound.t W F.
  
  (*
      type SerializeTuple = Compound<'a, W, F>;
  *)
  Definition SerializeTuple : Set := serde_json.ser.Compound.t W F.
  
  (*
      type SerializeTupleStruct = Compound<'a, W, F>;
  *)
  Definition SerializeTupleStruct : Set := serde_json.ser.Compound.t W F.
  
  (*
      type SerializeTupleVariant = Compound<'a, W, F>;
  *)
  Definition SerializeTupleVariant : Set := serde_json.ser.Compound.t W F.
  
  (*
      type SerializeMap = Compound<'a, W, F>;
  *)
  Definition SerializeMap : Set := serde_json.ser.Compound.t W F.
  
  (*
      type SerializeStruct = Compound<'a, W, F>;
  *)
  Definition SerializeStruct : Set := serde_json.ser.Compound.t W F.
  
  (*
      type SerializeStructVariant = Compound<'a, W, F>;
  *)
  Definition SerializeStructVariant : Set := serde_json.ser.Compound.t W F.
  
  (*
      fn serialize_bool(self, value: bool) -> Result<()> {
          self.formatter
              .write_bool(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_bool
      (self : Self)
      (value : bool.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_bool :
    Notations.DoubleColon Self "serialize_bool" := {
    Notations.double_colon := serialize_bool;
  }.
  
  (*
      fn serialize_i8(self, value: i8) -> Result<()> {
          self.formatter
              .write_i8(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i8
      (self : Self)
      (value : i8.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i8 :
    Notations.DoubleColon Self "serialize_i8" := {
    Notations.double_colon := serialize_i8;
  }.
  
  (*
      fn serialize_i16(self, value: i16) -> Result<()> {
          self.formatter
              .write_i16(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i16
      (self : Self)
      (value : i16.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i16 :
    Notations.DoubleColon Self "serialize_i16" := {
    Notations.double_colon := serialize_i16;
  }.
  
  (*
      fn serialize_i32(self, value: i32) -> Result<()> {
          self.formatter
              .write_i32(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i32
      (self : Self)
      (value : i32.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i32 :
    Notations.DoubleColon Self "serialize_i32" := {
    Notations.double_colon := serialize_i32;
  }.
  
  (*
      fn serialize_i64(self, value: i64) -> Result<()> {
          self.formatter
              .write_i64(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i64
      (self : Self)
      (value : i64.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i64 :
    Notations.DoubleColon Self "serialize_i64" := {
    Notations.double_colon := serialize_i64;
  }.
  
  (*
      fn serialize_i128(self, value: i128) -> Result<()> {
          self.formatter
              .write_i128(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i128
      (self : Self)
      (value : i128.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i128 :
    Notations.DoubleColon Self "serialize_i128" := {
    Notations.double_colon := serialize_i128;
  }.
  
  (*
      fn serialize_u8(self, value: u8) -> Result<()> {
          self.formatter
              .write_u8(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u8
      (self : Self)
      (value : u8.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u8 :
    Notations.DoubleColon Self "serialize_u8" := {
    Notations.double_colon := serialize_u8;
  }.
  
  (*
      fn serialize_u16(self, value: u16) -> Result<()> {
          self.formatter
              .write_u16(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u16
      (self : Self)
      (value : u16.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u16 :
    Notations.DoubleColon Self "serialize_u16" := {
    Notations.double_colon := serialize_u16;
  }.
  
  (*
      fn serialize_u32(self, value: u32) -> Result<()> {
          self.formatter
              .write_u32(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u32
      (self : Self)
      (value : u32.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u32 :
    Notations.DoubleColon Self "serialize_u32" := {
    Notations.double_colon := serialize_u32;
  }.
  
  (*
      fn serialize_u64(self, value: u64) -> Result<()> {
          self.formatter
              .write_u64(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u64
      (self : Self)
      (value : u64.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u64 :
    Notations.DoubleColon Self "serialize_u64" := {
    Notations.double_colon := serialize_u64;
  }.
  
  (*
      fn serialize_u128(self, value: u128) -> Result<()> {
          self.formatter
              .write_u128(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u128
      (self : Self)
      (value : u128.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u128 :
    Notations.DoubleColon Self "serialize_u128" := {
    Notations.double_colon := serialize_u128;
  }.
  
  (*
      fn serialize_f32(self, value: f32) -> Result<()> {
          match value.classify() {
              FpCategory::Nan | FpCategory::Infinite => self
                  .formatter
                  .write_null(&mut self.writer)
                  .map_err(Error::io),
              _ => self
                  .formatter
                  .write_f32(&mut self.writer, value)
                  .map_err(Error::io),
          }
      }
  *)
  Definition serialize_f32
      (self : Self)
      (value : f32.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_f32 :
    Notations.DoubleColon Self "serialize_f32" := {
    Notations.double_colon := serialize_f32;
  }.
  
  (*
      fn serialize_f64(self, value: f64) -> Result<()> {
          match value.classify() {
              FpCategory::Nan | FpCategory::Infinite => self
                  .formatter
                  .write_null(&mut self.writer)
                  .map_err(Error::io),
              _ => self
                  .formatter
                  .write_f64(&mut self.writer, value)
                  .map_err(Error::io),
          }
      }
  *)
  Definition serialize_f64
      (self : Self)
      (value : f64.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_f64 :
    Notations.DoubleColon Self "serialize_f64" := {
    Notations.double_colon := serialize_f64;
  }.
  
  (*
      fn serialize_char(self, value: char) -> Result<()> {
          // A char encoded as UTF-8 takes 4 bytes at most.
          let mut buf = [0; 4];
          self.serialize_str(value.encode_utf8(&mut buf))
      }
  *)
  Definition serialize_char
      (self : Self)
      (value : char.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_char :
    Notations.DoubleColon Self "serialize_char" := {
    Notations.double_colon := serialize_char;
  }.
  
  (*
      fn serialize_str(self, value: &str) -> Result<()> {
          format_escaped_str(&mut self.writer, &mut self.formatter, value).map_err(Error::io)
      }
  *)
  Definition serialize_str
      (self : Self)
      (value : ref str.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_str :
    Notations.DoubleColon Self "serialize_str" := {
    Notations.double_colon := serialize_str;
  }.
  
  (*
      fn serialize_bytes(self, value: &[u8]) -> Result<()> {
          self.formatter
              .write_byte_array(&mut self.writer, value)
              .map_err(Error::io)
      }
  *)
  Definition serialize_bytes
      (self : Self)
      (value : ref (slice u8.t))
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_bytes :
    Notations.DoubleColon Self "serialize_bytes" := {
    Notations.double_colon := serialize_bytes;
  }.
  
  (*
      fn serialize_unit(self) -> Result<()> {
          self.formatter
              .write_null(&mut self.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_unit
      (self : Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit :
    Notations.DoubleColon Self "serialize_unit" := {
    Notations.double_colon := serialize_unit;
  }.
  
  (*
      fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {
          self.serialize_unit()
      }
  *)
  Definition serialize_unit_struct
      (self : Self)
      (_name : ref str.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit_struct :
    Notations.DoubleColon Self "serialize_unit_struct" := {
    Notations.double_colon := serialize_unit_struct;
  }.
  
  (*
      fn serialize_unit_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
      ) -> Result<()> {
          self.serialize_str(variant)
      }
  *)
  Definition serialize_unit_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit_variant :
    Notations.DoubleColon Self "serialize_unit_variant" := {
    Notations.double_colon := serialize_unit_variant;
  }.
  
  (*
      fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          value.serialize(self)
      }
  *)
  Definition serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_name : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_newtype_struct" := {
    Notations.double_colon := serialize_newtype_struct (T := T);
  }.
  
  (*
      fn serialize_newtype_variant<T>(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
          value: &T,
      ) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          tri!(self
              .formatter
              .begin_object(&mut self.writer)
              .map_err(Error::io));
          tri!(self
              .formatter
              .begin_object_key(&mut self.writer, true)
              .map_err(Error::io));
          tri!(self.serialize_str(variant));
          tri!(self
              .formatter
              .end_object_key(&mut self.writer)
              .map_err(Error::io));
          tri!(self
              .formatter
              .begin_object_value(&mut self.writer)
              .map_err(Error::io));
          tri!(value.serialize(&mut *self));
          tri!(self
              .formatter
              .end_object_value(&mut self.writer)
              .map_err(Error::io));
          self.formatter
              .end_object(&mut self.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_newtype_variant" := {
    Notations.double_colon := serialize_newtype_variant (T := T);
  }.
  
  (*
      fn serialize_none(self) -> Result<()> {
          self.serialize_unit()
      }
  *)
  Definition serialize_none
      (self : Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_none :
    Notations.DoubleColon Self "serialize_none" := {
    Notations.double_colon := serialize_none;
  }.
  
  (*
      fn serialize_some<T>(self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          value.serialize(self)
      }
  *)
  Definition serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_some" := {
    Notations.double_colon := serialize_some (T := T);
  }.
  
  (*
      fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {
          tri!(self
              .formatter
              .begin_array(&mut self.writer)
              .map_err(Error::io));
          if len == Some(0) {
              tri!(self
                  .formatter
                  .end_array(&mut self.writer)
                  .map_err(Error::io));
              Ok(Compound::Map {
                  ser: self,
                  state: State::Empty,
              })
          } else {
              Ok(Compound::Map {
                  ser: self,
                  state: State::First,
              })
          }
      }
  *)
  Definition serialize_seq
      (self : Self)
      (len : core.option.Option.t usize.t)
      : M ltac:(serde_json.error.Result SerializeSeq) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_seq :
    Notations.DoubleColon Self "serialize_seq" := {
    Notations.double_colon := serialize_seq;
  }.
  
  (*
      fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {
          self.serialize_seq(Some(len))
      }
  *)
  Definition serialize_tuple
      (self : Self)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTuple) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple :
    Notations.DoubleColon Self "serialize_tuple" := {
    Notations.double_colon := serialize_tuple;
  }.
  
  (*
      fn serialize_tuple_struct(
          self,
          _name: &'static str,
          len: usize,
      ) -> Result<Self::SerializeTupleStruct> {
          self.serialize_seq(Some(len))
      }
  *)
  Definition serialize_tuple_struct
      (self : Self)
      (_name : ref str.t)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple_struct :
    Notations.DoubleColon Self "serialize_tuple_struct" := {
    Notations.double_colon := serialize_tuple_struct;
  }.
  
  (*
      fn serialize_tuple_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
          len: usize,
      ) -> Result<Self::SerializeTupleVariant> {
          tri!(self
              .formatter
              .begin_object(&mut self.writer)
              .map_err(Error::io));
          tri!(self
              .formatter
              .begin_object_key(&mut self.writer, true)
              .map_err(Error::io));
          tri!(self.serialize_str(variant));
          tri!(self
              .formatter
              .end_object_key(&mut self.writer)
              .map_err(Error::io));
          tri!(self
              .formatter
              .begin_object_value(&mut self.writer)
              .map_err(Error::io));
          self.serialize_seq(Some(len))
      }
  *)
  Definition serialize_tuple_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple_variant :
    Notations.DoubleColon Self "serialize_tuple_variant" := {
    Notations.double_colon := serialize_tuple_variant;
  }.
  
  (*
      fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap> {
          tri!(self
              .formatter
              .begin_object(&mut self.writer)
              .map_err(Error::io));
          if len == Some(0) {
              tri!(self
                  .formatter
                  .end_object(&mut self.writer)
                  .map_err(Error::io));
              Ok(Compound::Map {
                  ser: self,
                  state: State::Empty,
              })
          } else {
              Ok(Compound::Map {
                  ser: self,
                  state: State::First,
              })
          }
      }
  *)
  Definition serialize_map
      (self : Self)
      (len : core.option.Option.t usize.t)
      : M ltac:(serde_json.error.Result SerializeMap) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_map :
    Notations.DoubleColon Self "serialize_map" := {
    Notations.double_colon := serialize_map;
  }.
  
  (*
      fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct> {
          match name {
              #[cfg(feature = "arbitrary_precision")]
              crate::number::TOKEN => Ok(Compound::Number { ser: self }),
              #[cfg(feature = "raw_value")]
              crate::raw::TOKEN => Ok(Compound::RawValue { ser: self }),
              _ => self.serialize_map(Some(len)),
          }
      }
  *)
  Definition serialize_struct
      (self : Self)
      (name : ref str.t)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeStruct) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_struct :
    Notations.DoubleColon Self "serialize_struct" := {
    Notations.double_colon := serialize_struct;
  }.
  
  (*
      fn serialize_struct_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
          len: usize,
      ) -> Result<Self::SerializeStructVariant> {
          tri!(self
              .formatter
              .begin_object(&mut self.writer)
              .map_err(Error::io));
          tri!(self
              .formatter
              .begin_object_key(&mut self.writer, true)
              .map_err(Error::io));
          tri!(self.serialize_str(variant));
          tri!(self
              .formatter
              .end_object_key(&mut self.writer)
              .map_err(Error::io));
          tri!(self
              .formatter
              .begin_object_value(&mut self.writer)
              .map_err(Error::io));
          self.serialize_map(Some(len))
      }
  *)
  Definition serialize_struct_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeStructVariant) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_struct_variant :
    Notations.DoubleColon Self "serialize_struct_variant" := {
    Notations.double_colon := serialize_struct_variant;
  }.
  
  (*
      fn collect_str<T>(self, value: &T) -> Result<()>
      where
          T: ?Sized + Display,
      {
          use self::fmt::Write;
  
          struct Adapter<'ser, W: 'ser, F: 'ser> {
              writer: &'ser mut W,
              formatter: &'ser mut F,
              error: Option<io::Error>,
          }
  
          impl<'ser, W, F> Write for Adapter<'ser, W, F>
          where
              W: io::Write,
              F: Formatter,
          {
              fn write_str(&mut self, s: &str) -> fmt::Result {
                  debug_assert!(self.error.is_none());
                  match format_escaped_str_contents(self.writer, self.formatter, s) {
                      Ok(()) => Ok(()),
                      Err(err) => {
                          self.error = Some(err);
                          Err(fmt::Error)
                      }
                  }
              }
          }
  
          tri!(self
              .formatter
              .begin_string(&mut self.writer)
              .map_err(Error::io));
          let mut adapter = Adapter {
              writer: &mut self.writer,
              formatter: &mut self.formatter,
              error: None,
          };
          match write!(adapter, "{}", value) {
              Ok(()) => debug_assert!(adapter.error.is_none()),
              Err(fmt::Error) => {
                  return Err(Error::io(adapter.error.expect("there should be an error")));
              }
          }
          self.formatter
              .end_string(&mut self.writer)
              .map_err(Error::io)
      }
  *)
  Definition collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T}
      (self : Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :
    Notations.DoubleColon Self "collect_str" := {
    Notations.double_colon := collect_str (T := T);
  }.
  
  Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
    serde.ser.Serializer.Ok := Ok;
    serde.ser.Serializer.Error := Error;
    serde.ser.Serializer.SerializeSeq := SerializeSeq;
    serde.ser.Serializer.SerializeTuple := SerializeTuple;
    serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
    serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
    serde.ser.Serializer.SerializeMap := SerializeMap;
    serde.ser.Serializer.SerializeStruct := SerializeStruct;
    serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
    serde.ser.Serializer.serialize_bool := serialize_bool;
    serde.ser.Serializer.serialize_i8 := serialize_i8;
    serde.ser.Serializer.serialize_i16 := serialize_i16;
    serde.ser.Serializer.serialize_i32 := serialize_i32;
    serde.ser.Serializer.serialize_i64 := serialize_i64;
    serde.ser.Serializer.serialize_i128 := Datatypes.Some serialize_i128;
    serde.ser.Serializer.serialize_u8 := serialize_u8;
    serde.ser.Serializer.serialize_u16 := serialize_u16;
    serde.ser.Serializer.serialize_u32 := serialize_u32;
    serde.ser.Serializer.serialize_u64 := serialize_u64;
    serde.ser.Serializer.serialize_u128 := Datatypes.Some serialize_u128;
    serde.ser.Serializer.serialize_f32 := serialize_f32;
    serde.ser.Serializer.serialize_f64 := serialize_f64;
    serde.ser.Serializer.serialize_char := serialize_char;
    serde.ser.Serializer.serialize_str := serialize_str;
    serde.ser.Serializer.serialize_bytes := serialize_bytes;
    serde.ser.Serializer.serialize_unit := serialize_unit;
    serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
    serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
    serde.ser.Serializer.serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_newtype_struct (T := T);
    serde.ser.Serializer.serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_newtype_variant (T := T);
    serde.ser.Serializer.serialize_none := serialize_none;
    serde.ser.Serializer.serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_some (T := T);
    serde.ser.Serializer.serialize_seq := serialize_seq;
    serde.ser.Serializer.serialize_tuple := serialize_tuple;
    serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
    serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
    serde.ser.Serializer.serialize_map := serialize_map;
    serde.ser.Serializer.serialize_struct := serialize_struct;
    serde.ser.Serializer.serialize_struct_variant := serialize_struct_variant;
    serde.ser.Serializer.collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :=
      Datatypes.Some (collect_str (T := T));
    serde.ser.Serializer.collect_seq := Datatypes.None;
    serde.ser.Serializer.collect_map := Datatypes.None;
    serde.ser.Serializer.is_human_readable := Datatypes.None;
  }.
End Impl_serde_ser_Serializer_for_mut_ref_serde_json_ser_Serializer_t_W_F.
End Impl_serde_ser_Serializer_for_mut_ref_serde_json_ser_Serializer_t_W_F.

Module  Adapter.
Section Adapter.
  Context (W F : Set).
  
  Record t : Set := {
    writer : mut_ref W;
    formatter : mut_ref F;
    error : core.option.Option.t std.io.error.Error.t;
  }.
  
  Definition Get_writer :=
    Ref.map (fun α => Some α.(writer)) (fun β α => Some (α <| writer := β |>)).
  Definition Get_formatter :=
    Ref.map
      (fun α => Some α.(formatter))
      (fun β α => Some (α <| formatter := β |>)).
  Definition Get_error :=
    Ref.map (fun α => Some α.(error)) (fun β α => Some (α <| error := β |>)).
End Adapter.
End Adapter.

Module  Impl_core_fmt_Write_for_serde_json_ser_collect_str_Adapter_t_W_F.
Section Impl_core_fmt_Write_for_serde_json_ser_collect_str_Adapter_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.collect_str.Adapter.t W F.
  
  (*
              fn write_str(&mut self, s: &str) -> fmt::Result {
                  debug_assert!(self.error.is_none());
                  match format_escaped_str_contents(self.writer, self.formatter, s) {
                      Ok(()) => Ok(()),
                      Err(err) => {
                          self.error = Some(err);
                          Err(fmt::Error)
                      }
                  }
              }
  *)
  Definition write_str
      (self : mut_ref Self)
      (s : ref str.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* s := M.alloc s in
    M.read foo.
  
  Global Instance AssociatedFunction_write_str :
    Notations.DoubleColon Self "write_str" := {
    Notations.double_colon := write_str;
  }.
  
  Global Instance ℐ : core.fmt.Write.Required.Trait Self := {
    core.fmt.Write.write_str := write_str;
    core.fmt.Write.write_char := Datatypes.None;
    core.fmt.Write.write_fmt := Datatypes.None;
  }.
End Impl_core_fmt_Write_for_serde_json_ser_collect_str_Adapter_t_W_F.
End Impl_core_fmt_Write_for_serde_json_ser_collect_str_Adapter_t_W_F.

Module State.
  Inductive t : Set :=
  | Empty
  | First
  | Rest.
End State.

Module  Impl_core_marker_StructuralEq_for_serde_json_ser_State_t.
Section Impl_core_marker_StructuralEq_for_serde_json_ser_State_t.
  Definition Self : Set := serde_json.ser.State.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_serde_json_ser_State_t.
End Impl_core_marker_StructuralEq_for_serde_json_ser_State_t.

Module  Impl_core_cmp_Eq_for_serde_json_ser_State_t.
Section Impl_core_cmp_Eq_for_serde_json_ser_State_t.
  Definition Self : Set := serde_json.ser.State.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_serde_json_ser_State_t.
End Impl_core_cmp_Eq_for_serde_json_ser_State_t.

Module  Impl_core_marker_StructuralPartialEq_for_serde_json_ser_State_t.
Section Impl_core_marker_StructuralPartialEq_for_serde_json_ser_State_t.
  Definition Self : Set := serde_json.ser.State.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_serde_json_ser_State_t.
End Impl_core_marker_StructuralPartialEq_for_serde_json_ser_State_t.

Module  Impl_core_cmp_PartialEq_for_serde_json_ser_State_t.
Section Impl_core_cmp_PartialEq_for_serde_json_ser_State_t.
  Definition Self : Set := serde_json.ser.State.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.ser.State.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_serde_json_ser_State_t.
End Impl_core_cmp_PartialEq_for_serde_json_ser_State_t.

Module Compound.
  Module Map.
    Record t : Set := {
      ser : mut_ref (serde_json.ser.Serializer.t W F);
      state : serde_json.ser.State.t;
    }.
  End Map.
  
  Inductive t (W : Set) (F : Set) : Set :=
  | Map (_ : Map.t).
  
  Definition Get_Map_ser :=
    Ref.map
      (fun α => match α with | Map α => Some α.(Map.ser) end)
      (fun β α =>
        match α with | Map α => Some (Map (α <| Map.ser := β |>)) end).
  
  Definition Get_Map_state :=
    Ref.map
      (fun α => match α with | Map α => Some α.(Map.state) end)
      (fun β α =>
        match α with | Map α => Some (Map (α <| Map.state := β |>)) end).
End Compound.

Module  Impl_serde_ser_SerializeSeq_for_serde_json_ser_Compound_t_W_F.
Section Impl_serde_ser_SerializeSeq_for_serde_json_ser_Compound_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.Compound.t W F.
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_element<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          match self {
              Compound::Map { ser, state } => {
                  tri!(ser
                      .formatter
                      .begin_array_value(&mut ser.writer, *state == State::First)
                      .map_err(Error::io));
                  *state = State::Rest;
                  tri!(value.serialize(&mut **ser));
                  ser.formatter
                      .end_array_value(&mut ser.writer)
                      .map_err(Error::io)
              }
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_element" := {
    Notations.double_colon := serialize_element (T := T);
  }.
  
  (*
      fn end(self) -> Result<()> {
          match self {
              Compound::Map { ser, state } => match state {
                  State::Empty => Ok(()),
                  _ => ser.formatter.end_array(&mut ser.writer).map_err(Error::io),
              },
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeSeq.Trait Self := {
    serde.ser.SerializeSeq.Ok := Ok;
    serde.ser.SerializeSeq.Error := Error;
    serde.ser.SerializeSeq.serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_element (T := T);
    serde.ser.SerializeSeq.end_ := end_;
  }.
End Impl_serde_ser_SerializeSeq_for_serde_json_ser_Compound_t_W_F.
End Impl_serde_ser_SerializeSeq_for_serde_json_ser_Compound_t_W_F.

Module  Impl_serde_ser_SerializeTuple_for_serde_json_ser_Compound_t_W_F.
Section Impl_serde_ser_SerializeTuple_for_serde_json_ser_Compound_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.Compound.t W F.
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_element<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          ser::SerializeSeq::serialize_element(self, value)
      }
  *)
  Definition serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_element" := {
    Notations.double_colon := serialize_element (T := T);
  }.
  
  (*
      fn end(self) -> Result<()> {
          ser::SerializeSeq::end(self)
      }
  *)
  Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeTuple.Trait Self := {
    serde.ser.SerializeTuple.Ok := Ok;
    serde.ser.SerializeTuple.Error := Error;
    serde.ser.SerializeTuple.serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_element (T := T);
    serde.ser.SerializeTuple.end_ := end_;
  }.
End Impl_serde_ser_SerializeTuple_for_serde_json_ser_Compound_t_W_F.
End Impl_serde_ser_SerializeTuple_for_serde_json_ser_Compound_t_W_F.

Module  Impl_serde_ser_SerializeTupleStruct_for_serde_json_ser_Compound_t_W_F.
Section Impl_serde_ser_SerializeTupleStruct_for_serde_json_ser_Compound_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.Compound.t W F.
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_field<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          ser::SerializeSeq::serialize_element(self, value)
      }
  *)
  Definition serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_field" := {
    Notations.double_colon := serialize_field (T := T);
  }.
  
  (*
      fn end(self) -> Result<()> {
          ser::SerializeSeq::end(self)
      }
  *)
  Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeTupleStruct.Trait Self := {
    serde.ser.SerializeTupleStruct.Ok := Ok;
    serde.ser.SerializeTupleStruct.Error := Error;
    serde.ser.SerializeTupleStruct.serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_field (T := T);
    serde.ser.SerializeTupleStruct.end_ := end_;
  }.
End Impl_serde_ser_SerializeTupleStruct_for_serde_json_ser_Compound_t_W_F.
End Impl_serde_ser_SerializeTupleStruct_for_serde_json_ser_Compound_t_W_F.

Module  Impl_serde_ser_SerializeTupleVariant_for_serde_json_ser_Compound_t_W_F.
Section Impl_serde_ser_SerializeTupleVariant_for_serde_json_ser_Compound_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.Compound.t W F.
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_field<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          ser::SerializeSeq::serialize_element(self, value)
      }
  *)
  Definition serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_field" := {
    Notations.double_colon := serialize_field (T := T);
  }.
  
  (*
      fn end(self) -> Result<()> {
          match self {
              Compound::Map { ser, state } => {
                  match state {
                      State::Empty => {}
                      _ => tri!(ser.formatter.end_array(&mut ser.writer).map_err(Error::io)),
                  }
                  tri!(ser
                      .formatter
                      .end_object_value(&mut ser.writer)
                      .map_err(Error::io));
                  ser.formatter.end_object(&mut ser.writer).map_err(Error::io)
              }
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeTupleVariant.Trait Self := {
    serde.ser.SerializeTupleVariant.Ok := Ok;
    serde.ser.SerializeTupleVariant.Error := Error;
    serde.ser.SerializeTupleVariant.serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_field (T := T);
    serde.ser.SerializeTupleVariant.end_ := end_;
  }.
End Impl_serde_ser_SerializeTupleVariant_for_serde_json_ser_Compound_t_W_F.
End Impl_serde_ser_SerializeTupleVariant_for_serde_json_ser_Compound_t_W_F.

Module  Impl_serde_ser_SerializeMap_for_serde_json_ser_Compound_t_W_F.
Section Impl_serde_ser_SerializeMap_for_serde_json_ser_Compound_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.Compound.t W F.
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_key<T>(&mut self, key: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          match self {
              Compound::Map { ser, state } => {
                  tri!(ser
                      .formatter
                      .begin_object_key(&mut ser.writer, *state == State::First)
                      .map_err(Error::io));
                  *state = State::Rest;
  
                  tri!(key.serialize(MapKeySerializer { ser: *ser }));
  
                  ser.formatter
                      .end_object_key(&mut ser.writer)
                      .map_err(Error::io)
              }
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition serialize_key
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (key : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_key
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_key" := {
    Notations.double_colon := serialize_key (T := T);
  }.
  
  (*
      fn serialize_value<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          match self {
              Compound::Map { ser, .. } => {
                  tri!(ser
                      .formatter
                      .begin_object_value(&mut ser.writer)
                      .map_err(Error::io));
                  tri!(value.serialize(&mut **ser));
                  ser.formatter
                      .end_object_value(&mut ser.writer)
                      .map_err(Error::io)
              }
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition serialize_value
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_value
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_value" := {
    Notations.double_colon := serialize_value (T := T);
  }.
  
  (*
      fn end(self) -> Result<()> {
          match self {
              Compound::Map { ser, state } => match state {
                  State::Empty => Ok(()),
                  _ => ser.formatter.end_object(&mut ser.writer).map_err(Error::io),
              },
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeMap.Required.Trait Self := {
    serde.ser.SerializeMap.Ok := Ok;
    serde.ser.SerializeMap.Error := Error;
    serde.ser.SerializeMap.serialize_key
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_key (T := T);
    serde.ser.SerializeMap.serialize_value
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_value (T := T);
    serde.ser.SerializeMap.end_ := end_;
    serde.ser.SerializeMap.serialize_entry := Datatypes.None;
  }.
End Impl_serde_ser_SerializeMap_for_serde_json_ser_Compound_t_W_F.
End Impl_serde_ser_SerializeMap_for_serde_json_ser_Compound_t_W_F.

Module  Impl_serde_ser_SerializeStruct_for_serde_json_ser_Compound_t_W_F.
Section Impl_serde_ser_SerializeStruct_for_serde_json_ser_Compound_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.Compound.t W F.
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          match self {
              Compound::Map { .. } => ser::SerializeMap::serialize_entry(self, key, value),
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { ser, .. } => {
                  if key == crate::number::TOKEN {
                      value.serialize(NumberStrEmitter(ser))
                  } else {
                      Err(invalid_number())
                  }
              }
              #[cfg(feature = "raw_value")]
              Compound::RawValue { ser, .. } => {
                  if key == crate::raw::TOKEN {
                      value.serialize(RawValueStrEmitter(ser))
                  } else {
                      Err(invalid_raw_value())
                  }
              }
          }
      }
  *)
  Definition serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (key : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_field" := {
    Notations.double_colon := serialize_field (T := T);
  }.
  
  (*
      fn end(self) -> Result<()> {
          match self {
              Compound::Map { .. } => ser::SerializeMap::end(self),
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => Ok(()),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => Ok(()),
          }
      }
  *)
  Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeStruct.Required.Trait Self := {
    serde.ser.SerializeStruct.Ok := Ok;
    serde.ser.SerializeStruct.Error := Error;
    serde.ser.SerializeStruct.serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_field (T := T);
    serde.ser.SerializeStruct.end_ := end_;
    serde.ser.SerializeStruct.skip_field := Datatypes.None;
  }.
End Impl_serde_ser_SerializeStruct_for_serde_json_ser_Compound_t_W_F.
End Impl_serde_ser_SerializeStruct_for_serde_json_ser_Compound_t_W_F.

Module  Impl_serde_ser_SerializeStructVariant_for_serde_json_ser_Compound_t_W_F.
Section Impl_serde_ser_SerializeStructVariant_for_serde_json_ser_Compound_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.Compound.t W F.
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          match *self {
              Compound::Map { .. } => ser::SerializeStruct::serialize_field(self, key, value),
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (key : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_field" := {
    Notations.double_colon := serialize_field (T := T);
  }.
  
  (*
      fn end(self) -> Result<()> {
          match self {
              Compound::Map { ser, state } => {
                  match state {
                      State::Empty => {}
                      _ => tri!(ser.formatter.end_object(&mut ser.writer).map_err(Error::io)),
                  }
                  tri!(ser
                      .formatter
                      .end_object_value(&mut ser.writer)
                      .map_err(Error::io));
                  ser.formatter.end_object(&mut ser.writer).map_err(Error::io)
              }
              #[cfg(feature = "arbitrary_precision")]
              Compound::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              Compound::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition end_ (self : Self) : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeStructVariant.Required.Trait Self := {
    serde.ser.SerializeStructVariant.Ok := Ok;
    serde.ser.SerializeStructVariant.Error := Error;
    serde.ser.SerializeStructVariant.serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_field (T := T);
    serde.ser.SerializeStructVariant.end_ := end_;
    serde.ser.SerializeStructVariant.skip_field := Datatypes.None;
  }.
End Impl_serde_ser_SerializeStructVariant_for_serde_json_ser_Compound_t_W_F.
End Impl_serde_ser_SerializeStructVariant_for_serde_json_ser_Compound_t_W_F.

Module  MapKeySerializer.
Section MapKeySerializer.
  Context (W F : Set).
  
  Record t : Set := {
    ser : mut_ref (serde_json.ser.Serializer.t W F);
  }.
  
  Definition Get_ser :=
    Ref.map (fun α => Some α.(ser)) (fun β α => Some (α <| ser := β |>)).
End MapKeySerializer.
End MapKeySerializer.

(*
fn key_must_be_a_string() -> Error {
    Error::syntax(ErrorCode::KeyMustBeAString, 0, 0)
}
*)
Definition key_must_be_a_string : M serde_json.error.Error.t := M.read foo.

(*
fn float_key_must_be_finite() -> Error {
    Error::syntax(ErrorCode::FloatKeyMustBeFinite, 0, 0)
}
*)
Definition float_key_must_be_finite : M serde_json.error.Error.t := M.read foo.

Module  Impl_serde_ser_Serializer_for_serde_json_ser_MapKeySerializer_t_W_F.
Section Impl_serde_ser_Serializer_for_serde_json_ser_MapKeySerializer_t_W_F.
  Context {W F : Set}.
  
  Context {ℋ_0 : std.io.Write.Trait W} {ℋ_1 : serde_json.ser.Formatter.Trait F}.
  
  Definition Self : Set := serde_json.ser.MapKeySerializer.t W F.
  
  (*
      type Ok = ();
  *)
  Definition Ok : Set := unit.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_str(self, value: &str) -> Result<()> {
          self.ser.serialize_str(value)
      }
  *)
  Definition serialize_str
      (self : Self)
      (value : ref str.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_str :
    Notations.DoubleColon Self "serialize_str" := {
    Notations.double_colon := serialize_str;
  }.
  
  (*
      fn serialize_unit_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
      ) -> Result<()> {
          self.ser.serialize_str(variant)
      }
  *)
  Definition serialize_unit_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit_variant :
    Notations.DoubleColon Self "serialize_unit_variant" := {
    Notations.double_colon := serialize_unit_variant;
  }.
  
  (*
      fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          value.serialize(self)
      }
  *)
  Definition serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_name : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_newtype_struct" := {
    Notations.double_colon := serialize_newtype_struct (T := T);
  }.
  
  (*
      type SerializeSeq = Impossible<(), Error>;
  *)
  Definition SerializeSeq : Set :=
    serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
  
  (*
      type SerializeTuple = Impossible<(), Error>;
  *)
  Definition SerializeTuple : Set :=
    serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
  
  (*
      type SerializeTupleStruct = Impossible<(), Error>;
  *)
  Definition SerializeTupleStruct : Set :=
    serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
  
  (*
      type SerializeTupleVariant = Impossible<(), Error>;
  *)
  Definition SerializeTupleVariant : Set :=
    serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
  
  (*
      type SerializeMap = Impossible<(), Error>;
  *)
  Definition SerializeMap : Set :=
    serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
  
  (*
      type SerializeStruct = Impossible<(), Error>;
  *)
  Definition SerializeStruct : Set :=
    serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
  
  (*
      type SerializeStructVariant = Impossible<(), Error>;
  *)
  Definition SerializeStructVariant : Set :=
    serde.ser.impossible.Impossible.t unit serde_json.error.Error.t.
  
  (*
      fn serialize_bool(self, value: bool) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_bool(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_bool
      (self : Self)
      (value : bool.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_bool :
    Notations.DoubleColon Self "serialize_bool" := {
    Notations.double_colon := serialize_bool;
  }.
  
  (*
      fn serialize_i8(self, value: i8) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_i8(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i8
      (self : Self)
      (value : i8.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i8 :
    Notations.DoubleColon Self "serialize_i8" := {
    Notations.double_colon := serialize_i8;
  }.
  
  (*
      fn serialize_i16(self, value: i16) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_i16(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i16
      (self : Self)
      (value : i16.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i16 :
    Notations.DoubleColon Self "serialize_i16" := {
    Notations.double_colon := serialize_i16;
  }.
  
  (*
      fn serialize_i32(self, value: i32) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_i32(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i32
      (self : Self)
      (value : i32.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i32 :
    Notations.DoubleColon Self "serialize_i32" := {
    Notations.double_colon := serialize_i32;
  }.
  
  (*
      fn serialize_i64(self, value: i64) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_i64(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i64
      (self : Self)
      (value : i64.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i64 :
    Notations.DoubleColon Self "serialize_i64" := {
    Notations.double_colon := serialize_i64;
  }.
  
  (*
      fn serialize_i128(self, value: i128) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_i128(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_i128
      (self : Self)
      (value : i128.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i128 :
    Notations.DoubleColon Self "serialize_i128" := {
    Notations.double_colon := serialize_i128;
  }.
  
  (*
      fn serialize_u8(self, value: u8) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_u8(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u8
      (self : Self)
      (value : u8.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u8 :
    Notations.DoubleColon Self "serialize_u8" := {
    Notations.double_colon := serialize_u8;
  }.
  
  (*
      fn serialize_u16(self, value: u16) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_u16(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u16
      (self : Self)
      (value : u16.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u16 :
    Notations.DoubleColon Self "serialize_u16" := {
    Notations.double_colon := serialize_u16;
  }.
  
  (*
      fn serialize_u32(self, value: u32) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_u32(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u32
      (self : Self)
      (value : u32.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u32 :
    Notations.DoubleColon Self "serialize_u32" := {
    Notations.double_colon := serialize_u32;
  }.
  
  (*
      fn serialize_u64(self, value: u64) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_u64(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u64
      (self : Self)
      (value : u64.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u64 :
    Notations.DoubleColon Self "serialize_u64" := {
    Notations.double_colon := serialize_u64;
  }.
  
  (*
      fn serialize_u128(self, value: u128) -> Result<()> {
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_u128(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_u128
      (self : Self)
      (value : u128.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u128 :
    Notations.DoubleColon Self "serialize_u128" := {
    Notations.double_colon := serialize_u128;
  }.
  
  (*
      fn serialize_f32(self, value: f32) -> Result<()> {
          if !value.is_finite() {
              return Err(float_key_must_be_finite());
          }
  
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_f32(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_f32
      (self : Self)
      (value : f32.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_f32 :
    Notations.DoubleColon Self "serialize_f32" := {
    Notations.double_colon := serialize_f32;
  }.
  
  (*
      fn serialize_f64(self, value: f64) -> Result<()> {
          if !value.is_finite() {
              return Err(float_key_must_be_finite());
          }
  
          tri!(self
              .ser
              .formatter
              .begin_string(&mut self.ser.writer)
              .map_err(Error::io));
          tri!(self
              .ser
              .formatter
              .write_f64(&mut self.ser.writer, value)
              .map_err(Error::io));
          self.ser
              .formatter
              .end_string(&mut self.ser.writer)
              .map_err(Error::io)
      }
  *)
  Definition serialize_f64
      (self : Self)
      (value : f64.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_f64 :
    Notations.DoubleColon Self "serialize_f64" := {
    Notations.double_colon := serialize_f64;
  }.
  
  (*
      fn serialize_char(self, value: char) -> Result<()> {
          self.ser.serialize_str(&value.to_string())
      }
  *)
  Definition serialize_char
      (self : Self)
      (value : char.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_char :
    Notations.DoubleColon Self "serialize_char" := {
    Notations.double_colon := serialize_char;
  }.
  
  (*
      fn serialize_bytes(self, _value: &[u8]) -> Result<()> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_bytes
      (self : Self)
      (_value : ref (slice u8.t))
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _value := M.alloc _value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_bytes :
    Notations.DoubleColon Self "serialize_bytes" := {
    Notations.double_colon := serialize_bytes;
  }.
  
  (*
      fn serialize_unit(self) -> Result<()> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_unit
      (self : Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit :
    Notations.DoubleColon Self "serialize_unit" := {
    Notations.double_colon := serialize_unit;
  }.
  
  (*
      fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_unit_struct
      (self : Self)
      (_name : ref str.t)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit_struct :
    Notations.DoubleColon Self "serialize_unit_struct" := {
    Notations.double_colon := serialize_unit_struct;
  }.
  
  (*
      fn serialize_newtype_variant<T>(
          self,
          _name: &'static str,
          _variant_index: u32,
          _variant: &'static str,
          _value: &T,
      ) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (_variant : ref str.t)
      (_value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* _variant := M.alloc _variant in
    let* _value := M.alloc _value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_newtype_variant" := {
    Notations.double_colon := serialize_newtype_variant (T := T);
  }.
  
  (*
      fn serialize_none(self) -> Result<()> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_none
      (self : Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_none :
    Notations.DoubleColon Self "serialize_none" := {
    Notations.double_colon := serialize_none;
  }.
  
  (*
      fn serialize_some<T>(self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          value.serialize(self)
      }
  *)
  Definition serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_some" := {
    Notations.double_colon := serialize_some (T := T);
  }.
  
  (*
      fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_seq
      (self : Self)
      (_len : core.option.Option.t usize.t)
      : M ltac:(serde_json.error.Result SerializeSeq) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_seq :
    Notations.DoubleColon Self "serialize_seq" := {
    Notations.double_colon := serialize_seq;
  }.
  
  (*
      fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_tuple
      (self : Self)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTuple) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple :
    Notations.DoubleColon Self "serialize_tuple" := {
    Notations.double_colon := serialize_tuple;
  }.
  
  (*
      fn serialize_tuple_struct(
          self,
          _name: &'static str,
          _len: usize,
      ) -> Result<Self::SerializeTupleStruct> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_tuple_struct
      (self : Self)
      (_name : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple_struct :
    Notations.DoubleColon Self "serialize_tuple_struct" := {
    Notations.double_colon := serialize_tuple_struct;
  }.
  
  (*
      fn serialize_tuple_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          _variant: &'static str,
          _len: usize,
      ) -> Result<Self::SerializeTupleVariant> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_tuple_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (_variant : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* _variant := M.alloc _variant in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple_variant :
    Notations.DoubleColon Self "serialize_tuple_variant" := {
    Notations.double_colon := serialize_tuple_variant;
  }.
  
  (*
      fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_map
      (self : Self)
      (_len : core.option.Option.t usize.t)
      : M ltac:(serde_json.error.Result SerializeMap) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_map :
    Notations.DoubleColon Self "serialize_map" := {
    Notations.double_colon := serialize_map;
  }.
  
  (*
      fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_struct
      (self : Self)
      (_name : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeStruct) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_struct :
    Notations.DoubleColon Self "serialize_struct" := {
    Notations.double_colon := serialize_struct;
  }.
  
  (*
      fn serialize_struct_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          _variant: &'static str,
          _len: usize,
      ) -> Result<Self::SerializeStructVariant> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_struct_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (_variant : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeStructVariant) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* _variant := M.alloc _variant in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_struct_variant :
    Notations.DoubleColon Self "serialize_struct_variant" := {
    Notations.double_colon := serialize_struct_variant;
  }.
  
  (*
      fn collect_str<T>(self, value: &T) -> Result<()>
      where
          T: ?Sized + Display,
      {
          self.ser.collect_str(value)
      }
  *)
  Definition collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T}
      (self : Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :
    Notations.DoubleColon Self "collect_str" := {
    Notations.double_colon := collect_str (T := T);
  }.
  
  Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
    serde.ser.Serializer.Ok := Ok;
    serde.ser.Serializer.Error := Error;
    serde.ser.Serializer.serialize_str := serialize_str;
    serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
    serde.ser.Serializer.serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_newtype_struct (T := T);
    serde.ser.Serializer.SerializeSeq := SerializeSeq;
    serde.ser.Serializer.SerializeTuple := SerializeTuple;
    serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
    serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
    serde.ser.Serializer.SerializeMap := SerializeMap;
    serde.ser.Serializer.SerializeStruct := SerializeStruct;
    serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
    serde.ser.Serializer.serialize_bool := serialize_bool;
    serde.ser.Serializer.serialize_i8 := serialize_i8;
    serde.ser.Serializer.serialize_i16 := serialize_i16;
    serde.ser.Serializer.serialize_i32 := serialize_i32;
    serde.ser.Serializer.serialize_i64 := serialize_i64;
    serde.ser.Serializer.serialize_i128 := Datatypes.Some serialize_i128;
    serde.ser.Serializer.serialize_u8 := serialize_u8;
    serde.ser.Serializer.serialize_u16 := serialize_u16;
    serde.ser.Serializer.serialize_u32 := serialize_u32;
    serde.ser.Serializer.serialize_u64 := serialize_u64;
    serde.ser.Serializer.serialize_u128 := Datatypes.Some serialize_u128;
    serde.ser.Serializer.serialize_f32 := serialize_f32;
    serde.ser.Serializer.serialize_f64 := serialize_f64;
    serde.ser.Serializer.serialize_char := serialize_char;
    serde.ser.Serializer.serialize_bytes := serialize_bytes;
    serde.ser.Serializer.serialize_unit := serialize_unit;
    serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
    serde.ser.Serializer.serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_newtype_variant (T := T);
    serde.ser.Serializer.serialize_none := serialize_none;
    serde.ser.Serializer.serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_some (T := T);
    serde.ser.Serializer.serialize_seq := serialize_seq;
    serde.ser.Serializer.serialize_tuple := serialize_tuple;
    serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
    serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
    serde.ser.Serializer.serialize_map := serialize_map;
    serde.ser.Serializer.serialize_struct := serialize_struct;
    serde.ser.Serializer.serialize_struct_variant := serialize_struct_variant;
    serde.ser.Serializer.collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :=
      Datatypes.Some (collect_str (T := T));
    serde.ser.Serializer.collect_seq := Datatypes.None;
    serde.ser.Serializer.collect_map := Datatypes.None;
    serde.ser.Serializer.is_human_readable := Datatypes.None;
  }.
End Impl_serde_ser_Serializer_for_serde_json_ser_MapKeySerializer_t_W_F.
End Impl_serde_ser_Serializer_for_serde_json_ser_MapKeySerializer_t_W_F.

Module CharEscape.
  Inductive t : Set :=
  | Quote
  | ReverseSolidus
  | Solidus
  | Backspace
  | FormFeed
  | LineFeed
  | CarriageReturn
  | Tab
  | AsciiControl (_ : u8.t).
  
  Definition Get_AsciiControl_0 :=
    Ref.map
      (fun α => match α with | AsciiControl α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | AsciiControl _ => Some (AsciiControl β) | _ => None end).
End CharEscape.

Module  Impl_serde_json_ser_CharEscape_t_2.
Section Impl_serde_json_ser_CharEscape_t_2.
  Definition Self : Set := serde_json.ser.CharEscape.t.
  
  (*
      fn from_escape_table(escape: u8, byte: u8) -> CharEscape {
          match escape {
              self::BB => CharEscape::Backspace,
              self::TT => CharEscape::Tab,
              self::NN => CharEscape::LineFeed,
              self::FF => CharEscape::FormFeed,
              self::RR => CharEscape::CarriageReturn,
              self::QU => CharEscape::Quote,
              self::BS => CharEscape::ReverseSolidus,
              self::UU => CharEscape::AsciiControl(byte),
              _ => unreachable!(),
          }
      }
  *)
  Definition from_escape_table
      (escape : u8.t)
      (byte : u8.t)
      : M serde_json.ser.CharEscape.t :=
    let* escape := M.alloc escape in
    let* byte := M.alloc byte in
    M.read foo.
  
  Global Instance AssociatedFunction_from_escape_table :
    Notations.DoubleColon Self "from_escape_table" := {
    Notations.double_colon := from_escape_table;
  }.
End Impl_serde_json_ser_CharEscape_t_2.
End Impl_serde_json_ser_CharEscape_t_2.

Module  Formatter.
Section Formatter.
  Unset Primitive Projections.
  Class Trait (Self : Set) : Type := {
  }.
  Global Set Primitive Projections.
End Formatter.
End Formatter.

Definition HEX_DIGITS : M.Val (ref (array u8.t)) := M.run (M.alloc foo).

Module  CompactFormatter.
Section CompactFormatter.
  Inductive t : Set := Build.
End CompactFormatter.
End CompactFormatter.

Module  Impl_core_clone_Clone_for_serde_json_ser_CompactFormatter_t.
Section Impl_core_clone_Clone_for_serde_json_ser_CompactFormatter_t.
  Definition Self : Set := serde_json.ser.CompactFormatter.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M serde_json.ser.CompactFormatter.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_serde_json_ser_CompactFormatter_t.
End Impl_core_clone_Clone_for_serde_json_ser_CompactFormatter_t.

Module  Impl_core_fmt_Debug_for_serde_json_ser_CompactFormatter_t.
Section Impl_core_fmt_Debug_for_serde_json_ser_CompactFormatter_t.
  Definition Self : Set := serde_json.ser.CompactFormatter.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_serde_json_ser_CompactFormatter_t.
End Impl_core_fmt_Debug_for_serde_json_ser_CompactFormatter_t.

Module  Impl_serde_json_ser_Formatter_for_serde_json_ser_CompactFormatter_t.
Section Impl_serde_json_ser_Formatter_for_serde_json_ser_CompactFormatter_t.
  Definition Self : Set := serde_json.ser.CompactFormatter.t.
  
  Global Instance ℐ : serde_json.ser.Formatter.Required.Trait Self := {
    serde_json.ser.Formatter.write_null := Datatypes.None;
    serde_json.ser.Formatter.write_bool := Datatypes.None;
    serde_json.ser.Formatter.write_i8 := Datatypes.None;
    serde_json.ser.Formatter.write_i16 := Datatypes.None;
    serde_json.ser.Formatter.write_i32 := Datatypes.None;
    serde_json.ser.Formatter.write_i64 := Datatypes.None;
    serde_json.ser.Formatter.write_i128 := Datatypes.None;
    serde_json.ser.Formatter.write_u8 := Datatypes.None;
    serde_json.ser.Formatter.write_u16 := Datatypes.None;
    serde_json.ser.Formatter.write_u32 := Datatypes.None;
    serde_json.ser.Formatter.write_u64 := Datatypes.None;
    serde_json.ser.Formatter.write_u128 := Datatypes.None;
    serde_json.ser.Formatter.write_f32 := Datatypes.None;
    serde_json.ser.Formatter.write_f64 := Datatypes.None;
    serde_json.ser.Formatter.write_number_str := Datatypes.None;
    serde_json.ser.Formatter.begin_string := Datatypes.None;
    serde_json.ser.Formatter.end_string := Datatypes.None;
    serde_json.ser.Formatter.write_string_fragment := Datatypes.None;
    serde_json.ser.Formatter.write_char_escape := Datatypes.None;
    serde_json.ser.Formatter.write_byte_array := Datatypes.None;
    serde_json.ser.Formatter.begin_array := Datatypes.None;
    serde_json.ser.Formatter.end_array := Datatypes.None;
    serde_json.ser.Formatter.begin_array_value := Datatypes.None;
    serde_json.ser.Formatter.end_array_value := Datatypes.None;
    serde_json.ser.Formatter.begin_object := Datatypes.None;
    serde_json.ser.Formatter.end_object := Datatypes.None;
    serde_json.ser.Formatter.begin_object_key := Datatypes.None;
    serde_json.ser.Formatter.end_object_key := Datatypes.None;
    serde_json.ser.Formatter.begin_object_value := Datatypes.None;
    serde_json.ser.Formatter.end_object_value := Datatypes.None;
    serde_json.ser.Formatter.write_raw_fragment := Datatypes.None;
  }.
End Impl_serde_json_ser_Formatter_for_serde_json_ser_CompactFormatter_t.
End Impl_serde_json_ser_Formatter_for_serde_json_ser_CompactFormatter_t.

Module  PrettyFormatter.
Section PrettyFormatter.
  Record t : Set := {
    current_indent : usize.t;
    has_value : bool.t;
    indent : ref (slice u8.t);
  }.
  
  Definition Get_current_indent :=
    Ref.map
      (fun α => Some α.(current_indent))
      (fun β α => Some (α <| current_indent := β |>)).
  Definition Get_has_value :=
    Ref.map
      (fun α => Some α.(has_value))
      (fun β α => Some (α <| has_value := β |>)).
  Definition Get_indent :=
    Ref.map (fun α => Some α.(indent)) (fun β α => Some (α <| indent := β |>)).
End PrettyFormatter.
End PrettyFormatter.

Module  Impl_core_clone_Clone_for_serde_json_ser_PrettyFormatter_t.
Section Impl_core_clone_Clone_for_serde_json_ser_PrettyFormatter_t.
  Definition Self : Set := serde_json.ser.PrettyFormatter.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M serde_json.ser.PrettyFormatter.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_serde_json_ser_PrettyFormatter_t.
End Impl_core_clone_Clone_for_serde_json_ser_PrettyFormatter_t.

Module  Impl_core_fmt_Debug_for_serde_json_ser_PrettyFormatter_t.
Section Impl_core_fmt_Debug_for_serde_json_ser_PrettyFormatter_t.
  Definition Self : Set := serde_json.ser.PrettyFormatter.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_serde_json_ser_PrettyFormatter_t.
End Impl_core_fmt_Debug_for_serde_json_ser_PrettyFormatter_t.

Module  Impl_serde_json_ser_PrettyFormatter_t_2.
Section Impl_serde_json_ser_PrettyFormatter_t_2.
  Definition Self : Set := serde_json.ser.PrettyFormatter.t.
  
  (*
      pub fn new() -> Self {
          PrettyFormatter::with_indent(b"  ")
      }
  *)
  Definition new : M Self := M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn with_indent(indent: &'a [u8]) -> Self {
          PrettyFormatter {
              current_indent: 0,
              has_value: false,
              indent,
          }
      }
  *)
  Definition with_indent (indent : ref (slice u8.t)) : M Self :=
    let* indent := M.alloc indent in
    M.read foo.
  
  Global Instance AssociatedFunction_with_indent :
    Notations.DoubleColon Self "with_indent" := {
    Notations.double_colon := with_indent;
  }.
End Impl_serde_json_ser_PrettyFormatter_t_2.
End Impl_serde_json_ser_PrettyFormatter_t_2.

Module  Impl_core_default_Default_for_serde_json_ser_PrettyFormatter_t.
Section Impl_core_default_Default_for_serde_json_ser_PrettyFormatter_t.
  Definition Self : Set := serde_json.ser.PrettyFormatter.t.
  
  (*
      fn default() -> Self {
          PrettyFormatter::new()
      }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_serde_json_ser_PrettyFormatter_t.
End Impl_core_default_Default_for_serde_json_ser_PrettyFormatter_t.

Module  Impl_serde_json_ser_Formatter_for_serde_json_ser_PrettyFormatter_t.
Section Impl_serde_json_ser_Formatter_for_serde_json_ser_PrettyFormatter_t.
  Definition Self : Set := serde_json.ser.PrettyFormatter.t.
  
  (*
      fn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          self.current_indent += 1;
          self.has_value = false;
          writer.write_all(b"[")
      }
  *)
  Definition begin_array
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (writer : mut_ref W)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* writer := M.alloc writer in
    M.read foo.
  
  Global Instance AssociatedFunction_begin_array
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "begin_array" := {
    Notations.double_colon := begin_array (W := W);
  }.
  
  (*
      fn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          self.current_indent -= 1;
  
          if self.has_value {
              tri!(writer.write_all(b"\n"));
              tri!(indent(writer, self.current_indent, self.indent));
          }
  
          writer.write_all(b"]")
      }
  *)
  Definition end_array
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (writer : mut_ref W)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* writer := M.alloc writer in
    M.read foo.
  
  Global Instance AssociatedFunction_end_array
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "end_array" := {
    Notations.double_colon := end_array (W := W);
  }.
  
  (*
      fn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          tri!(writer.write_all(if first { b"\n" } else { b",\n" }));
          indent(writer, self.current_indent, self.indent)
      }
  *)
  Definition begin_array_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (writer : mut_ref W)
      (first : bool.t)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* writer := M.alloc writer in
    let* first := M.alloc first in
    M.read foo.
  
  Global Instance AssociatedFunction_begin_array_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "begin_array_value" := {
    Notations.double_colon := begin_array_value (W := W);
  }.
  
  (*
      fn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          self.has_value = true;
          Ok(())
      }
  *)
  Definition end_array_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (_writer : mut_ref W)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* _writer := M.alloc _writer in
    M.read foo.
  
  Global Instance AssociatedFunction_end_array_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "end_array_value" := {
    Notations.double_colon := end_array_value (W := W);
  }.
  
  (*
      fn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          self.current_indent += 1;
          self.has_value = false;
          writer.write_all(b"{")
      }
  *)
  Definition begin_object
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (writer : mut_ref W)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* writer := M.alloc writer in
    M.read foo.
  
  Global Instance AssociatedFunction_begin_object
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "begin_object" := {
    Notations.double_colon := begin_object (W := W);
  }.
  
  (*
      fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          self.current_indent -= 1;
  
          if self.has_value {
              tri!(writer.write_all(b"\n"));
              tri!(indent(writer, self.current_indent, self.indent));
          }
  
          writer.write_all(b"}")
      }
  *)
  Definition end_object
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (writer : mut_ref W)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* writer := M.alloc writer in
    M.read foo.
  
  Global Instance AssociatedFunction_end_object
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "end_object" := {
    Notations.double_colon := end_object (W := W);
  }.
  
  (*
      fn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          tri!(writer.write_all(if first { b"\n" } else { b",\n" }));
          indent(writer, self.current_indent, self.indent)
      }
  *)
  Definition begin_object_key
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (writer : mut_ref W)
      (first : bool.t)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* writer := M.alloc writer in
    let* first := M.alloc first in
    M.read foo.
  
  Global Instance AssociatedFunction_begin_object_key
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "begin_object_key" := {
    Notations.double_colon := begin_object_key (W := W);
  }.
  
  (*
      fn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          writer.write_all(b": ")
      }
  *)
  Definition begin_object_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (writer : mut_ref W)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* writer := M.alloc writer in
    M.read foo.
  
  Global Instance AssociatedFunction_begin_object_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "begin_object_value" := {
    Notations.double_colon := begin_object_value (W := W);
  }.
  
  (*
      fn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>
      where
          W: ?Sized + io::Write,
      {
          self.has_value = true;
          Ok(())
      }
  *)
  Definition end_object_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W}
      (self : mut_ref Self)
      (_writer : mut_ref W)
      : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    let* _writer := M.alloc _writer in
    M.read foo.
  
  Global Instance AssociatedFunction_end_object_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :
    Notations.DoubleColon Self "end_object_value" := {
    Notations.double_colon := end_object_value (W := W);
  }.
  
  Global Instance ℐ : serde_json.ser.Formatter.Required.Trait Self := {
    serde_json.ser.Formatter.begin_array
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (begin_array (W := W));
    serde_json.ser.Formatter.end_array {W : Set} {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (end_array (W := W));
    serde_json.ser.Formatter.begin_array_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (begin_array_value (W := W));
    serde_json.ser.Formatter.end_array_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (end_array_value (W := W));
    serde_json.ser.Formatter.begin_object
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (begin_object (W := W));
    serde_json.ser.Formatter.end_object
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (end_object (W := W));
    serde_json.ser.Formatter.begin_object_key
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (begin_object_key (W := W));
    serde_json.ser.Formatter.begin_object_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (begin_object_value (W := W));
    serde_json.ser.Formatter.end_object_value
      {W : Set}
      {ℋ_0 : std.io.Write.Trait W} :=
      Datatypes.Some (end_object_value (W := W));
    serde_json.ser.Formatter.write_null := Datatypes.None;
    serde_json.ser.Formatter.write_bool := Datatypes.None;
    serde_json.ser.Formatter.write_i8 := Datatypes.None;
    serde_json.ser.Formatter.write_i16 := Datatypes.None;
    serde_json.ser.Formatter.write_i32 := Datatypes.None;
    serde_json.ser.Formatter.write_i64 := Datatypes.None;
    serde_json.ser.Formatter.write_i128 := Datatypes.None;
    serde_json.ser.Formatter.write_u8 := Datatypes.None;
    serde_json.ser.Formatter.write_u16 := Datatypes.None;
    serde_json.ser.Formatter.write_u32 := Datatypes.None;
    serde_json.ser.Formatter.write_u64 := Datatypes.None;
    serde_json.ser.Formatter.write_u128 := Datatypes.None;
    serde_json.ser.Formatter.write_f32 := Datatypes.None;
    serde_json.ser.Formatter.write_f64 := Datatypes.None;
    serde_json.ser.Formatter.write_number_str := Datatypes.None;
    serde_json.ser.Formatter.begin_string := Datatypes.None;
    serde_json.ser.Formatter.end_string := Datatypes.None;
    serde_json.ser.Formatter.write_string_fragment := Datatypes.None;
    serde_json.ser.Formatter.write_char_escape := Datatypes.None;
    serde_json.ser.Formatter.write_byte_array := Datatypes.None;
    serde_json.ser.Formatter.end_object_key := Datatypes.None;
    serde_json.ser.Formatter.write_raw_fragment := Datatypes.None;
  }.
End Impl_serde_json_ser_Formatter_for_serde_json_ser_PrettyFormatter_t.
End Impl_serde_json_ser_Formatter_for_serde_json_ser_PrettyFormatter_t.

(*
fn format_escaped_str<W, F>(writer: &mut W, formatter: &mut F, value: &str) -> io::Result<()>
where
    W: ?Sized + io::Write,
    F: ?Sized + Formatter,
{
    tri!(formatter.begin_string(writer));
    tri!(format_escaped_str_contents(writer, formatter, value));
    formatter.end_string(writer)
}
*)
Definition format_escaped_str
    {W F : Set}
    {ℋ_0 : std.io.Write.Trait W}
    {ℋ_1 : serde_json.ser.Formatter.Trait F}
    (writer : mut_ref W)
    (formatter : mut_ref F)
    (value : ref str.t)
    : M ltac:(std.io.error.Result unit) :=
  let* writer := M.alloc writer in
  let* formatter := M.alloc formatter in
  let* value := M.alloc value in
  M.read foo.

(*
fn format_escaped_str_contents<W, F>(
    writer: &mut W,
    formatter: &mut F,
    value: &str,
) -> io::Result<()>
where
    W: ?Sized + io::Write,
    F: ?Sized + Formatter,
{
    let bytes = value.as_bytes();

    let mut start = 0;

    for (i, &byte) in bytes.iter().enumerate() {
        let escape = ESCAPE[byte as usize];
        if escape == 0 {
            continue;
        }

        if start < i {
            tri!(formatter.write_string_fragment(writer, &value[start..i]));
        }

        let char_escape = CharEscape::from_escape_table(escape, byte);
        tri!(formatter.write_char_escape(writer, char_escape));

        start = i + 1;
    }

    if start == bytes.len() {
        return Ok(());
    }

    formatter.write_string_fragment(writer, &value[start..])
}
*)
Definition format_escaped_str_contents
    {W F : Set}
    {ℋ_0 : std.io.Write.Trait W}
    {ℋ_1 : serde_json.ser.Formatter.Trait F}
    (writer : mut_ref W)
    (formatter : mut_ref F)
    (value : ref str.t)
    : M ltac:(std.io.error.Result unit) :=
  let* writer := M.alloc writer in
  let* formatter := M.alloc formatter in
  let* value := M.alloc value in
  M.read foo.

Definition BB : M.Val u8.t := M.run (M.pure foo).

Definition TT : M.Val u8.t := M.run (M.pure foo).

Definition NN : M.Val u8.t := M.run (M.pure foo).

Definition FF : M.Val u8.t := M.run (M.pure foo).

Definition RR : M.Val u8.t := M.run (M.pure foo).

Definition QU : M.Val u8.t := M.run (M.pure foo).

Definition BS : M.Val u8.t := M.run (M.pure foo).

Definition UU : M.Val u8.t := M.run (M.pure foo).

Definition __ : M.Val u8.t := M.run (M.pure foo).

Definition ESCAPE : M.Val (ref (array u8.t)) := M.run (M.alloc foo).

(*
pub fn to_writer<W, T>(writer: W, value: &T) -> Result<()>
where
    W: io::Write,
    T: ?Sized + Serialize,
{
    let mut ser = Serializer::new(writer);
    value.serialize(&mut ser)
}
*)
Definition to_writer
    {W T : Set}
    {ℋ_0 : std.io.Write.Trait W}
    {ℋ_1 : serde.ser.Serialize.Trait T}
    (writer : W)
    (value : ref T)
    : M ltac:(serde_json.error.Result unit) :=
  let* writer := M.alloc writer in
  let* value := M.alloc value in
  M.read foo.

(*
pub fn to_writer_pretty<W, T>(writer: W, value: &T) -> Result<()>
where
    W: io::Write,
    T: ?Sized + Serialize,
{
    let mut ser = Serializer::pretty(writer);
    value.serialize(&mut ser)
}
*)
Definition to_writer_pretty
    {W T : Set}
    {ℋ_0 : std.io.Write.Trait W}
    {ℋ_1 : serde.ser.Serialize.Trait T}
    (writer : W)
    (value : ref T)
    : M ltac:(serde_json.error.Result unit) :=
  let* writer := M.alloc writer in
  let* value := M.alloc value in
  M.read foo.

(*
pub fn to_vec<T>(value: &T) -> Result<Vec<u8>>
where
    T: ?Sized + Serialize,
{
    let mut writer = Vec::with_capacity(128);
    tri!(to_writer(&mut writer, value));
    Ok(writer)
}
*)
Definition to_vec
    {T : Set}
    {ℋ_0 : serde.ser.Serialize.Trait T}
    (value : ref T)
    :
      M
        ltac:(serde_json.error.Result
          (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)) :=
  let* value := M.alloc value in
  M.read foo.

(*
pub fn to_vec_pretty<T>(value: &T) -> Result<Vec<u8>>
where
    T: ?Sized + Serialize,
{
    let mut writer = Vec::with_capacity(128);
    tri!(to_writer_pretty(&mut writer, value));
    Ok(writer)
}
*)
Definition to_vec_pretty
    {T : Set}
    {ℋ_0 : serde.ser.Serialize.Trait T}
    (value : ref T)
    :
      M
        ltac:(serde_json.error.Result
          (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)) :=
  let* value := M.alloc value in
  M.read foo.

(*
pub fn to_string<T>(value: &T) -> Result<String>
where
    T: ?Sized + Serialize,
{
    let vec = tri!(to_vec(value));
    let string = unsafe {
        // We do not emit invalid UTF-8.
        String::from_utf8_unchecked(vec)
    };
    Ok(string)
}
*)
Definition to_string
    {T : Set}
    {ℋ_0 : serde.ser.Serialize.Trait T}
    (value : ref T)
    : M ltac:(serde_json.error.Result alloc.string.String.t) :=
  let* value := M.alloc value in
  M.read foo.

(*
pub fn to_string_pretty<T>(value: &T) -> Result<String>
where
    T: ?Sized + Serialize,
{
    let vec = tri!(to_vec_pretty(value));
    let string = unsafe {
        // We do not emit invalid UTF-8.
        String::from_utf8_unchecked(vec)
    };
    Ok(string)
}
*)
Definition to_string_pretty
    {T : Set}
    {ℋ_0 : serde.ser.Serialize.Trait T}
    (value : ref T)
    : M ltac:(serde_json.error.Result alloc.string.String.t) :=
  let* value := M.alloc value in
  M.read foo.

(*
fn indent<W>(wr: &mut W, n: usize, s: &[u8]) -> io::Result<()>
where
    W: ?Sized + io::Write,
{
    for _ in 0..n {
        tri!(wr.write_all(s));
    }

    Ok(())
}
*)
Definition indent
    {W : Set}
    {ℋ_0 : std.io.Write.Trait W}
    (wr : mut_ref W)
    (n : usize.t)
    (s : ref (slice u8.t))
    : M ltac:(std.io.error.Result unit) :=
  let* wr := M.alloc wr in
  let* n := M.alloc n in
  let* s := M.alloc s in
  M.read foo.

Module value.
  Module Value.
    Inductive t : Set :=
    | Null
    | Bool (_ : bool.t)
    | Number (_ : serde_json.number.Number.t)
    | String (_ : alloc.string.String.t)
    |
      Array
      (_ : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A)
    |
      Object
      (_ : serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t).
    
    Definition Get_Bool_0 :=
      Ref.map
        (fun α => match α with | Bool α0 => Some α0 | _ => None end)
        (fun β α => match α with | Bool _ => Some (Bool β) | _ => None end).
    
    Definition Get_Number_0 :=
      Ref.map
        (fun α => match α with | Number α0 => Some α0 | _ => None end)
        (fun β α => match α with | Number _ => Some (Number β) | _ => None end).
    
    Definition Get_String_0 :=
      Ref.map
        (fun α => match α with | String α0 => Some α0 | _ => None end)
        (fun β α => match α with | String _ => Some (String β) | _ => None end).
    
    Definition Get_Array_0 :=
      Ref.map
        (fun α => match α with | Array α0 => Some α0 | _ => None end)
        (fun β α => match α with | Array _ => Some (Array β) | _ => None end).
    
    Definition Get_Object_0 :=
      Ref.map
        (fun α => match α with | Object α0 => Some α0 | _ => None end)
        (fun β α => match α with | Object _ => Some (Object β) | _ => None end).
  End Value.
  
  Module  Impl_core_clone_Clone_for_serde_json_value_Value_t.
  Section Impl_core_clone_Clone_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M serde_json.value.Value.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_serde_json_value_Value_t.
  End Impl_core_clone_Clone_for_serde_json_value_Value_t.
  
  Module  Impl_core_marker_StructuralEq_for_serde_json_value_Value_t.
  Section Impl_core_marker_StructuralEq_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralEq_for_serde_json_value_Value_t.
  End Impl_core_marker_StructuralEq_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_Eq_for_serde_json_value_Value_t.
  Section Impl_core_cmp_Eq_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
    Eq
    *)
    Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_assert_receiver_is_total_eq :
      Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
      Notations.double_colon := assert_receiver_is_total_eq;
    }.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq :=
        Datatypes.Some assert_receiver_is_total_eq;
    }.
  End Impl_core_cmp_Eq_for_serde_json_value_Value_t.
  End Impl_core_cmp_Eq_for_serde_json_value_Value_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_serde_json_value_Value_t.
  Section Impl_core_marker_StructuralPartialEq_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_serde_json_value_Value_t.
  End Impl_core_marker_StructuralPartialEq_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_for_serde_json_value_Value_t.
  
  Module  Impl_core_fmt_Debug_for_serde_json_value_Value_t.
  Section Impl_core_fmt_Debug_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Value::Null => formatter.write_str("Null"),
                Value::Bool(boolean) => write!(formatter, "Bool({})", boolean),
                Value::Number(number) => Debug::fmt(number, formatter),
                Value::String(string) => write!(formatter, "String({:?})", string),
                Value::Array(vec) => {
                    tri!(formatter.write_str("Array "));
                    Debug::fmt(vec, formatter)
                }
                Value::Object(map) => {
                    tri!(formatter.write_str("Object "));
                    Debug::fmt(map, formatter)
                }
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (formatter : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* formatter := M.alloc formatter in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_serde_json_value_Value_t.
  End Impl_core_fmt_Debug_for_serde_json_value_Value_t.
  
  Module  Impl_core_fmt_Display_for_serde_json_value_Value_t.
  Section Impl_core_fmt_Display_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            struct WriterFormatter<'a, 'b: 'a> {
                inner: &'a mut fmt::Formatter<'b>,
            }
    
            impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {
                fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                    // Safety: the serializer below only emits valid utf8 when using
                    // the default formatter.
                    let s = unsafe { str::from_utf8_unchecked(buf) };
                    tri!(self.inner.write_str(s).map_err(io_error));
                    Ok(buf.len())
                }
    
                fn flush(&mut self) -> io::Result<()> {
                    Ok(())
                }
            }
    
            fn io_error(_: fmt::Error) -> io::Error {
                // Error value does not matter because Display impl just maps it
                // back to fmt::Error.
                io::Error::new(io::ErrorKind::Other, "fmt error")
            }
    
            let alternate = f.alternate();
            let mut wr = WriterFormatter { inner: f };
            if alternate {
                // {:#}
                super::ser::to_writer_pretty(&mut wr, self).map_err(|_| fmt::Error)
            } else {
                // {}
                super::ser::to_writer(&mut wr, self).map_err(|_| fmt::Error)
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_serde_json_value_Value_t.
  End Impl_core_fmt_Display_for_serde_json_value_Value_t.
  
  (*
  fn parse_index(s: &str) -> Option<usize> {
      if s.starts_with('+') || (s.starts_with('0') && s.len() != 1) {
          return None;
      }
      s.parse().ok()
  }
  *)
  Definition parse_index (s : ref str.t) : M (core.option.Option.t usize.t) :=
    let* s := M.alloc s in
    M.read foo.
  
  Module  Impl_serde_json_value_Value_t.
  Section Impl_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        pub fn get<I: Index>(&self, index: I) -> Option<&Value> {
            index.index_into(self)
        }
    *)
    Definition get
        {I : Set}
        {ℋ_0 : serde_json.value.index.Index.Trait I}
        (self : ref Self)
        (index : I)
        : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* index := M.alloc index in
      M.read foo.
    
    Global Instance AssociatedFunction_get
        {I : Set}
        {ℋ_0 : serde_json.value.index.Index.Trait I} :
      Notations.DoubleColon Self "get" := {
      Notations.double_colon := get (I := I);
    }.
    
    (*
        pub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value> {
            index.index_into_mut(self)
        }
    *)
    Definition get_mut
        {I : Set}
        {ℋ_0 : serde_json.value.index.Index.Trait I}
        (self : mut_ref Self)
        (index : I)
        : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* index := M.alloc index in
      M.read foo.
    
    Global Instance AssociatedFunction_get_mut
        {I : Set}
        {ℋ_0 : serde_json.value.index.Index.Trait I} :
      Notations.DoubleColon Self "get_mut" := {
      Notations.double_colon := get_mut (I := I);
    }.
    
    (*
        pub fn is_object(&self) -> bool {
            self.as_object().is_some()
        }
    *)
    Definition is_object (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_object :
      Notations.DoubleColon Self "is_object" := {
      Notations.double_colon := is_object;
    }.
    
    (*
        pub fn as_object(&self) -> Option<&Map<String, Value>> {
            match self {
                Value::Object(map) => Some(map),
                _ => None,
            }
        }
    *)
    Definition as_object
        (self : ref Self)
        :
          M
            (core.option.Option.t
              (ref
                (serde_json.map.Map.t
                  alloc.string.String.t
                  serde_json.value.Value.t))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_object :
      Notations.DoubleColon Self "as_object" := {
      Notations.double_colon := as_object;
    }.
    
    (*
        pub fn as_object_mut(&mut self) -> Option<&mut Map<String, Value>> {
            match self {
                Value::Object(map) => Some(map),
                _ => None,
            }
        }
    *)
    Definition as_object_mut
        (self : mut_ref Self)
        :
          M
            (core.option.Option.t
              (mut_ref
                (serde_json.map.Map.t
                  alloc.string.String.t
                  serde_json.value.Value.t))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_object_mut :
      Notations.DoubleColon Self "as_object_mut" := {
      Notations.double_colon := as_object_mut;
    }.
    
    (*
        pub fn is_array(&self) -> bool {
            self.as_array().is_some()
        }
    *)
    Definition is_array (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_array :
      Notations.DoubleColon Self "is_array" := {
      Notations.double_colon := is_array;
    }.
    
    (*
        pub fn as_array(&self) -> Option<&Vec<Value>> {
            match self {
                Value::Array(array) => Some(array),
                _ => None,
            }
        }
    *)
    Definition as_array
        (self : ref Self)
        :
          M
            (core.option.Option.t
              (ref
                (alloc.vec.Vec.t
                  serde_json.value.Value.t
                  alloc.vec.Vec.Default.A))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_array :
      Notations.DoubleColon Self "as_array" := {
      Notations.double_colon := as_array;
    }.
    
    (*
        pub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>> {
            match self {
                Value::Array(list) => Some(list),
                _ => None,
            }
        }
    *)
    Definition as_array_mut
        (self : mut_ref Self)
        :
          M
            (core.option.Option.t
              (mut_ref
                (alloc.vec.Vec.t
                  serde_json.value.Value.t
                  alloc.vec.Vec.Default.A))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_array_mut :
      Notations.DoubleColon Self "as_array_mut" := {
      Notations.double_colon := as_array_mut;
    }.
    
    (*
        pub fn is_string(&self) -> bool {
            self.as_str().is_some()
        }
    *)
    Definition is_string (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_string :
      Notations.DoubleColon Self "is_string" := {
      Notations.double_colon := is_string;
    }.
    
    (*
        pub fn as_str(&self) -> Option<&str> {
            match self {
                Value::String(s) => Some(s),
                _ => None,
            }
        }
    *)
    Definition as_str
        (self : ref Self)
        : M (core.option.Option.t (ref str.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_str :
      Notations.DoubleColon Self "as_str" := {
      Notations.double_colon := as_str;
    }.
    
    (*
        pub fn is_number(&self) -> bool {
            match *self {
                Value::Number(_) => true,
                _ => false,
            }
        }
    *)
    Definition is_number (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_number :
      Notations.DoubleColon Self "is_number" := {
      Notations.double_colon := is_number;
    }.
    
    (*
        pub fn as_number(&self) -> Option<&Number> {
            match self {
                Value::Number(number) => Some(number),
                _ => None,
            }
        }
    *)
    Definition as_number
        (self : ref Self)
        : M (core.option.Option.t (ref serde_json.number.Number.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_number :
      Notations.DoubleColon Self "as_number" := {
      Notations.double_colon := as_number;
    }.
    
    (*
        pub fn is_i64(&self) -> bool {
            match self {
                Value::Number(n) => n.is_i64(),
                _ => false,
            }
        }
    *)
    Definition is_i64 (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_i64 :
      Notations.DoubleColon Self "is_i64" := {
      Notations.double_colon := is_i64;
    }.
    
    (*
        pub fn is_u64(&self) -> bool {
            match self {
                Value::Number(n) => n.is_u64(),
                _ => false,
            }
        }
    *)
    Definition is_u64 (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_u64 :
      Notations.DoubleColon Self "is_u64" := {
      Notations.double_colon := is_u64;
    }.
    
    (*
        pub fn is_f64(&self) -> bool {
            match self {
                Value::Number(n) => n.is_f64(),
                _ => false,
            }
        }
    *)
    Definition is_f64 (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_f64 :
      Notations.DoubleColon Self "is_f64" := {
      Notations.double_colon := is_f64;
    }.
    
    (*
        pub fn as_i64(&self) -> Option<i64> {
            match self {
                Value::Number(n) => n.as_i64(),
                _ => None,
            }
        }
    *)
    Definition as_i64 (self : ref Self) : M (core.option.Option.t i64.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_i64 :
      Notations.DoubleColon Self "as_i64" := {
      Notations.double_colon := as_i64;
    }.
    
    (*
        pub fn as_u64(&self) -> Option<u64> {
            match self {
                Value::Number(n) => n.as_u64(),
                _ => None,
            }
        }
    *)
    Definition as_u64 (self : ref Self) : M (core.option.Option.t u64.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_u64 :
      Notations.DoubleColon Self "as_u64" := {
      Notations.double_colon := as_u64;
    }.
    
    (*
        pub fn as_f64(&self) -> Option<f64> {
            match self {
                Value::Number(n) => n.as_f64(),
                _ => None,
            }
        }
    *)
    Definition as_f64 (self : ref Self) : M (core.option.Option.t f64.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_f64 :
      Notations.DoubleColon Self "as_f64" := {
      Notations.double_colon := as_f64;
    }.
    
    (*
        pub fn is_boolean(&self) -> bool {
            self.as_bool().is_some()
        }
    *)
    Definition is_boolean (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_boolean :
      Notations.DoubleColon Self "is_boolean" := {
      Notations.double_colon := is_boolean;
    }.
    
    (*
        pub fn as_bool(&self) -> Option<bool> {
            match *self {
                Value::Bool(b) => Some(b),
                _ => None,
            }
        }
    *)
    Definition as_bool (self : ref Self) : M (core.option.Option.t bool.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_bool :
      Notations.DoubleColon Self "as_bool" := {
      Notations.double_colon := as_bool;
    }.
    
    (*
        pub fn is_null(&self) -> bool {
            self.as_null().is_some()
        }
    *)
    Definition is_null (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_null :
      Notations.DoubleColon Self "is_null" := {
      Notations.double_colon := is_null;
    }.
    
    (*
        pub fn as_null(&self) -> Option<()> {
            match *self {
                Value::Null => Some(()),
                _ => None,
            }
        }
    *)
    Definition as_null (self : ref Self) : M (core.option.Option.t unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_null :
      Notations.DoubleColon Self "as_null" := {
      Notations.double_colon := as_null;
    }.
    
    (*
        pub fn pointer(&self, pointer: &str) -> Option<&Value> {
            if pointer.is_empty() {
                return Some(self);
            }
            if !pointer.starts_with('/') {
                return None;
            }
            pointer
                .split('/')
                .skip(1)
                .map(|x| x.replace("~1", "/").replace("~0", "~"))
                .try_fold(self, |target, token| match target {
                    Value::Object(map) => map.get(&token),
                    Value::Array(list) => parse_index(&token).and_then(|x| list.get(x)),
                    _ => None,
                })
        }
    *)
    Definition pointer
        (self : ref Self)
        (pointer : ref str.t)
        : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* pointer := M.alloc pointer in
      M.read foo.
    
    Global Instance AssociatedFunction_pointer :
      Notations.DoubleColon Self "pointer" := {
      Notations.double_colon := pointer;
    }.
    
    (*
        pub fn pointer_mut(&mut self, pointer: &str) -> Option<&mut Value> {
            if pointer.is_empty() {
                return Some(self);
            }
            if !pointer.starts_with('/') {
                return None;
            }
            pointer
                .split('/')
                .skip(1)
                .map(|x| x.replace("~1", "/").replace("~0", "~"))
                .try_fold(self, |target, token| match target {
                    Value::Object(map) => map.get_mut(&token),
                    Value::Array(list) => parse_index(&token).and_then(move |x| list.get_mut(x)),
                    _ => None,
                })
        }
    *)
    Definition pointer_mut
        (self : mut_ref Self)
        (pointer : ref str.t)
        : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* pointer := M.alloc pointer in
      M.read foo.
    
    Global Instance AssociatedFunction_pointer_mut :
      Notations.DoubleColon Self "pointer_mut" := {
      Notations.double_colon := pointer_mut;
    }.
    
    (*
        pub fn take(&mut self) -> Value {
            mem::replace(self, Value::Null)
        }
    *)
    Definition take (self : mut_ref Self) : M serde_json.value.Value.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_take :
      Notations.DoubleColon Self "take" := {
      Notations.double_colon := take;
    }.
  End Impl_serde_json_value_Value_t.
  End Impl_serde_json_value_Value_t.
  
  Module  Impl_core_default_Default_for_serde_json_value_Value_t.
  Section Impl_core_default_Default_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn default() -> Value {
            Value::Null
        }
    *)
    Definition default : M serde_json.value.Value.t := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_serde_json_value_Value_t.
  End Impl_core_default_Default_for_serde_json_value_Value_t.
  
  Module de.
    Module  Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
    Section Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>
          where
              D: serde::Deserializer<'de>,
          {
              struct ValueVisitor;
      
              impl<'de> Visitor<'de> for ValueVisitor {
                  type Value = Value;
      
                  fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                      formatter.write_str("any valid JSON value")
                  }
      
                  #[inline]
                  fn visit_bool<E>(self, value: bool) -> Result<Value, E> {
                      Ok(Value::Bool(value))
                  }
      
                  #[inline]
                  fn visit_i64<E>(self, value: i64) -> Result<Value, E> {
                      Ok(Value::Number(value.into()))
                  }
      
                  #[inline]
                  fn visit_u64<E>(self, value: u64) -> Result<Value, E> {
                      Ok(Value::Number(value.into()))
                  }
      
                  #[inline]
                  fn visit_f64<E>(self, value: f64) -> Result<Value, E> {
                      Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))
                  }
      
                  #[cfg(any(feature = "std", feature = "alloc"))]
                  #[inline]
                  fn visit_str<E>(self, value: &str) -> Result<Value, E>
                  where
                      E: serde::de::Error,
                  {
                      self.visit_string(String::from(value))
                  }
      
                  #[cfg(any(feature = "std", feature = "alloc"))]
                  #[inline]
                  fn visit_string<E>(self, value: String) -> Result<Value, E> {
                      Ok(Value::String(value))
                  }
      
                  #[inline]
                  fn visit_none<E>(self) -> Result<Value, E> {
                      Ok(Value::Null)
                  }
      
                  #[inline]
                  fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>
                  where
                      D: serde::Deserializer<'de>,
                  {
                      Deserialize::deserialize(deserializer)
                  }
      
                  #[inline]
                  fn visit_unit<E>(self) -> Result<Value, E> {
                      Ok(Value::Null)
                  }
      
                  #[inline]
                  fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>
                  where
                      V: SeqAccess<'de>,
                  {
                      let mut vec = Vec::new();
      
                      while let Some(elem) = tri!(visitor.next_element()) {
                          vec.push(elem);
                      }
      
                      Ok(Value::Array(vec))
                  }
      
                  #[cfg(any(feature = "std", feature = "alloc"))]
                  fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>
                  where
                      V: MapAccess<'de>,
                  {
                      match tri!(visitor.next_key_seed(KeyClassifier)) {
                          #[cfg(feature = "arbitrary_precision")]
                          Some(KeyClass::Number) => {
                              let number: NumberFromString = tri!(visitor.next_value());
                              Ok(Value::Number(number.value))
                          }
                          #[cfg(feature = "raw_value")]
                          Some(KeyClass::RawValue) => {
                              let value = tri!(visitor.next_value_seed(crate::raw::BoxedFromString));
                              crate::from_str(value.get()).map_err(de::Error::custom)
                          }
                          Some(KeyClass::Map(first_key)) => {
                              let mut values = Map::new();
      
                              values.insert(first_key, tri!(visitor.next_value()));
                              while let Some((key, value)) = tri!(visitor.next_entry()) {
                                  values.insert(key, value);
                              }
      
                              Ok(Value::Object(values))
                          }
                          None => Ok(Value::Object(Map::new())),
                      }
                  }
              }
      
              deserializer.deserialize_any(ValueVisitor)
          }
      *)
      Definition deserialize
          {D : Set}
          {ℋ_0 : serde.de.Deserializer.Trait D}
          (deserializer : D)
          :
            M
              (core.result.Result.t
                serde_json.value.Value.t
                D::type["Error"].t) :=
        let* deserializer := M.alloc deserializer in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize
          {D : Set}
          {ℋ_0 : serde.de.Deserializer.Trait D} :
        Notations.DoubleColon Self "deserialize" := {
        Notations.double_colon := deserialize (D := D);
      }.
      
      Global Instance ℐ : serde.de.Deserialize.Required.Trait Self := {
        serde.de.Deserialize.deserialize
          {D : Set}
          {ℋ_0 : serde.de.Deserializer.Trait D} :=
          deserialize (D := D);
        serde.de.Deserialize.deserialize_in_place := Datatypes.None;
      }.
    End Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
    End Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
    
    Module  Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
    Section Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          type Err = Error;
      *)
      Definition Err : Set := serde_json.error.Error.t.
      
      (*
          fn from_str(s: &str) -> Result<Value, Error> {
              super::super::de::from_str(s)
          }
      *)
      Definition from_str
          (s : ref str.t)
          :
            M
              (core.result.Result.t
                serde_json.value.Value.t
                serde_json.error.Error.t) :=
        let* s := M.alloc s in
        M.read foo.
      
      Global Instance AssociatedFunction_from_str :
        Notations.DoubleColon Self "from_str" := {
        Notations.double_colon := from_str;
      }.
      
      Global Instance ℐ : core.str.traits.FromStr.Trait Self := {
        core.str.traits.FromStr.Err := Err;
        core.str.traits.FromStr.from_str := from_str;
      }.
    End Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
    End Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
    
    (*
    fn visit_array<'de, V>(array: Vec<Value>, visitor: V) -> Result<V::Value, Error>
    where
        V: Visitor<'de>,
    {
        let len = array.len();
        let mut deserializer = SeqDeserializer::new(array);
        let seq = tri!(visitor.visit_seq(&mut deserializer));
        let remaining = deserializer.iter.len();
        if remaining == 0 {
            Ok(seq)
        } else {
            Err(serde::de::Error::invalid_length(
                len,
                &"fewer elements in array",
            ))
        }
    }
    *)
    Definition visit_array
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (array_
          :
          alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* array_ := M.alloc array_ in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    (*
    fn visit_object<'de, V>(object: Map<String, Value>, visitor: V) -> Result<V::Value, Error>
    where
        V: Visitor<'de>,
    {
        let len = object.len();
        let mut deserializer = MapDeserializer::new(object);
        let map = tri!(visitor.visit_map(&mut deserializer));
        let remaining = deserializer.iter.len();
        if remaining == 0 {
            Ok(map)
        } else {
            Err(serde::de::Error::invalid_length(
                len,
                &"fewer elements in map",
            ))
        }
    }
    *)
    Definition visit_object
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (object
          :
          serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* object := M.alloc object in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Module  Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
    Section Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Null => visitor.visit_unit(),
                  Value::Bool(v) => visitor.visit_bool(v),
                  Value::Number(n) => n.deserialize_any(visitor),
                  #[cfg(any(feature = "std", feature = "alloc"))]
                  Value::String(v) => visitor.visit_string(v),
                  Value::Array(v) => visit_array(v, visitor),
                  Value::Object(v) => visit_object(v, visitor),
              }
          }
      *)
      Definition deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_any" := {
        Notations.double_colon := deserialize_any (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i8" := {
        Notations.double_colon := deserialize_i8 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i16" := {
        Notations.double_colon := deserialize_i16 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i32" := {
        Notations.double_colon := deserialize_i32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i64" := {
        Notations.double_colon := deserialize_i64 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i128" := {
        Notations.double_colon := deserialize_i128 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u8" := {
        Notations.double_colon := deserialize_u8 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u16" := {
        Notations.double_colon := deserialize_u16 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u32" := {
        Notations.double_colon := deserialize_u32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u64" := {
        Notations.double_colon := deserialize_u64 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u128" := {
        Notations.double_colon := deserialize_u128 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f32" := {
        Notations.double_colon := deserialize_f32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f64" := {
        Notations.double_colon := deserialize_f64 (V := V);
      }.
      
      (*
          fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Null => visitor.visit_none(),
                  _ => visitor.visit_some(self),
              }
          }
      *)
      Definition deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_option" := {
        Notations.double_colon := deserialize_option (V := V);
      }.
      
      (*
          fn deserialize_enum<V>(
              self,
              _name: &str,
              _variants: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let (variant, value) = match self {
                  Value::Object(value) => {
                      let mut iter = value.into_iter();
                      let (variant, value) = match iter.next() {
                          Some(v) => v,
                          None => {
                              return Err(serde::de::Error::invalid_value(
                                  Unexpected::Map,
                                  &"map with a single key",
                              ));
                          }
                      };
                      // enums are encoded in json as maps with a single key:value pair
                      if iter.next().is_some() {
                          return Err(serde::de::Error::invalid_value(
                              Unexpected::Map,
                              &"map with a single key",
                          ));
                      }
                      (variant, Some(value))
                  }
                  Value::String(variant) => (variant, None),
                  other => {
                      return Err(serde::de::Error::invalid_type(
                          other.unexpected(),
                          &"string or map",
                      ));
                  }
              };
      
              visitor.visit_enum(EnumDeserializer { variant, value })
          }
      *)
      Definition deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_variants : ref (slice (ref str.t)))
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variants := M.alloc _variants in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_enum" := {
        Notations.double_colon := deserialize_enum (V := V);
      }.
      
      (*
          fn deserialize_newtype_struct<V>(
              self,
              name: &'static str,
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              #[cfg(feature = "raw_value")]
              {
                  if name == crate::raw::TOKEN {
                      return visitor.visit_map(crate::raw::OwnedRawDeserializer {
                          raw_value: Some(self.to_string()),
                      });
                  }
              }
      
              let _ = name;
              visitor.visit_newtype_struct(self)
          }
      *)
      Definition deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_newtype_struct" := {
        Notations.double_colon := deserialize_newtype_struct (V := V);
      }.
      
      (*
          fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Bool(v) => visitor.visit_bool(v),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bool" := {
        Notations.double_colon := deserialize_bool (V := V);
      }.
      
      (*
          fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_string(visitor)
          }
      *)
      Definition deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_char" := {
        Notations.double_colon := deserialize_char (V := V);
      }.
      
      (*
          fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_string(visitor)
          }
      *)
      Definition deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_str" := {
        Notations.double_colon := deserialize_str (V := V);
      }.
      
      (*
          fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  #[cfg(any(feature = "std", feature = "alloc"))]
                  Value::String(v) => visitor.visit_string(v),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_string" := {
        Notations.double_colon := deserialize_string (V := V);
      }.
      
      (*
          fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_byte_buf(visitor)
          }
      *)
      Definition deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bytes" := {
        Notations.double_colon := deserialize_bytes (V := V);
      }.
      
      (*
          fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  #[cfg(any(feature = "std", feature = "alloc"))]
                  Value::String(v) => visitor.visit_string(v),
                  Value::Array(v) => visit_array(v, visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_byte_buf" := {
        Notations.double_colon := deserialize_byte_buf (V := V);
      }.
      
      (*
          fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Null => visitor.visit_unit(),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit" := {
        Notations.double_colon := deserialize_unit (V := V);
      }.
      
      (*
          fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_unit(visitor)
          }
      *)
      Definition deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit_struct" := {
        Notations.double_colon := deserialize_unit_struct (V := V);
      }.
      
      (*
          fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Array(v) => visit_array(v, visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_seq" := {
        Notations.double_colon := deserialize_seq (V := V);
      }.
      
      (*
          fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_seq(visitor)
          }
      *)
      Definition deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_len : usize.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple" := {
        Notations.double_colon := deserialize_tuple (V := V);
      }.
      
      (*
          fn deserialize_tuple_struct<V>(
              self,
              _name: &'static str,
              _len: usize,
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_seq(visitor)
          }
      *)
      Definition deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_len : usize.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _len := M.alloc _len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple_struct" := {
        Notations.double_colon := deserialize_tuple_struct (V := V);
      }.
      
      (*
          fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Object(v) => visit_object(v, visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_map" := {
        Notations.double_colon := deserialize_map (V := V);
      }.
      
      (*
          fn deserialize_struct<V>(
              self,
              _name: &'static str,
              _fields: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Array(v) => visit_array(v, visitor),
                  Value::Object(v) => visit_object(v, visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_fields : ref (slice (ref str.t)))
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _fields := M.alloc _fields in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_struct" := {
        Notations.double_colon := deserialize_struct (V := V);
      }.
      
      (*
          fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_string(visitor)
          }
      *)
      Definition deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_identifier" := {
        Notations.double_colon := deserialize_identifier (V := V);
      }.
      
      (*
          fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              drop(self);
              visitor.visit_unit()
          }
      *)
      Definition deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_ignored_any" := {
        Notations.double_colon := deserialize_ignored_any (V := V);
      }.
      
      Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
        serde.de.Deserializer.Error := Error;
        serde.de.Deserializer.deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_any (V := V);
        serde.de.Deserializer.deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i8 (V := V);
        serde.de.Deserializer.deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i16 (V := V);
        serde.de.Deserializer.deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i32 (V := V);
        serde.de.Deserializer.deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i64 (V := V);
        serde.de.Deserializer.deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_i128 (V := V));
        serde.de.Deserializer.deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u8 (V := V);
        serde.de.Deserializer.deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u16 (V := V);
        serde.de.Deserializer.deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u32 (V := V);
        serde.de.Deserializer.deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u64 (V := V);
        serde.de.Deserializer.deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_u128 (V := V));
        serde.de.Deserializer.deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f32 (V := V);
        serde.de.Deserializer.deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f64 (V := V);
        serde.de.Deserializer.deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_option (V := V);
        serde.de.Deserializer.deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_enum (V := V);
        serde.de.Deserializer.deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_newtype_struct (V := V);
        serde.de.Deserializer.deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bool (V := V);
        serde.de.Deserializer.deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_char (V := V);
        serde.de.Deserializer.deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_str (V := V);
        serde.de.Deserializer.deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_string (V := V);
        serde.de.Deserializer.deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bytes (V := V);
        serde.de.Deserializer.deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_byte_buf (V := V);
        serde.de.Deserializer.deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit (V := V);
        serde.de.Deserializer.deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit_struct (V := V);
        serde.de.Deserializer.deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_seq (V := V);
        serde.de.Deserializer.deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple (V := V);
        serde.de.Deserializer.deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple_struct (V := V);
        serde.de.Deserializer.deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_map (V := V);
        serde.de.Deserializer.deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_struct (V := V);
        serde.de.Deserializer.deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_identifier (V := V);
        serde.de.Deserializer.deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_ignored_any (V := V);
        serde.de.Deserializer.is_human_readable := Datatypes.None;
        serde.de.Deserializer.__deserialize_content := Datatypes.None;
      }.
    End Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
    End Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
    
    Module  EnumDeserializer.
    Section EnumDeserializer.
      Record t : Set := {
        variant : alloc.string.String.t;
        value : core.option.Option.t serde_json.value.Value.t;
      }.
      
      Definition Get_variant :=
        Ref.map
          (fun α => Some α.(variant))
          (fun β α => Some (α <| variant := β |>)).
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End EnumDeserializer.
    End EnumDeserializer.
    
    Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
    Section Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
      Definition Self : Set := serde_json.value.de.EnumDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          type Variant = VariantDeserializer;
      *)
      Definition Variant : Set := serde_json.value.de.VariantDeserializer.t.
      
      (*
          fn variant_seed<V>(self, seed: V) -> Result<(V::Value, VariantDeserializer), Error>
          where
              V: DeserializeSeed<'de>,
          {
              let variant = self.variant.into_deserializer();
              let visitor = VariantDeserializer { value: self.value };
              seed.deserialize(variant).map(|v| (v, visitor))
          }
      *)
      Definition variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V}
          (self : Self)
          (seed : V)
          :
            M
              (core.result.Result.t
                (V::type["Value"].t * serde_json.value.de.VariantDeserializer.t)
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
        Notations.DoubleColon Self "variant_seed" := {
        Notations.double_colon := variant_seed (V := V);
      }.
      
      Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
        serde.de.EnumAccess.Error := Error;
        serde.de.EnumAccess.Variant := Variant;
        serde.de.EnumAccess.variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
          variant_seed (V := V);
        serde.de.EnumAccess.variant := Datatypes.None;
      }.
    End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
    End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
    
    Module  Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
    Section Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          type Deserializer = Self;
      *)
      Definition Deserializer : Set := Self.
      
      (*
          fn into_deserializer(self) -> Self::Deserializer {
              self
          }
      *)
      Definition into_deserializer (self : Self) : M Deserializer :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_deserializer :
        Notations.DoubleColon Self "into_deserializer" := {
        Notations.double_colon := into_deserializer;
      }.
      
      Global Instance ℐ :
        serde.de.IntoDeserializer.Trait Self
          (E := serde_json.error.Error.t) := {
        serde.de.IntoDeserializer.Deserializer := Deserializer;
        serde.de.IntoDeserializer.into_deserializer := into_deserializer;
      }.
    End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
    End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
    
    Module  Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
    Section Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
          type Deserializer = Self;
      *)
      Definition Deserializer : Set := Self.
      
      (*
          fn into_deserializer(self) -> Self::Deserializer {
              self
          }
      *)
      Definition into_deserializer (self : Self) : M Deserializer :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_deserializer :
        Notations.DoubleColon Self "into_deserializer" := {
        Notations.double_colon := into_deserializer;
      }.
      
      Global Instance ℐ :
        serde.de.IntoDeserializer.Trait Self
          (E := serde_json.error.Error.t) := {
        serde.de.IntoDeserializer.Deserializer := Deserializer;
        serde.de.IntoDeserializer.into_deserializer := into_deserializer;
      }.
    End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
    End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
    
    Module  VariantDeserializer.
    Section VariantDeserializer.
      Record t : Set := {
        value : core.option.Option.t serde_json.value.Value.t;
      }.
      
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End VariantDeserializer.
    End VariantDeserializer.
    
    Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
    Section Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
      Definition Self : Set := serde_json.value.de.VariantDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn unit_variant(self) -> Result<(), Error> {
              match self.value {
                  Some(value) => Deserialize::deserialize(value),
                  None => Ok(()),
              }
          }
      *)
      Definition unit_variant
          (self : Self)
          : M (core.result.Result.t unit serde_json.error.Error.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_unit_variant :
        Notations.DoubleColon Self "unit_variant" := {
        Notations.double_colon := unit_variant;
      }.
      
      (*
          fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.value {
                  Some(value) => seed.deserialize(value),
                  None => Err(serde::de::Error::invalid_type(
                      Unexpected::UnitVariant,
                      &"newtype variant",
                  )),
              }
          }
      *)
      Definition newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                T::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "newtype_variant_seed" := {
        Notations.double_colon := newtype_variant_seed (T := T);
      }.
      
      (*
          fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self.value {
                  Some(Value::Array(v)) => {
                      if v.is_empty() {
                          visitor.visit_unit()
                      } else {
                          visit_array(v, visitor)
                      }
                  }
                  Some(other) => Err(serde::de::Error::invalid_type(
                      other.unexpected(),
                      &"tuple variant",
                  )),
                  None => Err(serde::de::Error::invalid_type(
                      Unexpected::UnitVariant,
                      &"tuple variant",
                  )),
              }
          }
      *)
      Definition tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_len : usize.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "tuple_variant" := {
        Notations.double_colon := tuple_variant (V := V);
      }.
      
      (*
          fn struct_variant<V>(
              self,
              _fields: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self.value {
                  Some(Value::Object(v)) => visit_object(v, visitor),
                  Some(other) => Err(serde::de::Error::invalid_type(
                      other.unexpected(),
                      &"struct variant",
                  )),
                  None => Err(serde::de::Error::invalid_type(
                      Unexpected::UnitVariant,
                      &"struct variant",
                  )),
              }
          }
      *)
      Definition struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_fields : ref (slice (ref str.t)))
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _fields := M.alloc _fields in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "struct_variant" := {
        Notations.double_colon := struct_variant (V := V);
      }.
      
      Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
        serde.de.VariantAccess.Error := Error;
        serde.de.VariantAccess.unit_variant := unit_variant;
        serde.de.VariantAccess.newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          newtype_variant_seed (T := T);
        serde.de.VariantAccess.tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          tuple_variant (V := V);
        serde.de.VariantAccess.struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          struct_variant (V := V);
        serde.de.VariantAccess.newtype_variant := Datatypes.None;
      }.
    End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
    End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
    
    Module  SeqDeserializer.
    Section SeqDeserializer.
      Record t : Set := {
        iter :
          alloc.vec.into_iter.IntoIter.t
            serde_json.value.Value.t
            alloc.vec.into_iter.IntoIter.Default.A;
      }.
      
      Definition Get_iter :=
        Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
    End SeqDeserializer.
    End SeqDeserializer.
    
    Module  Impl_serde_json_value_de_SeqDeserializer_t.
    Section Impl_serde_json_value_de_SeqDeserializer_t.
      Definition Self : Set := serde_json.value.de.SeqDeserializer.t.
      
      (*
          fn new(vec: Vec<Value>) -> Self {
              SeqDeserializer {
                  iter: vec.into_iter(),
              }
          }
      *)
      Definition new
          (vec
            :
            alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A)
          : M Self :=
        let* vec := M.alloc vec in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_serde_json_value_de_SeqDeserializer_t.
    End Impl_serde_json_value_de_SeqDeserializer_t.
    
    Module  Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
    Section Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
      Definition Self : Set := serde_json.value.de.SeqDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.iter.next() {
                  Some(value) => seed.deserialize(value).map(Some),
                  None => Ok(None),
              }
          }
      *)
      Definition next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : mut_ref Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                (core.option.Option.t T::type["Value"].t)
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "next_element_seed" := {
        Notations.double_colon := next_element_seed (T := T);
      }.
      
      (*
          fn size_hint(&self) -> Option<usize> {
              match self.iter.size_hint() {
                  (lower, Some(upper)) if lower == upper => Some(upper),
                  _ => None,
              }
          }
      *)
      Definition size_hint
          (self : ref Self)
          : M (core.option.Option.t usize.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_size_hint :
        Notations.DoubleColon Self "size_hint" := {
        Notations.double_colon := size_hint;
      }.
      
      Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
        serde.de.SeqAccess.Error := Error;
        serde.de.SeqAccess.next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          next_element_seed (T := T);
        serde.de.SeqAccess.size_hint := Datatypes.Some size_hint;
        serde.de.SeqAccess.next_element := Datatypes.None;
      }.
    End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
    End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
    
    Module  MapDeserializer.
    Section MapDeserializer.
      Record t : Set := {
        iter :
          core.iter.traits.collect.IntoIterator.IntoIter
            (Self := serde_json.map.Map.t
              alloc.string.String.t
              serde_json.value.Value.t)
            (Trait := ltac:(refine _));
        value : core.option.Option.t serde_json.value.Value.t;
      }.
      
      Definition Get_iter :=
        Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End MapDeserializer.
    End MapDeserializer.
    
    Module  Impl_serde_json_value_de_MapDeserializer_t.
    Section Impl_serde_json_value_de_MapDeserializer_t.
      Definition Self : Set := serde_json.value.de.MapDeserializer.t.
      
      (*
          fn new(map: Map<String, Value>) -> Self {
              MapDeserializer {
                  iter: map.into_iter(),
                  value: None,
              }
          }
      *)
      Definition new
          (map
            :
            serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
          : M Self :=
        let* map := M.alloc map in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_serde_json_value_de_MapDeserializer_t.
    End Impl_serde_json_value_de_MapDeserializer_t.
    
    Module  Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
    Section Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
      Definition Self : Set := serde_json.value.de.MapDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.iter.next() {
                  Some((key, value)) => {
                      self.value = Some(value);
                      let key_de = MapKeyDeserializer {
                          key: Cow::Owned(key),
                      };
                      seed.deserialize(key_de).map(Some)
                  }
                  None => Ok(None),
              }
          }
      *)
      Definition next_key_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : mut_ref Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                (core.option.Option.t T::type["Value"].t)
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_key_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "next_key_seed" := {
        Notations.double_colon := next_key_seed (T := T);
      }.
      
      (*
          fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.value.take() {
                  Some(value) => seed.deserialize(value),
                  None => Err(serde::de::Error::custom("value is missing")),
              }
          }
      *)
      Definition next_value_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : mut_ref Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                T::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_value_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "next_value_seed" := {
        Notations.double_colon := next_value_seed (T := T);
      }.
      
      (*
          fn size_hint(&self) -> Option<usize> {
              match self.iter.size_hint() {
                  (lower, Some(upper)) if lower == upper => Some(upper),
                  _ => None,
              }
          }
      *)
      Definition size_hint
          (self : ref Self)
          : M (core.option.Option.t usize.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_size_hint :
        Notations.DoubleColon Self "size_hint" := {
        Notations.double_colon := size_hint;
      }.
      
      Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
        serde.de.MapAccess.Error := Error;
        serde.de.MapAccess.next_key_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          next_key_seed (T := T);
        serde.de.MapAccess.next_value_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          next_value_seed (T := T);
        serde.de.MapAccess.size_hint := Datatypes.Some size_hint;
        serde.de.MapAccess.next_entry_seed := Datatypes.None;
        serde.de.MapAccess.next_key := Datatypes.None;
        serde.de.MapAccess.next_value := Datatypes.None;
        serde.de.MapAccess.next_entry := Datatypes.None;
      }.
    End Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
    End Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
    
    (*
    fn visit_array_ref<'de, V>(array: &'de [Value], visitor: V) -> Result<V::Value, Error>
    where
        V: Visitor<'de>,
    {
        let len = array.len();
        let mut deserializer = SeqRefDeserializer::new(array);
        let seq = tri!(visitor.visit_seq(&mut deserializer));
        let remaining = deserializer.iter.len();
        if remaining == 0 {
            Ok(seq)
        } else {
            Err(serde::de::Error::invalid_length(
                len,
                &"fewer elements in array",
            ))
        }
    }
    *)
    Definition visit_array_ref
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (array_ : ref (slice serde_json.value.Value.t))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* array_ := M.alloc array_ in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    (*
    fn visit_object_ref<'de, V>(object: &'de Map<String, Value>, visitor: V) -> Result<V::Value, Error>
    where
        V: Visitor<'de>,
    {
        let len = object.len();
        let mut deserializer = MapRefDeserializer::new(object);
        let map = tri!(visitor.visit_map(&mut deserializer));
        let remaining = deserializer.iter.len();
        if remaining == 0 {
            Ok(map)
        } else {
            Err(serde::de::Error::invalid_length(
                len,
                &"fewer elements in map",
            ))
        }
    }
    *)
    Definition visit_object_ref
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (object
          :
          ref
            (serde_json.map.Map.t
              alloc.string.String.t
              serde_json.value.Value.t))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* object := M.alloc object in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Module  Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
    Section Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Null => visitor.visit_unit(),
                  Value::Bool(v) => visitor.visit_bool( *v),
                  Value::Number(n) => n.deserialize_any(visitor),
                  Value::String(v) => visitor.visit_borrowed_str(v),
                  Value::Array(v) => visit_array_ref(v, visitor),
                  Value::Object(v) => visit_object_ref(v, visitor),
              }
          }
      *)
      Definition deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_any" := {
        Notations.double_colon := deserialize_any (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i8" := {
        Notations.double_colon := deserialize_i8 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i16" := {
        Notations.double_colon := deserialize_i16 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i32" := {
        Notations.double_colon := deserialize_i32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i64" := {
        Notations.double_colon := deserialize_i64 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i128" := {
        Notations.double_colon := deserialize_i128 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u8" := {
        Notations.double_colon := deserialize_u8 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u16" := {
        Notations.double_colon := deserialize_u16 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u32" := {
        Notations.double_colon := deserialize_u32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u64" := {
        Notations.double_colon := deserialize_u64 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u128" := {
        Notations.double_colon := deserialize_u128 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f32" := {
        Notations.double_colon := deserialize_f32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  match self {
                      Value::Number(n) => n.deserialize_any(visitor),
                      _ => Err(self.invalid_type(&visitor)),
                  }
              }
      *)
      Definition deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f64" := {
        Notations.double_colon := deserialize_f64 (V := V);
      }.
      
      (*
          fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match *self {
                  Value::Null => visitor.visit_none(),
                  _ => visitor.visit_some(self),
              }
          }
      *)
      Definition deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_option" := {
        Notations.double_colon := deserialize_option (V := V);
      }.
      
      (*
          fn deserialize_enum<V>(
              self,
              _name: &str,
              _variants: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let (variant, value) = match self {
                  Value::Object(value) => {
                      let mut iter = value.into_iter();
                      let (variant, value) = match iter.next() {
                          Some(v) => v,
                          None => {
                              return Err(serde::de::Error::invalid_value(
                                  Unexpected::Map,
                                  &"map with a single key",
                              ));
                          }
                      };
                      // enums are encoded in json as maps with a single key:value pair
                      if iter.next().is_some() {
                          return Err(serde::de::Error::invalid_value(
                              Unexpected::Map,
                              &"map with a single key",
                          ));
                      }
                      (variant, Some(value))
                  }
                  Value::String(variant) => (variant, None),
                  other => {
                      return Err(serde::de::Error::invalid_type(
                          other.unexpected(),
                          &"string or map",
                      ));
                  }
              };
      
              visitor.visit_enum(EnumRefDeserializer { variant, value })
          }
      *)
      Definition deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_variants : ref (slice (ref str.t)))
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variants := M.alloc _variants in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_enum" := {
        Notations.double_colon := deserialize_enum (V := V);
      }.
      
      (*
          fn deserialize_newtype_struct<V>(
              self,
              name: &'static str,
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              #[cfg(feature = "raw_value")]
              {
                  if name == crate::raw::TOKEN {
                      return visitor.visit_map(crate::raw::OwnedRawDeserializer {
                          raw_value: Some(self.to_string()),
                      });
                  }
              }
      
              let _ = name;
              visitor.visit_newtype_struct(self)
          }
      *)
      Definition deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_newtype_struct" := {
        Notations.double_colon := deserialize_newtype_struct (V := V);
      }.
      
      (*
          fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match *self {
                  Value::Bool(v) => visitor.visit_bool(v),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bool" := {
        Notations.double_colon := deserialize_bool (V := V);
      }.
      
      (*
          fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_str(visitor)
          }
      *)
      Definition deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_char" := {
        Notations.double_colon := deserialize_char (V := V);
      }.
      
      (*
          fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::String(v) => visitor.visit_borrowed_str(v),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_str" := {
        Notations.double_colon := deserialize_str (V := V);
      }.
      
      (*
          fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_str(visitor)
          }
      *)
      Definition deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_string" := {
        Notations.double_colon := deserialize_string (V := V);
      }.
      
      (*
          fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::String(v) => visitor.visit_borrowed_str(v),
                  Value::Array(v) => visit_array_ref(v, visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bytes" := {
        Notations.double_colon := deserialize_bytes (V := V);
      }.
      
      (*
          fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_bytes(visitor)
          }
      *)
      Definition deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_byte_buf" := {
        Notations.double_colon := deserialize_byte_buf (V := V);
      }.
      
      (*
          fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match *self {
                  Value::Null => visitor.visit_unit(),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit" := {
        Notations.double_colon := deserialize_unit (V := V);
      }.
      
      (*
          fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_unit(visitor)
          }
      *)
      Definition deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit_struct" := {
        Notations.double_colon := deserialize_unit_struct (V := V);
      }.
      
      (*
          fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Array(v) => visit_array_ref(v, visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_seq" := {
        Notations.double_colon := deserialize_seq (V := V);
      }.
      
      (*
          fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_seq(visitor)
          }
      *)
      Definition deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_len : usize.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple" := {
        Notations.double_colon := deserialize_tuple (V := V);
      }.
      
      (*
          fn deserialize_tuple_struct<V>(
              self,
              _name: &'static str,
              _len: usize,
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_seq(visitor)
          }
      *)
      Definition deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_len : usize.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _len := M.alloc _len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple_struct" := {
        Notations.double_colon := deserialize_tuple_struct (V := V);
      }.
      
      (*
          fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Object(v) => visit_object_ref(v, visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_map" := {
        Notations.double_colon := deserialize_map (V := V);
      }.
      
      (*
          fn deserialize_struct<V>(
              self,
              _name: &'static str,
              _fields: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Array(v) => visit_array_ref(v, visitor),
                  Value::Object(v) => visit_object_ref(v, visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
      *)
      Definition deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_fields : ref (slice (ref str.t)))
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _fields := M.alloc _fields in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_struct" := {
        Notations.double_colon := deserialize_struct (V := V);
      }.
      
      (*
          fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_str(visitor)
          }
      *)
      Definition deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_identifier" := {
        Notations.double_colon := deserialize_identifier (V := V);
      }.
      
      (*
          fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_unit()
          }
      *)
      Definition deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_ignored_any" := {
        Notations.double_colon := deserialize_ignored_any (V := V);
      }.
      
      Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
        serde.de.Deserializer.Error := Error;
        serde.de.Deserializer.deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_any (V := V);
        serde.de.Deserializer.deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i8 (V := V);
        serde.de.Deserializer.deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i16 (V := V);
        serde.de.Deserializer.deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i32 (V := V);
        serde.de.Deserializer.deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i64 (V := V);
        serde.de.Deserializer.deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_i128 (V := V));
        serde.de.Deserializer.deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u8 (V := V);
        serde.de.Deserializer.deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u16 (V := V);
        serde.de.Deserializer.deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u32 (V := V);
        serde.de.Deserializer.deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u64 (V := V);
        serde.de.Deserializer.deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_u128 (V := V));
        serde.de.Deserializer.deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f32 (V := V);
        serde.de.Deserializer.deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f64 (V := V);
        serde.de.Deserializer.deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_option (V := V);
        serde.de.Deserializer.deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_enum (V := V);
        serde.de.Deserializer.deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_newtype_struct (V := V);
        serde.de.Deserializer.deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bool (V := V);
        serde.de.Deserializer.deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_char (V := V);
        serde.de.Deserializer.deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_str (V := V);
        serde.de.Deserializer.deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_string (V := V);
        serde.de.Deserializer.deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bytes (V := V);
        serde.de.Deserializer.deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_byte_buf (V := V);
        serde.de.Deserializer.deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit (V := V);
        serde.de.Deserializer.deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit_struct (V := V);
        serde.de.Deserializer.deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_seq (V := V);
        serde.de.Deserializer.deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple (V := V);
        serde.de.Deserializer.deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple_struct (V := V);
        serde.de.Deserializer.deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_map (V := V);
        serde.de.Deserializer.deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_struct (V := V);
        serde.de.Deserializer.deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_identifier (V := V);
        serde.de.Deserializer.deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_ignored_any (V := V);
        serde.de.Deserializer.is_human_readable := Datatypes.None;
        serde.de.Deserializer.__deserialize_content := Datatypes.None;
      }.
    End Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
    End Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
    
    Module  EnumRefDeserializer.
    Section EnumRefDeserializer.
      Record t : Set := {
        variant : ref str.t;
        value : core.option.Option.t (ref serde_json.value.Value.t);
      }.
      
      Definition Get_variant :=
        Ref.map
          (fun α => Some α.(variant))
          (fun β α => Some (α <| variant := β |>)).
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End EnumRefDeserializer.
    End EnumRefDeserializer.
    
    Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
    Section Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
      Definition Self : Set := serde_json.value.de.EnumRefDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          type Variant = VariantRefDeserializer<'de>;
      *)
      Definition Variant : Set := serde_json.value.de.VariantRefDeserializer.t.
      
      (*
          fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Error>
          where
              V: DeserializeSeed<'de>,
          {
              let variant = self.variant.into_deserializer();
              let visitor = VariantRefDeserializer { value: self.value };
              seed.deserialize(variant).map(|v| (v, visitor))
          }
      *)
      Definition variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V}
          (self : Self)
          (seed : V)
          :
            M
              (core.result.Result.t
                (V::type["Value"].t * Variant)
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
        Notations.DoubleColon Self "variant_seed" := {
        Notations.double_colon := variant_seed (V := V);
      }.
      
      Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
        serde.de.EnumAccess.Error := Error;
        serde.de.EnumAccess.Variant := Variant;
        serde.de.EnumAccess.variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
          variant_seed (V := V);
        serde.de.EnumAccess.variant := Datatypes.None;
      }.
    End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
    End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
    
    Module  VariantRefDeserializer.
    Section VariantRefDeserializer.
      Record t : Set := {
        value : core.option.Option.t (ref serde_json.value.Value.t);
      }.
      
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End VariantRefDeserializer.
    End VariantRefDeserializer.
    
    Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
    Section Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
      Definition Self : Set := serde_json.value.de.VariantRefDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn unit_variant(self) -> Result<(), Error> {
              match self.value {
                  Some(value) => Deserialize::deserialize(value),
                  None => Ok(()),
              }
          }
      *)
      Definition unit_variant
          (self : Self)
          : M (core.result.Result.t unit serde_json.error.Error.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_unit_variant :
        Notations.DoubleColon Self "unit_variant" := {
        Notations.double_colon := unit_variant;
      }.
      
      (*
          fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.value {
                  Some(value) => seed.deserialize(value),
                  None => Err(serde::de::Error::invalid_type(
                      Unexpected::UnitVariant,
                      &"newtype variant",
                  )),
              }
          }
      *)
      Definition newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                T::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "newtype_variant_seed" := {
        Notations.double_colon := newtype_variant_seed (T := T);
      }.
      
      (*
          fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self.value {
                  Some(Value::Array(v)) => {
                      if v.is_empty() {
                          visitor.visit_unit()
                      } else {
                          visit_array_ref(v, visitor)
                      }
                  }
                  Some(other) => Err(serde::de::Error::invalid_type(
                      other.unexpected(),
                      &"tuple variant",
                  )),
                  None => Err(serde::de::Error::invalid_type(
                      Unexpected::UnitVariant,
                      &"tuple variant",
                  )),
              }
          }
      *)
      Definition tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_len : usize.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "tuple_variant" := {
        Notations.double_colon := tuple_variant (V := V);
      }.
      
      (*
          fn struct_variant<V>(
              self,
              _fields: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self.value {
                  Some(Value::Object(v)) => visit_object_ref(v, visitor),
                  Some(other) => Err(serde::de::Error::invalid_type(
                      other.unexpected(),
                      &"struct variant",
                  )),
                  None => Err(serde::de::Error::invalid_type(
                      Unexpected::UnitVariant,
                      &"struct variant",
                  )),
              }
          }
      *)
      Definition struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_fields : ref (slice (ref str.t)))
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _fields := M.alloc _fields in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "struct_variant" := {
        Notations.double_colon := struct_variant (V := V);
      }.
      
      Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
        serde.de.VariantAccess.Error := Error;
        serde.de.VariantAccess.unit_variant := unit_variant;
        serde.de.VariantAccess.newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          newtype_variant_seed (T := T);
        serde.de.VariantAccess.tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          tuple_variant (V := V);
        serde.de.VariantAccess.struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          struct_variant (V := V);
        serde.de.VariantAccess.newtype_variant := Datatypes.None;
      }.
    End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
    End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
    
    Module  SeqRefDeserializer.
    Section SeqRefDeserializer.
      Record t : Set := {
        iter : core.slice.iter.Iter.t serde_json.value.Value.t;
      }.
      
      Definition Get_iter :=
        Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
    End SeqRefDeserializer.
    End SeqRefDeserializer.
    
    Module  Impl_serde_json_value_de_SeqRefDeserializer_t.
    Section Impl_serde_json_value_de_SeqRefDeserializer_t.
      Definition Self : Set := serde_json.value.de.SeqRefDeserializer.t.
      
      (*
          fn new(slice: &'de [Value]) -> Self {
              SeqRefDeserializer { iter: slice.iter() }
          }
      *)
      Definition new (slice : ref (slice serde_json.value.Value.t)) : M Self :=
        let* slice := M.alloc slice in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_serde_json_value_de_SeqRefDeserializer_t.
    End Impl_serde_json_value_de_SeqRefDeserializer_t.
    
    Module  Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
    Section Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
      Definition Self : Set := serde_json.value.de.SeqRefDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.iter.next() {
                  Some(value) => seed.deserialize(value).map(Some),
                  None => Ok(None),
              }
          }
      *)
      Definition next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : mut_ref Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                (core.option.Option.t T::type["Value"].t)
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "next_element_seed" := {
        Notations.double_colon := next_element_seed (T := T);
      }.
      
      (*
          fn size_hint(&self) -> Option<usize> {
              match self.iter.size_hint() {
                  (lower, Some(upper)) if lower == upper => Some(upper),
                  _ => None,
              }
          }
      *)
      Definition size_hint
          (self : ref Self)
          : M (core.option.Option.t usize.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_size_hint :
        Notations.DoubleColon Self "size_hint" := {
        Notations.double_colon := size_hint;
      }.
      
      Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
        serde.de.SeqAccess.Error := Error;
        serde.de.SeqAccess.next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          next_element_seed (T := T);
        serde.de.SeqAccess.size_hint := Datatypes.Some size_hint;
        serde.de.SeqAccess.next_element := Datatypes.None;
      }.
    End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
    End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
    
    Module  MapRefDeserializer.
    Section MapRefDeserializer.
      Record t : Set := {
        iter :
          core.iter.traits.collect.IntoIterator.IntoIter
            (Self := ref
              (serde_json.map.Map.t
                alloc.string.String.t
                serde_json.value.Value.t))
            (Trait := ltac:(refine _));
        value : core.option.Option.t (ref serde_json.value.Value.t);
      }.
      
      Definition Get_iter :=
        Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End MapRefDeserializer.
    End MapRefDeserializer.
    
    Module  Impl_serde_json_value_de_MapRefDeserializer_t.
    Section Impl_serde_json_value_de_MapRefDeserializer_t.
      Definition Self : Set := serde_json.value.de.MapRefDeserializer.t.
      
      (*
          fn new(map: &'de Map<String, Value>) -> Self {
              MapRefDeserializer {
                  iter: map.into_iter(),
                  value: None,
              }
          }
      *)
      Definition new
          (map
            :
            ref
              (serde_json.map.Map.t
                alloc.string.String.t
                serde_json.value.Value.t))
          : M Self :=
        let* map := M.alloc map in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_serde_json_value_de_MapRefDeserializer_t.
    End Impl_serde_json_value_de_MapRefDeserializer_t.
    
    Module  Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
    Section Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
      Definition Self : Set := serde_json.value.de.MapRefDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.iter.next() {
                  Some((key, value)) => {
                      self.value = Some(value);
                      let key_de = MapKeyDeserializer {
                          key: Cow::Borrowed(&**key),
                      };
                      seed.deserialize(key_de).map(Some)
                  }
                  None => Ok(None),
              }
          }
      *)
      Definition next_key_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : mut_ref Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                (core.option.Option.t T::type["Value"].t)
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_key_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "next_key_seed" := {
        Notations.double_colon := next_key_seed (T := T);
      }.
      
      (*
          fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.value.take() {
                  Some(value) => seed.deserialize(value),
                  None => Err(serde::de::Error::custom("value is missing")),
              }
          }
      *)
      Definition next_value_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : mut_ref Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                T::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_value_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "next_value_seed" := {
        Notations.double_colon := next_value_seed (T := T);
      }.
      
      (*
          fn size_hint(&self) -> Option<usize> {
              match self.iter.size_hint() {
                  (lower, Some(upper)) if lower == upper => Some(upper),
                  _ => None,
              }
          }
      *)
      Definition size_hint
          (self : ref Self)
          : M (core.option.Option.t usize.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_size_hint :
        Notations.DoubleColon Self "size_hint" := {
        Notations.double_colon := size_hint;
      }.
      
      Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
        serde.de.MapAccess.Error := Error;
        serde.de.MapAccess.next_key_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          next_key_seed (T := T);
        serde.de.MapAccess.next_value_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          next_value_seed (T := T);
        serde.de.MapAccess.size_hint := Datatypes.Some size_hint;
        serde.de.MapAccess.next_entry_seed := Datatypes.None;
        serde.de.MapAccess.next_key := Datatypes.None;
        serde.de.MapAccess.next_value := Datatypes.None;
        serde.de.MapAccess.next_entry := Datatypes.None;
      }.
    End Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
    End Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
    
    Module  MapKeyDeserializer.
    Section MapKeyDeserializer.
      Record t : Set := {
        key : alloc.borrow.Cow.t str.t;
      }.
      
      Definition Get_key :=
        Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
    End MapKeyDeserializer.
    End MapKeyDeserializer.
    
    Module  Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
    Section Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
      Definition Self : Set := serde_json.value.de.MapKeyDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              BorrowedCowStrDeserializer::new(self.key).deserialize_any(visitor)
          }
      *)
      Definition deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_any" := {
        Notations.double_colon := deserialize_any (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i8" := {
        Notations.double_colon := deserialize_i8 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i16" := {
        Notations.double_colon := deserialize_i16 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i32" := {
        Notations.double_colon := deserialize_i32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i64" := {
        Notations.double_colon := deserialize_i64 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u8" := {
        Notations.double_colon := deserialize_u8 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u16" := {
        Notations.double_colon := deserialize_u16 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u32" := {
        Notations.double_colon := deserialize_u32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u64" := {
        Notations.double_colon := deserialize_u64 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f32" := {
        Notations.double_colon := deserialize_f32 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f64" := {
        Notations.double_colon := deserialize_f64 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i128" := {
        Notations.double_colon := deserialize_i128 (V := V);
      }.
      
      (*
              fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
              where
                  V: Visitor<'de>,
              {
                  let mut de = crate::Deserializer::from_str(&self.key);
      
                  match tri!(de.peek()) {
                      Some(b'0'..=b'9' | b'-') => {}
                      _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                  }
      
                  let number = tri!(de.$using(visitor));
      
                  if tri!(de.peek()).is_some() {
                      return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                  }
      
                  Ok(number)
              }
      *)
      Definition deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u128" := {
        Notations.double_colon := deserialize_u128 (V := V);
      }.
      
      (*
          fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              if self.key == "true" {
                  visitor.visit_bool(true)
              } else if self.key == "false" {
                  visitor.visit_bool(false)
              } else {
                  Err(serde::de::Error::invalid_type(
                      Unexpected::Str(&self.key),
                      &visitor,
                  ))
              }
          }
      *)
      Definition deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bool" := {
        Notations.double_colon := deserialize_bool (V := V);
      }.
      
      (*
          fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              // Map keys cannot be null.
              visitor.visit_some(self)
          }
      *)
      Definition deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_option" := {
        Notations.double_colon := deserialize_option (V := V);
      }.
      
      (*
          fn deserialize_newtype_struct<V>(
              self,
              _name: &'static str,
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_newtype_struct(self)
          }
      *)
      Definition deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_newtype_struct" := {
        Notations.double_colon := deserialize_newtype_struct (V := V);
      }.
      
      (*
          fn deserialize_enum<V>(
              self,
              name: &'static str,
              variants: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.key
                  .into_deserializer()
                  .deserialize_enum(name, variants, visitor)
          }
      *)
      Definition deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (variants : ref (slice (ref str.t)))
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* variants := M.alloc variants in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_enum" := {
        Notations.double_colon := deserialize_enum (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_char" := {
        Notations.double_colon := deserialize_char (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_str" := {
        Notations.double_colon := deserialize_str (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_string" := {
        Notations.double_colon := deserialize_string (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bytes" := {
        Notations.double_colon := deserialize_bytes (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_byte_buf" := {
        Notations.double_colon := deserialize_byte_buf (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit" := {
        Notations.double_colon := deserialize_unit (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit_struct" := {
        Notations.double_colon := deserialize_unit_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_seq" := {
        Notations.double_colon := deserialize_seq (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple" := {
        Notations.double_colon := deserialize_tuple (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple_struct" := {
        Notations.double_colon := deserialize_tuple_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_map" := {
        Notations.double_colon := deserialize_map (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (fields : ref (slice (ref str.t)))
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* fields := M.alloc fields in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_struct" := {
        Notations.double_colon := deserialize_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_identifier" := {
        Notations.double_colon := deserialize_identifier (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_ignored_any" := {
        Notations.double_colon := deserialize_ignored_any (V := V);
      }.
      
      Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
        serde.de.Deserializer.Error := Error;
        serde.de.Deserializer.deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_any (V := V);
        serde.de.Deserializer.deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i8 (V := V);
        serde.de.Deserializer.deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i16 (V := V);
        serde.de.Deserializer.deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i32 (V := V);
        serde.de.Deserializer.deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i64 (V := V);
        serde.de.Deserializer.deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u8 (V := V);
        serde.de.Deserializer.deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u16 (V := V);
        serde.de.Deserializer.deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u32 (V := V);
        serde.de.Deserializer.deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u64 (V := V);
        serde.de.Deserializer.deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f32 (V := V);
        serde.de.Deserializer.deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f64 (V := V);
        serde.de.Deserializer.deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_i128 (V := V));
        serde.de.Deserializer.deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_u128 (V := V));
        serde.de.Deserializer.deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bool (V := V);
        serde.de.Deserializer.deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_option (V := V);
        serde.de.Deserializer.deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_newtype_struct (V := V);
        serde.de.Deserializer.deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_enum (V := V);
        serde.de.Deserializer.deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_char (V := V);
        serde.de.Deserializer.deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_str (V := V);
        serde.de.Deserializer.deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_string (V := V);
        serde.de.Deserializer.deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bytes (V := V);
        serde.de.Deserializer.deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_byte_buf (V := V);
        serde.de.Deserializer.deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit (V := V);
        serde.de.Deserializer.deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit_struct (V := V);
        serde.de.Deserializer.deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_seq (V := V);
        serde.de.Deserializer.deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple (V := V);
        serde.de.Deserializer.deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple_struct (V := V);
        serde.de.Deserializer.deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_map (V := V);
        serde.de.Deserializer.deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_struct (V := V);
        serde.de.Deserializer.deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_identifier (V := V);
        serde.de.Deserializer.deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_ignored_any (V := V);
        serde.de.Deserializer.is_human_readable := Datatypes.None;
        serde.de.Deserializer.__deserialize_content := Datatypes.None;
      }.
    End Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
    End Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
    
    Module  KeyClassifier.
    Section KeyClassifier.
      Inductive t : Set := Build.
    End KeyClassifier.
    End KeyClassifier.
    
    Module KeyClass.
      Inductive t : Set :=
      | Map (_ : alloc.string.String.t).
      
      Definition Get_Map_0 :=
        Ref.map
          (fun α => match α with | Map α0 => Some α0 end)
          (fun β α => match α with | Map _ => Some (Map β) end).
    End KeyClass.
    
    Module  Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
    Section Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
      Definition Self : Set := serde_json.value.de.KeyClassifier.t.
      
      (*
          type Value = KeyClass;
      *)
      Definition Value : Set := serde_json.value.de.KeyClass.t.
      
      (*
          fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
          where
              D: serde::Deserializer<'de>,
          {
              deserializer.deserialize_str(self)
          }
      *)
      Definition deserialize
          {D : Set}
          {ℋ_0 : serde.de.Deserializer.Trait D}
          (self : Self)
          (deserializer : D)
          : M (core.result.Result.t Value D::type["Error"].t) :=
        let* self := M.alloc self in
        let* deserializer := M.alloc deserializer in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize
          {D : Set}
          {ℋ_0 : serde.de.Deserializer.Trait D} :
        Notations.DoubleColon Self "deserialize" := {
        Notations.double_colon := deserialize (D := D);
      }.
      
      Global Instance ℐ : serde.de.DeserializeSeed.Trait Self := {
        serde.de.DeserializeSeed.Value := Value;
        serde.de.DeserializeSeed.deserialize
          {D : Set}
          {ℋ_0 : serde.de.Deserializer.Trait D} :=
          deserialize (D := D);
      }.
    End Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
    End Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
    
    Module  Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
    Section Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
      Definition Self : Set := serde_json.value.de.KeyClassifier.t.
      
      (*
          type Value = KeyClass;
      *)
      Definition Value : Set := serde_json.value.de.KeyClass.t.
      
      (*
          fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
              formatter.write_str("a string key")
          }
      *)
      Definition expecting
          (self : ref Self)
          (formatter : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* formatter := M.alloc formatter in
        M.read foo.
      
      Global Instance AssociatedFunction_expecting :
        Notations.DoubleColon Self "expecting" := {
        Notations.double_colon := expecting;
      }.
      
      (*
          fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>
          where
              E: de::Error,
          {
              match s {
                  #[cfg(feature = "arbitrary_precision")]
                  crate::number::TOKEN => Ok(KeyClass::Number),
                  #[cfg(feature = "raw_value")]
                  crate::raw::TOKEN => Ok(KeyClass::RawValue),
                  _ => Ok(KeyClass::Map(s.to_owned())),
              }
          }
      *)
      Definition visit_str
          {E : Set}
          {ℋ_0 : serde.de.Error.Trait E}
          (self : Self)
          (s : ref str.t)
          : M (core.result.Result.t Value E) :=
        let* self := M.alloc self in
        let* s := M.alloc s in
        M.read foo.
      
      Global Instance AssociatedFunction_visit_str
          {E : Set}
          {ℋ_0 : serde.de.Error.Trait E} :
        Notations.DoubleColon Self "visit_str" := {
        Notations.double_colon := visit_str (E := E);
      }.
      
      (*
          fn visit_string<E>(self, s: String) -> Result<Self::Value, E>
          where
              E: de::Error,
          {
              match s.as_str() {
                  #[cfg(feature = "arbitrary_precision")]
                  crate::number::TOKEN => Ok(KeyClass::Number),
                  #[cfg(feature = "raw_value")]
                  crate::raw::TOKEN => Ok(KeyClass::RawValue),
                  _ => Ok(KeyClass::Map(s)),
              }
          }
      *)
      Definition visit_string
          {E : Set}
          {ℋ_0 : serde.de.Error.Trait E}
          (self : Self)
          (s : alloc.string.String.t)
          : M (core.result.Result.t Value E) :=
        let* self := M.alloc self in
        let* s := M.alloc s in
        M.read foo.
      
      Global Instance AssociatedFunction_visit_string
          {E : Set}
          {ℋ_0 : serde.de.Error.Trait E} :
        Notations.DoubleColon Self "visit_string" := {
        Notations.double_colon := visit_string (E := E);
      }.
      
      Global Instance ℐ : serde.de.Visitor.Required.Trait Self := {
        serde.de.Visitor.Value := Value;
        serde.de.Visitor.expecting := expecting;
        serde.de.Visitor.visit_str {E : Set} {ℋ_0 : serde.de.Error.Trait E} :=
          Datatypes.Some (visit_str (E := E));
        serde.de.Visitor.visit_string
          {E : Set}
          {ℋ_0 : serde.de.Error.Trait E} :=
          Datatypes.Some (visit_string (E := E));
        serde.de.Visitor.visit_bool := Datatypes.None;
        serde.de.Visitor.visit_i8 := Datatypes.None;
        serde.de.Visitor.visit_i16 := Datatypes.None;
        serde.de.Visitor.visit_i32 := Datatypes.None;
        serde.de.Visitor.visit_i64 := Datatypes.None;
        serde.de.Visitor.visit_i128 := Datatypes.None;
        serde.de.Visitor.visit_u8 := Datatypes.None;
        serde.de.Visitor.visit_u16 := Datatypes.None;
        serde.de.Visitor.visit_u32 := Datatypes.None;
        serde.de.Visitor.visit_u64 := Datatypes.None;
        serde.de.Visitor.visit_u128 := Datatypes.None;
        serde.de.Visitor.visit_f32 := Datatypes.None;
        serde.de.Visitor.visit_f64 := Datatypes.None;
        serde.de.Visitor.visit_char := Datatypes.None;
        serde.de.Visitor.visit_borrowed_str := Datatypes.None;
        serde.de.Visitor.visit_bytes := Datatypes.None;
        serde.de.Visitor.visit_borrowed_bytes := Datatypes.None;
        serde.de.Visitor.visit_byte_buf := Datatypes.None;
        serde.de.Visitor.visit_none := Datatypes.None;
        serde.de.Visitor.visit_some := Datatypes.None;
        serde.de.Visitor.visit_unit := Datatypes.None;
        serde.de.Visitor.visit_newtype_struct := Datatypes.None;
        serde.de.Visitor.visit_seq := Datatypes.None;
        serde.de.Visitor.visit_map := Datatypes.None;
        serde.de.Visitor.visit_enum := Datatypes.None;
        serde.de.Visitor.__private_visit_untagged_option := Datatypes.None;
      }.
    End Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
    End Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
    
    Module  Impl_serde_json_value_Value_t_2.
    Section Impl_serde_json_value_Value_t_2.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn invalid_type<E>(&self, exp: &dyn Expected) -> E
          where
              E: serde::de::Error,
          {
              serde::de::Error::invalid_type(self.unexpected(), exp)
          }
      *)
      Definition invalid_type
          {E DynT : Set}
          {ℋ_0 : serde.de.Error.Trait E}
          {ℋ_1 : serde.de.Expected.Trait.Trait DynT}
          (self : ref Self)
          (exp : ref DynT)
          : M E :=
        let* self := M.alloc self in
        let* exp := M.alloc exp in
        M.read foo.
      
      Global Instance AssociatedFunction_invalid_type
          {E DynT : Set}
          {ℋ_0 : serde.de.Error.Trait E}
          {ℋ_1 : serde.de.Expected.Trait.Trait DynT} :
        Notations.DoubleColon Self "invalid_type" := {
        Notations.double_colon := invalid_type (E := E) (DynT := DynT);
      }.
      
      (*
          fn unexpected(&self) -> Unexpected {
              match self {
                  Value::Null => Unexpected::Unit,
                  Value::Bool(b) => Unexpected::Bool( *b),
                  Value::Number(n) => n.unexpected(),
                  Value::String(s) => Unexpected::Str(s),
                  Value::Array(_) => Unexpected::Seq,
                  Value::Object(_) => Unexpected::Map,
              }
          }
      *)
      Definition unexpected (self : ref Self) : M serde.de.Unexpected.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_unexpected :
        Notations.DoubleColon Self "unexpected" := {
        Notations.double_colon := unexpected;
      }.
    End Impl_serde_json_value_Value_t_2.
    End Impl_serde_json_value_Value_t_2.
    
    Module  BorrowedCowStrDeserializer.
    Section BorrowedCowStrDeserializer.
      Record t : Set := {
        value : alloc.borrow.Cow.t str.t;
      }.
      
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End BorrowedCowStrDeserializer.
    End BorrowedCowStrDeserializer.
    
    Module  Impl_serde_json_value_de_BorrowedCowStrDeserializer_t.
    Section Impl_serde_json_value_de_BorrowedCowStrDeserializer_t.
      Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
      
      (*
          fn new(value: Cow<'de, str>) -> Self {
              BorrowedCowStrDeserializer { value }
          }
      *)
      Definition new (value : alloc.borrow.Cow.t str.t) : M Self :=
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_serde_json_value_de_BorrowedCowStrDeserializer_t.
    End Impl_serde_json_value_de_BorrowedCowStrDeserializer_t.
    
    Module  Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
    Section Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
      Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: de::Visitor<'de>,
          {
              match self.value {
                  Cow::Borrowed(string) => visitor.visit_borrowed_str(string),
                  #[cfg(any(feature = "std", feature = "alloc"))]
                  Cow::Owned(string) => visitor.visit_string(string),
              }
          }
      *)
      Definition deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_any" := {
        Notations.double_colon := deserialize_any (V := V);
      }.
      
      (*
          fn deserialize_enum<V>(
              self,
              _name: &str,
              _variants: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: de::Visitor<'de>,
          {
              visitor.visit_enum(self)
          }
      *)
      Definition deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_variants : ref (slice (ref str.t)))
          (visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variants := M.alloc _variants in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_enum" := {
        Notations.double_colon := deserialize_enum (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bool" := {
        Notations.double_colon := deserialize_bool (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i8" := {
        Notations.double_colon := deserialize_i8 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i16" := {
        Notations.double_colon := deserialize_i16 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i32" := {
        Notations.double_colon := deserialize_i32 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i64" := {
        Notations.double_colon := deserialize_i64 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i128" := {
        Notations.double_colon := deserialize_i128 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u8" := {
        Notations.double_colon := deserialize_u8 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u16" := {
        Notations.double_colon := deserialize_u16 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u32" := {
        Notations.double_colon := deserialize_u32 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u64" := {
        Notations.double_colon := deserialize_u64 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u128" := {
        Notations.double_colon := deserialize_u128 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f32" := {
        Notations.double_colon := deserialize_f32 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f64" := {
        Notations.double_colon := deserialize_f64 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_char" := {
        Notations.double_colon := deserialize_char (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_str" := {
        Notations.double_colon := deserialize_str (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_string" := {
        Notations.double_colon := deserialize_string (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bytes" := {
        Notations.double_colon := deserialize_bytes (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_byte_buf" := {
        Notations.double_colon := deserialize_byte_buf (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_option" := {
        Notations.double_colon := deserialize_option (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit" := {
        Notations.double_colon := deserialize_unit (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit_struct" := {
        Notations.double_colon := deserialize_unit_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_newtype_struct" := {
        Notations.double_colon := deserialize_newtype_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_seq" := {
        Notations.double_colon := deserialize_seq (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple" := {
        Notations.double_colon := deserialize_tuple (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple_struct" := {
        Notations.double_colon := deserialize_tuple_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_map" := {
        Notations.double_colon := deserialize_map (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (fields : ref (slice (ref str.t)))
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* fields := M.alloc fields in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_struct" := {
        Notations.double_colon := deserialize_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_identifier" := {
        Notations.double_colon := deserialize_identifier (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_ignored_any" := {
        Notations.double_colon := deserialize_ignored_any (V := V);
      }.
      
      Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
        serde.de.Deserializer.Error := Error;
        serde.de.Deserializer.deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_any (V := V);
        serde.de.Deserializer.deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_enum (V := V);
        serde.de.Deserializer.deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bool (V := V);
        serde.de.Deserializer.deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i8 (V := V);
        serde.de.Deserializer.deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i16 (V := V);
        serde.de.Deserializer.deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i32 (V := V);
        serde.de.Deserializer.deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i64 (V := V);
        serde.de.Deserializer.deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_i128 (V := V));
        serde.de.Deserializer.deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u8 (V := V);
        serde.de.Deserializer.deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u16 (V := V);
        serde.de.Deserializer.deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u32 (V := V);
        serde.de.Deserializer.deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u64 (V := V);
        serde.de.Deserializer.deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_u128 (V := V));
        serde.de.Deserializer.deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f32 (V := V);
        serde.de.Deserializer.deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f64 (V := V);
        serde.de.Deserializer.deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_char (V := V);
        serde.de.Deserializer.deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_str (V := V);
        serde.de.Deserializer.deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_string (V := V);
        serde.de.Deserializer.deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bytes (V := V);
        serde.de.Deserializer.deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_byte_buf (V := V);
        serde.de.Deserializer.deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_option (V := V);
        serde.de.Deserializer.deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit (V := V);
        serde.de.Deserializer.deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit_struct (V := V);
        serde.de.Deserializer.deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_newtype_struct (V := V);
        serde.de.Deserializer.deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_seq (V := V);
        serde.de.Deserializer.deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple (V := V);
        serde.de.Deserializer.deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple_struct (V := V);
        serde.de.Deserializer.deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_map (V := V);
        serde.de.Deserializer.deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_struct (V := V);
        serde.de.Deserializer.deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_identifier (V := V);
        serde.de.Deserializer.deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_ignored_any (V := V);
        serde.de.Deserializer.is_human_readable := Datatypes.None;
        serde.de.Deserializer.__deserialize_content := Datatypes.None;
      }.
    End Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
    End Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
    
    Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
    Section Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
      Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          type Variant = UnitOnly;
      *)
      Definition Variant : Set := serde_json.value.de.UnitOnly.t.
      
      (*
          fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Error>
          where
              T: de::DeserializeSeed<'de>,
          {
              let value = tri!(seed.deserialize(self));
              Ok((value, UnitOnly))
          }
      *)
      Definition variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                (T::type["Value"].t * Variant)
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "variant_seed" := {
        Notations.double_colon := variant_seed (T := T);
      }.
      
      Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
        serde.de.EnumAccess.Error := Error;
        serde.de.EnumAccess.Variant := Variant;
        serde.de.EnumAccess.variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          variant_seed (T := T);
        serde.de.EnumAccess.variant := Datatypes.None;
      }.
    End Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
    End Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
    
    Module  UnitOnly.
    Section UnitOnly.
      Inductive t : Set := Build.
    End UnitOnly.
    End UnitOnly.
    
    Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
    Section Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
      Definition Self : Set := serde_json.value.de.UnitOnly.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn unit_variant(self) -> Result<(), Error> {
              Ok(())
          }
      *)
      Definition unit_variant
          (self : Self)
          : M (core.result.Result.t unit serde_json.error.Error.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_unit_variant :
        Notations.DoubleColon Self "unit_variant" := {
        Notations.double_colon := unit_variant;
      }.
      
      (*
          fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Error>
          where
              T: de::DeserializeSeed<'de>,
          {
              Err(de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"newtype variant",
              ))
          }
      *)
      Definition newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : Self)
          (_seed : T)
          :
            M
              (core.result.Result.t
                T::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _seed := M.alloc _seed in
        M.read foo.
      
      Global Instance AssociatedFunction_newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "newtype_variant_seed" := {
        Notations.double_colon := newtype_variant_seed (T := T);
      }.
      
      (*
          fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Error>
          where
              V: de::Visitor<'de>,
          {
              Err(de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"tuple variant",
              ))
          }
      *)
      Definition tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_len : usize.t)
          (_visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        let* _visitor := M.alloc _visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "tuple_variant" := {
        Notations.double_colon := tuple_variant (V := V);
      }.
      
      (*
          fn struct_variant<V>(
              self,
              _fields: &'static [&'static str],
              _visitor: V,
          ) -> Result<V::Value, Error>
          where
              V: de::Visitor<'de>,
          {
              Err(de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"struct variant",
              ))
          }
      *)
      Definition struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_fields : ref (slice (ref str.t)))
          (_visitor : V)
          :
            M
              (core.result.Result.t
                V::type["Value"].t
                serde_json.error.Error.t) :=
        let* self := M.alloc self in
        let* _fields := M.alloc _fields in
        let* _visitor := M.alloc _visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "struct_variant" := {
        Notations.double_colon := struct_variant (V := V);
      }.
      
      Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
        serde.de.VariantAccess.Error := Error;
        serde.de.VariantAccess.unit_variant := unit_variant;
        serde.de.VariantAccess.newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          newtype_variant_seed (T := T);
        serde.de.VariantAccess.tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          tuple_variant (V := V);
        serde.de.VariantAccess.struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          struct_variant (V := V);
        serde.de.VariantAccess.newtype_variant := Datatypes.None;
      }.
    End Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
    End Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
  End de.
  
  Module from.
    Module  Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : i8.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := i8.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : i16.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := i16.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : i32.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := i32.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : i64.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := i64.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : isize.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := isize.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : u8.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := u8.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : u16.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := u16.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : u32.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := u32.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : u64.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := u64.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn from(n: $ty) -> Self {
                          Value::Number(n.into())
                      }
      *)
      Definition from (n : usize.t) : M Self :=
        let* n := M.alloc n in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := usize.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: f32) -> Self {
              Number::from_f32(f).map_or(Value::Null, Value::Number)
          }
      *)
      Definition from (f : f32.t) : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := f32.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: f64) -> Self {
              Number::from_f64(f).map_or(Value::Null, Value::Number)
          }
      *)
      Definition from (f : f64.t) : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := f64.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: bool) -> Self {
              Value::Bool(f)
          }
      *)
      Definition from (f : bool.t) : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := bool.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: String) -> Self {
              Value::String(f)
          }
      *)
      Definition from (f : alloc.string.String.t) : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self (T := alloc.string.String.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: &str) -> Self {
              Value::String(f.to_string())
          }
      *)
      Definition from (f : ref str.t) : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := ref str.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: Cow<'a, str>) -> Self {
              Value::String(f.into_owned())
          }
      *)
      Definition from (f : alloc.borrow.Cow.t str.t) : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self (T := alloc.borrow.Cow.t str.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: Number) -> Self {
              Value::Number(f)
          }
      *)
      Definition from (f : serde_json.number.Number.t) : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self (T := serde_json.number.Number.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: Map<String, Value>) -> Self {
              Value::Object(f)
          }
      *)
      Definition from
          (f
            :
            serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
          : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := serde_json.map.Map.t
            alloc.string.String.t
            serde_json.value.Value.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
    End Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
      Context {T : Set}.
      
      Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
      
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: Vec<T>) -> Self {
              Value::Array(f.into_iter().map(Into::into).collect())
          }
      *)
      Definition from
          (f : alloc.vec.Vec.t T alloc.vec.Vec.Default.A)
          : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := alloc.vec.Vec.t T alloc.vec.Vec.Default.A) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
    End Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
      Context {T : Set}.
      
      Context
        {ℋ_0 : core.clone.Clone.Trait T}
        {ℋ_1 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
      
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(f: &[T]) -> Self {
              Value::Array(f.iter().cloned().map(Into::into).collect())
          }
      *)
      Definition from (f : ref (slice T)) : M Self :=
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := ref (slice T)) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
    End Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
    
    Module  Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
    Section Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
      Context {T : Set}.
      
      Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
      
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
              Value::Array(iter.into_iter().map(Into::into).collect())
          }
      *)
      Definition from_iter
          {I : Set}
          {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
          (iter : I)
          : M Self :=
        let* iter := M.alloc iter in
        M.read foo.
      
      Global Instance AssociatedFunction_from_iter
          {I : Set}
          {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :
        Notations.DoubleColon Self "from_iter" := {
        Notations.double_colon := from_iter (I := I);
      }.
      
      Global Instance ℐ :
        core.iter.traits.collect.FromIterator.Trait Self (A := T) := {
        core.iter.traits.collect.FromIterator.from_iter
          {I : Set}
          {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :=
          from_iter (I := I);
      }.
    End Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
    End Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
    
    Module  Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
    Section Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
      Context {K V : Set}.
      
      Context
        {ℋ_0 : core.convert.Into.Trait K (T := alloc.string.String.t)}
        {ℋ_1 : core.convert.Into.Trait V (T := serde_json.value.Value.t)}.
      
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {
              Value::Object(
                  iter.into_iter()
                      .map(|(k, v)| (k.into(), v.into()))
                      .collect(),
              )
          }
      *)
      Definition from_iter
          {I : Set}
          {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
          (iter : I)
          : M Self :=
        let* iter := M.alloc iter in
        M.read foo.
      
      Global Instance AssociatedFunction_from_iter
          {I : Set}
          {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :
        Notations.DoubleColon Self "from_iter" := {
        Notations.double_colon := from_iter (I := I);
      }.
      
      Global Instance ℐ :
        core.iter.traits.collect.FromIterator.Trait Self (A := K * V) := {
        core.iter.traits.collect.FromIterator.from_iter
          {I : Set}
          {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :=
          from_iter (I := I);
      }.
    End Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
    End Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
    Section Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from((): ()) -> Self {
              Value::Null
          }
      *)
      Definition from (Pattern : unit) : M Self :=
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ : core.convert.From.Trait Self (T := unit) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
    End Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
    
    Module  Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
    Section Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
      Context {T : Set}.
      
      Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
      
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn from(opt: Option<T>) -> Self {
              match opt {
                  None => Value::Null,
                  Some(value) => Into::into(value),
              }
          }
      *)
      Definition from (opt : core.option.Option.t T) : M Self :=
        let* opt := M.alloc opt in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self (T := core.option.Option.t T) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
    End Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
  End from.
  
  Module index.
    Module  Index.
    Section Index.
      Class Trait (Self : Set) : Type := {
        ℒ_0 :: serde_json.value.index.private.Sealed.Trait Self;
        index_into :
          (ref Self) ->
            (ref serde_json.value.Value.t) ->
            M (core.option.Option.t (ref serde_json.value.Value.t));
        index_into_mut :
          (ref Self) ->
            (mut_ref serde_json.value.Value.t) ->
            M (core.option.Option.t (mut_ref serde_json.value.Value.t));
        index_or_insert :
          (ref Self) ->
            (mut_ref serde_json.value.Value.t) ->
            M (mut_ref serde_json.value.Value.t);
      }.
      
    End Index.
    End Index.
    
    Module  Impl_serde_json_value_index_Index_for_usize_t.
    Section Impl_serde_json_value_index_Index_for_usize_t.
      Definition Self : Set := usize.t.
      
      (*
          fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
              match v {
                  Value::Array(vec) => vec.get( *self),
                  _ => None,
              }
          }
      *)
      Definition index_into
          (self : ref Self)
          (v : ref serde_json.value.Value.t)
          : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_into :
        Notations.DoubleColon Self "index_into" := {
        Notations.double_colon := index_into;
      }.
      
      (*
          fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
              match v {
                  Value::Array(vec) => vec.get_mut( *self),
                  _ => None,
              }
          }
      *)
      Definition index_into_mut
          (self : ref Self)
          (v : mut_ref serde_json.value.Value.t)
          : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_into_mut :
        Notations.DoubleColon Self "index_into_mut" := {
        Notations.double_colon := index_into_mut;
      }.
      
      (*
          fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
              match v {
                  Value::Array(vec) => {
                      let len = vec.len();
                      vec.get_mut( *self).unwrap_or_else(|| {
                          panic!(
                              "cannot access index {} of JSON array of length {}",
                              self, len
                          )
                      })
                  }
                  _ => panic!("cannot access index {} of JSON {}", self, Type(v)),
              }
          }
      *)
      Definition index_or_insert
          (self : ref Self)
          (v : mut_ref serde_json.value.Value.t)
          : M (mut_ref serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_or_insert :
        Notations.DoubleColon Self "index_or_insert" := {
        Notations.double_colon := index_or_insert;
      }.
      
      Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
        serde_json.value.index.Index.index_into := index_into;
        serde_json.value.index.Index.index_into_mut := index_into_mut;
        serde_json.value.index.Index.index_or_insert := index_or_insert;
      }.
    End Impl_serde_json_value_index_Index_for_usize_t.
    End Impl_serde_json_value_index_Index_for_usize_t.
    
    Module  Impl_serde_json_value_index_Index_for_str_t.
    Section Impl_serde_json_value_index_Index_for_str_t.
      Definition Self : Set := str.t.
      
      (*
          fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
              match v {
                  Value::Object(map) => map.get(self),
                  _ => None,
              }
          }
      *)
      Definition index_into
          (self : ref Self)
          (v : ref serde_json.value.Value.t)
          : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_into :
        Notations.DoubleColon Self "index_into" := {
        Notations.double_colon := index_into;
      }.
      
      (*
          fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
              match v {
                  Value::Object(map) => map.get_mut(self),
                  _ => None,
              }
          }
      *)
      Definition index_into_mut
          (self : ref Self)
          (v : mut_ref serde_json.value.Value.t)
          : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_into_mut :
        Notations.DoubleColon Self "index_into_mut" := {
        Notations.double_colon := index_into_mut;
      }.
      
      (*
          fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
              if let Value::Null = v {
                  *v = Value::Object(Map::new());
              }
              match v {
                  Value::Object(map) => map.entry(self.to_owned()).or_insert(Value::Null),
                  _ => panic!("cannot access key {:?} in JSON {}", self, Type(v)),
              }
          }
      *)
      Definition index_or_insert
          (self : ref Self)
          (v : mut_ref serde_json.value.Value.t)
          : M (mut_ref serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_or_insert :
        Notations.DoubleColon Self "index_or_insert" := {
        Notations.double_colon := index_or_insert;
      }.
      
      Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
        serde_json.value.index.Index.index_into := index_into;
        serde_json.value.index.Index.index_into_mut := index_into_mut;
        serde_json.value.index.Index.index_or_insert := index_or_insert;
      }.
    End Impl_serde_json_value_index_Index_for_str_t.
    End Impl_serde_json_value_index_Index_for_str_t.
    
    Module  Impl_serde_json_value_index_Index_for_alloc_string_String_t.
    Section Impl_serde_json_value_index_Index_for_alloc_string_String_t.
      Definition Self : Set := alloc.string.String.t.
      
      (*
          fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
              self[..].index_into(v)
          }
      *)
      Definition index_into
          (self : ref Self)
          (v : ref serde_json.value.Value.t)
          : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_into :
        Notations.DoubleColon Self "index_into" := {
        Notations.double_colon := index_into;
      }.
      
      (*
          fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
              self[..].index_into_mut(v)
          }
      *)
      Definition index_into_mut
          (self : ref Self)
          (v : mut_ref serde_json.value.Value.t)
          : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_into_mut :
        Notations.DoubleColon Self "index_into_mut" := {
        Notations.double_colon := index_into_mut;
      }.
      
      (*
          fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
              self[..].index_or_insert(v)
          }
      *)
      Definition index_or_insert
          (self : ref Self)
          (v : mut_ref serde_json.value.Value.t)
          : M (mut_ref serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_or_insert :
        Notations.DoubleColon Self "index_or_insert" := {
        Notations.double_colon := index_or_insert;
      }.
      
      Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
        serde_json.value.index.Index.index_into := index_into;
        serde_json.value.index.Index.index_into_mut := index_into_mut;
        serde_json.value.index.Index.index_or_insert := index_or_insert;
      }.
    End Impl_serde_json_value_index_Index_for_alloc_string_String_t.
    End Impl_serde_json_value_index_Index_for_alloc_string_String_t.
    
    Module  Impl_serde_json_value_index_Index_for_ref_T.
    Section Impl_serde_json_value_index_Index_for_ref_T.
      Context {T : Set}.
      
      Context {ℋ_0 : serde_json.value.index.Index.Trait T}.
      
      Definition Self : Set := ref T.
      
      (*
          fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
              ( **self).index_into(v)
          }
      *)
      Definition index_into
          (self : ref Self)
          (v : ref serde_json.value.Value.t)
          : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_into :
        Notations.DoubleColon Self "index_into" := {
        Notations.double_colon := index_into;
      }.
      
      (*
          fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
              ( **self).index_into_mut(v)
          }
      *)
      Definition index_into_mut
          (self : ref Self)
          (v : mut_ref serde_json.value.Value.t)
          : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_into_mut :
        Notations.DoubleColon Self "index_into_mut" := {
        Notations.double_colon := index_into_mut;
      }.
      
      (*
          fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
              ( **self).index_or_insert(v)
          }
      *)
      Definition index_or_insert
          (self : ref Self)
          (v : mut_ref serde_json.value.Value.t)
          : M (mut_ref serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_index_or_insert :
        Notations.DoubleColon Self "index_or_insert" := {
        Notations.double_colon := index_or_insert;
      }.
      
      Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
        serde_json.value.index.Index.index_into := index_into;
        serde_json.value.index.Index.index_into_mut := index_into_mut;
        serde_json.value.index.Index.index_or_insert := index_or_insert;
      }.
    End Impl_serde_json_value_index_Index_for_ref_T.
    End Impl_serde_json_value_index_Index_for_ref_T.
    
    Module private.
      Module  Sealed.
      Section Sealed.
        Unset Primitive Projections.
        Class Trait (Self : Set) : Type := {
        }.
        Global Set Primitive Projections.
      End Sealed.
      End Sealed.
      
      Module  Impl_serde_json_value_index_private_Sealed_for_usize_t.
      Section Impl_serde_json_value_index_private_Sealed_for_usize_t.
        Definition Self : Set := usize.t.
        
        Global Instance ℐ :
          serde_json.value.index.private.Sealed.Trait Self := {
        }.
      End Impl_serde_json_value_index_private_Sealed_for_usize_t.
      End Impl_serde_json_value_index_private_Sealed_for_usize_t.
      
      Module  Impl_serde_json_value_index_private_Sealed_for_str_t.
      Section Impl_serde_json_value_index_private_Sealed_for_str_t.
        Definition Self : Set := str.t.
        
        Global Instance ℐ :
          serde_json.value.index.private.Sealed.Trait Self := {
        }.
      End Impl_serde_json_value_index_private_Sealed_for_str_t.
      End Impl_serde_json_value_index_private_Sealed_for_str_t.
      
      Module  Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
      Section Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
        Definition Self : Set := alloc.string.String.t.
        
        Global Instance ℐ :
          serde_json.value.index.private.Sealed.Trait Self := {
        }.
      End Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
      End Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
      
      Module  Impl_serde_json_value_index_private_Sealed_for_ref_T.
      Section Impl_serde_json_value_index_private_Sealed_for_ref_T.
        Context {T : Set}.
        
        Context {ℋ_0 : serde_json.value.index.private.Sealed.Trait T}.
        
        Definition Self : Set := ref T.
        
        Global Instance ℐ :
          serde_json.value.index.private.Sealed.Trait Self := {
        }.
      End Impl_serde_json_value_index_private_Sealed_for_ref_T.
      End Impl_serde_json_value_index_private_Sealed_for_ref_T.
    End private.
    
    Module  Type_.
    Section Type_.
      Record t : Set := {
        x0 : ref serde_json.value.Value.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End Type_.
    End Type_.
    
    Module  Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
    Section Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
      Definition Self : Set := serde_json.value.index.Type_.t.
      
      (*
          fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
              match *self.0 {
                  Value::Null => formatter.write_str("null"),
                  Value::Bool(_) => formatter.write_str("boolean"),
                  Value::Number(_) => formatter.write_str("number"),
                  Value::String(_) => formatter.write_str("string"),
                  Value::Array(_) => formatter.write_str("array"),
                  Value::Object(_) => formatter.write_str("object"),
              }
          }
      *)
      Definition fmt
          (self : ref Self)
          (formatter : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* formatter := M.alloc formatter in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
    End Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
    
    Module  Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
    Section Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
      Context {I : Set}.
      
      Context {ℋ_0 : serde_json.value.index.Index.Trait I}.
      
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          type Output = Value;
      *)
      Definition Output : Set := serde_json.value.Value.t.
      
      (*
          fn index(&self, index: I) -> &Value {
              static NULL: Value = Value::Null;
              index.index_into(self).unwrap_or(&NULL)
          }
      *)
      Definition index
          (self : ref Self)
          (index : I)
          : M (ref serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* index := M.alloc index in
        M.read foo.
      
      Global Instance AssociatedFunction_index :
        Notations.DoubleColon Self "index" := {
        Notations.double_colon := index;
      }.
      
      Global Instance ℐ : core.ops.index.Index.Trait Self (Idx := I) := {
        core.ops.index.Index.Output := Output;
        core.ops.index.Index.index := index;
      }.
    End Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
    End Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
    
    Module  Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
    Section Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
      Context {I : Set}.
      
      Context {ℋ_0 : serde_json.value.index.Index.Trait I}.
      
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn index_mut(&mut self, index: I) -> &mut Value {
              index.index_or_insert(self)
          }
      *)
      Definition index_mut
          (self : mut_ref Self)
          (index : I)
          : M (mut_ref serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* index := M.alloc index in
        M.read foo.
      
      Global Instance AssociatedFunction_index_mut :
        Notations.DoubleColon Self "index_mut" := {
        Notations.double_colon := index_mut;
      }.
      
      Global Instance ℐ : core.ops.index.IndexMut.Trait Self (Idx := I) := {
        core.ops.index.IndexMut.index_mut := index_mut;
      }.
    End Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
    End Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
  End index.
  
  Module partial_eq.
    (*
    fn eq_i64(value: &Value, other: i64) -> bool {
        value.as_i64().map_or(false, |i| i == other)
    }
    *)
    Definition eq_i64
        (value : ref serde_json.value.Value.t)
        (other : i64.t)
        : M bool.t :=
      let* value := M.alloc value in
      let* other := M.alloc other in
      M.read foo.
    
    (*
    fn eq_u64(value: &Value, other: u64) -> bool {
        value.as_u64().map_or(false, |i| i == other)
    }
    *)
    Definition eq_u64
        (value : ref serde_json.value.Value.t)
        (other : u64.t)
        : M bool.t :=
      let* value := M.alloc value in
      let* other := M.alloc other in
      M.read foo.
    
    (*
    fn eq_f32(value: &Value, other: f32) -> bool {
        match value {
            Value::Number(n) => n.as_f32().map_or(false, |i| i == other),
            _ => false,
        }
    }
    *)
    Definition eq_f32
        (value : ref serde_json.value.Value.t)
        (other : f32.t)
        : M bool.t :=
      let* value := M.alloc value in
      let* other := M.alloc other in
      M.read foo.
    
    (*
    fn eq_f64(value: &Value, other: f64) -> bool {
        value.as_f64().map_or(false, |i| i == other)
    }
    *)
    Definition eq_f64
        (value : ref serde_json.value.Value.t)
        (other : f64.t)
        : M bool.t :=
      let* value := M.alloc value in
      let* other := M.alloc other in
      M.read foo.
    
    (*
    fn eq_bool(value: &Value, other: bool) -> bool {
        value.as_bool().map_or(false, |i| i == other)
    }
    *)
    Definition eq_bool
        (value : ref serde_json.value.Value.t)
        (other : bool.t)
        : M bool.t :=
      let* value := M.alloc value in
      let* other := M.alloc other in
      M.read foo.
    
    (*
    fn eq_str(value: &Value, other: &str) -> bool {
        value.as_str().map_or(false, |i| i == other)
    }
    *)
    Definition eq_str
        (value : ref serde_json.value.Value.t)
        (other : ref str.t)
        : M bool.t :=
      let* value := M.alloc value in
      let* other := M.alloc other in
      M.read foo.
    
    Module  Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn eq(&self, other: &str) -> bool {
              eq_str(self, other)
          }
      *)
      Definition eq (self : ref Self) (other : ref str.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := str.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn eq(&self, other: &&str) -> bool {
              eq_str(self, *other)
          }
      *)
      Definition eq (self : ref Self) (other : ref (ref str.t)) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := ref str.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
      Definition Self : Set := str.t.
      
      (*
          fn eq(&self, other: &Value) -> bool {
              eq_str(other, self)
          }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
      Definition Self : Set := ref str.t.
      
      (*
          fn eq(&self, other: &Value) -> bool {
              eq_str(other, *self)
          }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
    
    Module  Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn eq(&self, other: &String) -> bool {
              eq_str(self, other.as_str())
          }
      *)
      Definition eq
          (self : ref Self)
          (other : ref alloc.string.String.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := alloc.string.String.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
      Definition Self : Set := alloc.string.String.t.
      
      (*
          fn eq(&self, other: &Value) -> bool {
              eq_str(other, self.as_str())
          }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
    
    Module  Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
      Definition Self : Set := i8.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
    
    Module  Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
      Definition Self : Set := i16.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
    
    Module  Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
      Definition Self : Set := i32.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
    
    Module  Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
      Definition Self : Set := i64.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
    
    Module  Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
      Definition Self : Set := isize.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
    
    Module  Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
      Definition Self : Set := u8.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
    
    Module  Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
      Definition Self : Set := u16.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
    
    Module  Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
      Definition Self : Set := u32.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
    
    Module  Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
      Definition Self : Set := u64.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
    
    Module  Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
      Definition Self : Set := usize.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
    
    Module  Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
      Definition Self : Set := f32.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
    
    Module  Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
      Definition Self : Set := f64.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
    
    Module  Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq(self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
    Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
      Definition Self : Set := bool.t.
      
      (*
                      fn eq(&self, other: &Value) -> bool {
                          $eq(other, *self as _)
                      }
      *)
      Definition eq
          (self : ref Self)
          (other : ref serde_json.value.Value.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := serde_json.value.Value.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
    End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
    
    Module  Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
      Definition Self : Set := ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
    
    Module  Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
    Section Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
      Definition Self : Set := mut_ref serde_json.value.Value.t.
      
      (*
                      fn eq(&self, other: &$ty) -> bool {
                          $eq( *self, *other as _)
                      }
      *)
      Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
    End Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
  End partial_eq.
  
  Module ser.
    Module  Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
    Section Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
      Definition Self : Set := serde_json.value.Value.t.
      
      (*
          fn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>
          where
              S: ::serde::Serializer,
          {
              match self {
                  Value::Null => serializer.serialize_unit(),
                  Value::Bool(b) => serializer.serialize_bool( *b),
                  Value::Number(n) => n.serialize(serializer),
                  Value::String(s) => serializer.serialize_str(s),
                  Value::Array(v) => v.serialize(serializer),
                  #[cfg(any(feature = "std", feature = "alloc"))]
                  Value::Object(m) => {
                      use serde::ser::SerializeMap;
                      let mut map = tri!(serializer.serialize_map(Some(m.len())));
                      for (k, v) in m {
                          tri!(map.serialize_entry(k, v));
                      }
                      map.end()
                  }
              }
          }
      *)
      Definition serialize
          {S : Set}
          {ℋ_0 : serde.ser.Serializer.Trait S}
          (self : ref Self)
          (serializer : S)
          : M (core.result.Result.t S::type["Ok"].t S::type["Error"].t) :=
        let* self := M.alloc self in
        let* serializer := M.alloc serializer in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize
          {S : Set}
          {ℋ_0 : serde.ser.Serializer.Trait S} :
        Notations.DoubleColon Self "serialize" := {
        Notations.double_colon := serialize (S := S);
      }.
      
      Global Instance ℐ : serde.ser.Serialize.Trait Self := {
        serde.ser.Serialize.serialize
          {S : Set}
          {ℋ_0 : serde.ser.Serializer.Trait S} :=
          serialize (S := S);
      }.
    End Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
    End Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
    
    Module  Serializer.
    Section Serializer.
      Inductive t : Set := Build.
    End Serializer.
    End Serializer.
    
    Module  Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
    Section Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
      Definition Self : Set := serde_json.value.ser.Serializer.t.
      
      (*
          type Ok = Value;
      *)
      Definition Ok : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          type SerializeSeq = SerializeVec;
      *)
      Definition SerializeSeq : Set := serde_json.value.ser.SerializeVec.t.
      
      (*
          type SerializeTuple = SerializeVec;
      *)
      Definition SerializeTuple : Set := serde_json.value.ser.SerializeVec.t.
      
      (*
          type SerializeTupleStruct = SerializeVec;
      *)
      Definition SerializeTupleStruct : Set :=
        serde_json.value.ser.SerializeVec.t.
      
      (*
          type SerializeTupleVariant = SerializeTupleVariant;
      *)
      Definition SerializeTupleVariant : Set :=
        serde_json.value.ser.SerializeTupleVariant.t.
      
      (*
          type SerializeMap = SerializeMap;
      *)
      Definition SerializeMap : Set := serde_json.value.ser.SerializeMap.t.
      
      (*
          type SerializeStruct = SerializeMap;
      *)
      Definition SerializeStruct : Set := serde_json.value.ser.SerializeMap.t.
      
      (*
          type SerializeStructVariant = SerializeStructVariant;
      *)
      Definition SerializeStructVariant : Set :=
        serde_json.value.ser.SerializeStructVariant.t.
      
      (*
          fn serialize_bool(self, value: bool) -> Result<Value> {
              Ok(Value::Bool(value))
          }
      *)
      Definition serialize_bool
          (self : Self)
          (value : bool.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_bool :
        Notations.DoubleColon Self "serialize_bool" := {
        Notations.double_colon := serialize_bool;
      }.
      
      (*
          fn serialize_i8(self, value: i8) -> Result<Value> {
              self.serialize_i64(value as i64)
          }
      *)
      Definition serialize_i8
          (self : Self)
          (value : i8.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i8 :
        Notations.DoubleColon Self "serialize_i8" := {
        Notations.double_colon := serialize_i8;
      }.
      
      (*
          fn serialize_i16(self, value: i16) -> Result<Value> {
              self.serialize_i64(value as i64)
          }
      *)
      Definition serialize_i16
          (self : Self)
          (value : i16.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i16 :
        Notations.DoubleColon Self "serialize_i16" := {
        Notations.double_colon := serialize_i16;
      }.
      
      (*
          fn serialize_i32(self, value: i32) -> Result<Value> {
              self.serialize_i64(value as i64)
          }
      *)
      Definition serialize_i32
          (self : Self)
          (value : i32.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i32 :
        Notations.DoubleColon Self "serialize_i32" := {
        Notations.double_colon := serialize_i32;
      }.
      
      (*
          fn serialize_i64(self, value: i64) -> Result<Value> {
              Ok(Value::Number(value.into()))
          }
      *)
      Definition serialize_i64
          (self : Self)
          (value : i64.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i64 :
        Notations.DoubleColon Self "serialize_i64" := {
        Notations.double_colon := serialize_i64;
      }.
      
      (*
          fn serialize_i128(self, value: i128) -> Result<Value> {
              #[cfg(feature = "arbitrary_precision")]
              {
                  Ok(Value::Number(value.into()))
              }
      
              #[cfg(not(feature = "arbitrary_precision"))]
              {
                  if let Ok(value) = u64::try_from(value) {
                      Ok(Value::Number(value.into()))
                  } else if let Ok(value) = i64::try_from(value) {
                      Ok(Value::Number(value.into()))
                  } else {
                      Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))
                  }
              }
          }
      *)
      Definition serialize_i128
          (self : Self)
          (value : i128.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i128 :
        Notations.DoubleColon Self "serialize_i128" := {
        Notations.double_colon := serialize_i128;
      }.
      
      (*
          fn serialize_u8(self, value: u8) -> Result<Value> {
              self.serialize_u64(value as u64)
          }
      *)
      Definition serialize_u8
          (self : Self)
          (value : u8.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u8 :
        Notations.DoubleColon Self "serialize_u8" := {
        Notations.double_colon := serialize_u8;
      }.
      
      (*
          fn serialize_u16(self, value: u16) -> Result<Value> {
              self.serialize_u64(value as u64)
          }
      *)
      Definition serialize_u16
          (self : Self)
          (value : u16.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u16 :
        Notations.DoubleColon Self "serialize_u16" := {
        Notations.double_colon := serialize_u16;
      }.
      
      (*
          fn serialize_u32(self, value: u32) -> Result<Value> {
              self.serialize_u64(value as u64)
          }
      *)
      Definition serialize_u32
          (self : Self)
          (value : u32.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u32 :
        Notations.DoubleColon Self "serialize_u32" := {
        Notations.double_colon := serialize_u32;
      }.
      
      (*
          fn serialize_u64(self, value: u64) -> Result<Value> {
              Ok(Value::Number(value.into()))
          }
      *)
      Definition serialize_u64
          (self : Self)
          (value : u64.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u64 :
        Notations.DoubleColon Self "serialize_u64" := {
        Notations.double_colon := serialize_u64;
      }.
      
      (*
          fn serialize_u128(self, value: u128) -> Result<Value> {
              #[cfg(feature = "arbitrary_precision")]
              {
                  Ok(Value::Number(value.into()))
              }
      
              #[cfg(not(feature = "arbitrary_precision"))]
              {
                  if let Ok(value) = u64::try_from(value) {
                      Ok(Value::Number(value.into()))
                  } else {
                      Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))
                  }
              }
          }
      *)
      Definition serialize_u128
          (self : Self)
          (value : u128.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u128 :
        Notations.DoubleColon Self "serialize_u128" := {
        Notations.double_colon := serialize_u128;
      }.
      
      (*
          fn serialize_f32(self, float: f32) -> Result<Value> {
              Ok(Value::from(float))
          }
      *)
      Definition serialize_f32
          (self : Self)
          (float : f32.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* float := M.alloc float in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_f32 :
        Notations.DoubleColon Self "serialize_f32" := {
        Notations.double_colon := serialize_f32;
      }.
      
      (*
          fn serialize_f64(self, float: f64) -> Result<Value> {
              Ok(Value::from(float))
          }
      *)
      Definition serialize_f64
          (self : Self)
          (float : f64.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* float := M.alloc float in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_f64 :
        Notations.DoubleColon Self "serialize_f64" := {
        Notations.double_colon := serialize_f64;
      }.
      
      (*
          fn serialize_char(self, value: char) -> Result<Value> {
              let mut s = String::new();
              s.push(value);
              Ok(Value::String(s))
          }
      *)
      Definition serialize_char
          (self : Self)
          (value : char.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_char :
        Notations.DoubleColon Self "serialize_char" := {
        Notations.double_colon := serialize_char;
      }.
      
      (*
          fn serialize_str(self, value: &str) -> Result<Value> {
              Ok(Value::String(value.to_owned()))
          }
      *)
      Definition serialize_str
          (self : Self)
          (value : ref str.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_str :
        Notations.DoubleColon Self "serialize_str" := {
        Notations.double_colon := serialize_str;
      }.
      
      (*
          fn serialize_bytes(self, value: &[u8]) -> Result<Value> {
              let vec = value.iter().map(|&b| Value::Number(b.into())).collect();
              Ok(Value::Array(vec))
          }
      *)
      Definition serialize_bytes
          (self : Self)
          (value : ref (slice u8.t))
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_bytes :
        Notations.DoubleColon Self "serialize_bytes" := {
        Notations.double_colon := serialize_bytes;
      }.
      
      (*
          fn serialize_unit(self) -> Result<Value> {
              Ok(Value::Null)
          }
      *)
      Definition serialize_unit
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_unit :
        Notations.DoubleColon Self "serialize_unit" := {
        Notations.double_colon := serialize_unit;
      }.
      
      (*
          fn serialize_unit_struct(self, _name: &'static str) -> Result<Value> {
              self.serialize_unit()
          }
      *)
      Definition serialize_unit_struct
          (self : Self)
          (_name : ref str.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_unit_struct :
        Notations.DoubleColon Self "serialize_unit_struct" := {
        Notations.double_colon := serialize_unit_struct;
      }.
      
      (*
          fn serialize_unit_variant(
              self,
              _name: &'static str,
              _variant_index: u32,
              variant: &'static str,
          ) -> Result<Value> {
              self.serialize_str(variant)
          }
      *)
      Definition serialize_unit_variant
          (self : Self)
          (_name : ref str.t)
          (_variant_index : u32.t)
          (variant : ref str.t)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variant_index := M.alloc _variant_index in
        let* variant := M.alloc variant in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_unit_variant :
        Notations.DoubleColon Self "serialize_unit_variant" := {
        Notations.double_colon := serialize_unit_variant;
      }.
      
      (*
          fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<Value>
          where
              T: ?Sized + Serialize,
          {
              value.serialize(self)
          }
      *)
      Definition serialize_newtype_struct
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : Self)
          (_name : ref str.t)
          (value : ref T)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_newtype_struct
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_newtype_struct" := {
        Notations.double_colon := serialize_newtype_struct (T := T);
      }.
      
      (*
          fn serialize_newtype_variant<T>(
              self,
              _name: &'static str,
              _variant_index: u32,
              variant: &'static str,
              value: &T,
          ) -> Result<Value>
          where
              T: ?Sized + Serialize,
          {
              let mut values = Map::new();
              values.insert(String::from(variant), tri!(to_value(value)));
              Ok(Value::Object(values))
          }
      *)
      Definition serialize_newtype_variant
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : Self)
          (_name : ref str.t)
          (_variant_index : u32.t)
          (variant : ref str.t)
          (value : ref T)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variant_index := M.alloc _variant_index in
        let* variant := M.alloc variant in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_newtype_variant
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_newtype_variant" := {
        Notations.double_colon := serialize_newtype_variant (T := T);
      }.
      
      (*
          fn serialize_none(self) -> Result<Value> {
              self.serialize_unit()
          }
      *)
      Definition serialize_none
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_none :
        Notations.DoubleColon Self "serialize_none" := {
        Notations.double_colon := serialize_none;
      }.
      
      (*
          fn serialize_some<T>(self, value: &T) -> Result<Value>
          where
              T: ?Sized + Serialize,
          {
              value.serialize(self)
          }
      *)
      Definition serialize_some
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : Self)
          (value : ref T)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_some
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_some" := {
        Notations.double_colon := serialize_some (T := T);
      }.
      
      (*
          fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {
              Ok(SerializeVec {
                  vec: Vec::with_capacity(len.unwrap_or(0)),
              })
          }
      *)
      Definition serialize_seq
          (self : Self)
          (len : core.option.Option.t usize.t)
          : M ltac:(serde_json.error.Result SerializeSeq) :=
        let* self := M.alloc self in
        let* len := M.alloc len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_seq :
        Notations.DoubleColon Self "serialize_seq" := {
        Notations.double_colon := serialize_seq;
      }.
      
      (*
          fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {
              self.serialize_seq(Some(len))
          }
      *)
      Definition serialize_tuple
          (self : Self)
          (len : usize.t)
          : M ltac:(serde_json.error.Result SerializeTuple) :=
        let* self := M.alloc self in
        let* len := M.alloc len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_tuple :
        Notations.DoubleColon Self "serialize_tuple" := {
        Notations.double_colon := serialize_tuple;
      }.
      
      (*
          fn serialize_tuple_struct(
              self,
              _name: &'static str,
              len: usize,
          ) -> Result<Self::SerializeTupleStruct> {
              self.serialize_seq(Some(len))
          }
      *)
      Definition serialize_tuple_struct
          (self : Self)
          (_name : ref str.t)
          (len : usize.t)
          : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* len := M.alloc len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_tuple_struct :
        Notations.DoubleColon Self "serialize_tuple_struct" := {
        Notations.double_colon := serialize_tuple_struct;
      }.
      
      (*
          fn serialize_tuple_variant(
              self,
              _name: &'static str,
              _variant_index: u32,
              variant: &'static str,
              len: usize,
          ) -> Result<Self::SerializeTupleVariant> {
              Ok(SerializeTupleVariant {
                  name: String::from(variant),
                  vec: Vec::with_capacity(len),
              })
          }
      *)
      Definition serialize_tuple_variant
          (self : Self)
          (_name : ref str.t)
          (_variant_index : u32.t)
          (variant : ref str.t)
          (len : usize.t)
          : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variant_index := M.alloc _variant_index in
        let* variant := M.alloc variant in
        let* len := M.alloc len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_tuple_variant :
        Notations.DoubleColon Self "serialize_tuple_variant" := {
        Notations.double_colon := serialize_tuple_variant;
      }.
      
      (*
          fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {
              Ok(SerializeMap::Map {
                  map: Map::new(),
                  next_key: None,
              })
          }
      *)
      Definition serialize_map
          (self : Self)
          (_len : core.option.Option.t usize.t)
          : M ltac:(serde_json.error.Result SerializeMap) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_map :
        Notations.DoubleColon Self "serialize_map" := {
        Notations.double_colon := serialize_map;
      }.
      
      (*
          fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct> {
              match name {
                  #[cfg(feature = "arbitrary_precision")]
                  crate::number::TOKEN => Ok(SerializeMap::Number { out_value: None }),
                  #[cfg(feature = "raw_value")]
                  crate::raw::TOKEN => Ok(SerializeMap::RawValue { out_value: None }),
                  _ => self.serialize_map(Some(len)),
              }
          }
      *)
      Definition serialize_struct
          (self : Self)
          (name : ref str.t)
          (len : usize.t)
          : M ltac:(serde_json.error.Result SerializeStruct) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* len := M.alloc len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_struct :
        Notations.DoubleColon Self "serialize_struct" := {
        Notations.double_colon := serialize_struct;
      }.
      
      (*
          fn serialize_struct_variant(
              self,
              _name: &'static str,
              _variant_index: u32,
              variant: &'static str,
              _len: usize,
          ) -> Result<Self::SerializeStructVariant> {
              Ok(SerializeStructVariant {
                  name: String::from(variant),
                  map: Map::new(),
              })
          }
      *)
      Definition serialize_struct_variant
          (self : Self)
          (_name : ref str.t)
          (_variant_index : u32.t)
          (variant : ref str.t)
          (_len : usize.t)
          : M ltac:(serde_json.error.Result SerializeStructVariant) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variant_index := M.alloc _variant_index in
        let* variant := M.alloc variant in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_struct_variant :
        Notations.DoubleColon Self "serialize_struct_variant" := {
        Notations.double_colon := serialize_struct_variant;
      }.
      
      (*
          fn collect_str<T>(self, value: &T) -> Result<Value>
          where
              T: ?Sized + Display,
          {
              Ok(Value::String(value.to_string()))
          }
      *)
      Definition collect_str
          {T : Set}
          {ℋ_0 : core.fmt.Display.Trait T}
          (self : Self)
          (value : ref T)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_collect_str
          {T : Set}
          {ℋ_0 : core.fmt.Display.Trait T} :
        Notations.DoubleColon Self "collect_str" := {
        Notations.double_colon := collect_str (T := T);
      }.
      
      Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
        serde.ser.Serializer.Ok := Ok;
        serde.ser.Serializer.Error := Error;
        serde.ser.Serializer.SerializeSeq := SerializeSeq;
        serde.ser.Serializer.SerializeTuple := SerializeTuple;
        serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
        serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
        serde.ser.Serializer.SerializeMap := SerializeMap;
        serde.ser.Serializer.SerializeStruct := SerializeStruct;
        serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
        serde.ser.Serializer.serialize_bool := serialize_bool;
        serde.ser.Serializer.serialize_i8 := serialize_i8;
        serde.ser.Serializer.serialize_i16 := serialize_i16;
        serde.ser.Serializer.serialize_i32 := serialize_i32;
        serde.ser.Serializer.serialize_i64 := serialize_i64;
        serde.ser.Serializer.serialize_i128 := Datatypes.Some serialize_i128;
        serde.ser.Serializer.serialize_u8 := serialize_u8;
        serde.ser.Serializer.serialize_u16 := serialize_u16;
        serde.ser.Serializer.serialize_u32 := serialize_u32;
        serde.ser.Serializer.serialize_u64 := serialize_u64;
        serde.ser.Serializer.serialize_u128 := Datatypes.Some serialize_u128;
        serde.ser.Serializer.serialize_f32 := serialize_f32;
        serde.ser.Serializer.serialize_f64 := serialize_f64;
        serde.ser.Serializer.serialize_char := serialize_char;
        serde.ser.Serializer.serialize_str := serialize_str;
        serde.ser.Serializer.serialize_bytes := serialize_bytes;
        serde.ser.Serializer.serialize_unit := serialize_unit;
        serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
        serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
        serde.ser.Serializer.serialize_newtype_struct
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_newtype_struct (T := T);
        serde.ser.Serializer.serialize_newtype_variant
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_newtype_variant (T := T);
        serde.ser.Serializer.serialize_none := serialize_none;
        serde.ser.Serializer.serialize_some
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_some (T := T);
        serde.ser.Serializer.serialize_seq := serialize_seq;
        serde.ser.Serializer.serialize_tuple := serialize_tuple;
        serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
        serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
        serde.ser.Serializer.serialize_map := serialize_map;
        serde.ser.Serializer.serialize_struct := serialize_struct;
        serde.ser.Serializer.serialize_struct_variant :=
          serialize_struct_variant;
        serde.ser.Serializer.collect_str
          {T : Set}
          {ℋ_0 : core.fmt.Display.Trait T} :=
          Datatypes.Some (collect_str (T := T));
        serde.ser.Serializer.collect_seq := Datatypes.None;
        serde.ser.Serializer.collect_map := Datatypes.None;
        serde.ser.Serializer.is_human_readable := Datatypes.None;
      }.
    End Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
    End Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
    
    Module  SerializeVec.
    Section SerializeVec.
      Record t : Set := {
        vec : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A;
      }.
      
      Definition Get_vec :=
        Ref.map (fun α => Some α.(vec)) (fun β α => Some (α <| vec := β |>)).
    End SerializeVec.
    End SerializeVec.
    
    Module  SerializeTupleVariant.
    Section SerializeTupleVariant.
      Record t : Set := {
        name : alloc.string.String.t;
        vec : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A;
      }.
      
      Definition Get_name :=
        Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
      Definition Get_vec :=
        Ref.map (fun α => Some α.(vec)) (fun β α => Some (α <| vec := β |>)).
    End SerializeTupleVariant.
    End SerializeTupleVariant.
    
    Module SerializeMap.
      Module Map.
        Record t : Set := {
          map :
            serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t;
          next_key : core.option.Option.t alloc.string.String.t;
        }.
      End Map.
      
      Inductive t : Set :=
      | Map (_ : Map.t).
      
      Definition Get_Map_map :=
        Ref.map
          (fun α => match α with | Map α => Some α.(Map.map) end)
          (fun β α =>
            match α with | Map α => Some (Map (α <| Map.map := β |>)) end).
      
      Definition Get_Map_next_key :=
        Ref.map
          (fun α => match α with | Map α => Some α.(Map.next_key) end)
          (fun β α =>
            match α with | Map α => Some (Map (α <| Map.next_key := β |>)) end).
    End SerializeMap.
    
    Module  SerializeStructVariant.
    Section SerializeStructVariant.
      Record t : Set := {
        name : alloc.string.String.t;
        map :
          serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t;
      }.
      
      Definition Get_name :=
        Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
      Definition Get_map :=
        Ref.map (fun α => Some α.(map)) (fun β α => Some (α <| map := β |>)).
    End SerializeStructVariant.
    End SerializeStructVariant.
    
    Module  Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
    Section Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
      Definition Self : Set := serde_json.value.ser.SerializeVec.t.
      
      (*
          type Ok = Value;
      *)
      Definition Ok : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn serialize_element<T>(&mut self, value: &T) -> Result<()>
          where
              T: ?Sized + Serialize,
          {
              self.vec.push(tri!(to_value(value)));
              Ok(())
          }
      *)
      Definition serialize_element
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : mut_ref Self)
          (value : ref T)
          : M ltac:(serde_json.error.Result unit) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_element
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_element" := {
        Notations.double_colon := serialize_element (T := T);
      }.
      
      (*
          fn end(self) -> Result<Value> {
              Ok(Value::Array(self.vec))
          }
      *)
      Definition end_
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_end_ :
        Notations.DoubleColon Self "end_" := {
        Notations.double_colon := end_;
      }.
      
      Global Instance ℐ : serde.ser.SerializeSeq.Trait Self := {
        serde.ser.SerializeSeq.Ok := Ok;
        serde.ser.SerializeSeq.Error := Error;
        serde.ser.SerializeSeq.serialize_element
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_element (T := T);
        serde.ser.SerializeSeq.end_ := end_;
      }.
    End Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
    End Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
    
    Module  Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
    Section Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
      Definition Self : Set := serde_json.value.ser.SerializeVec.t.
      
      (*
          type Ok = Value;
      *)
      Definition Ok : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn serialize_element<T>(&mut self, value: &T) -> Result<()>
          where
              T: ?Sized + Serialize,
          {
              serde::ser::SerializeSeq::serialize_element(self, value)
          }
      *)
      Definition serialize_element
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : mut_ref Self)
          (value : ref T)
          : M ltac:(serde_json.error.Result unit) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_element
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_element" := {
        Notations.double_colon := serialize_element (T := T);
      }.
      
      (*
          fn end(self) -> Result<Value> {
              serde::ser::SerializeSeq::end(self)
          }
      *)
      Definition end_
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_end_ :
        Notations.DoubleColon Self "end_" := {
        Notations.double_colon := end_;
      }.
      
      Global Instance ℐ : serde.ser.SerializeTuple.Trait Self := {
        serde.ser.SerializeTuple.Ok := Ok;
        serde.ser.SerializeTuple.Error := Error;
        serde.ser.SerializeTuple.serialize_element
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_element (T := T);
        serde.ser.SerializeTuple.end_ := end_;
      }.
    End Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
    End Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
    
    Module  Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
    Section Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
      Definition Self : Set := serde_json.value.ser.SerializeVec.t.
      
      (*
          type Ok = Value;
      *)
      Definition Ok : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn serialize_field<T>(&mut self, value: &T) -> Result<()>
          where
              T: ?Sized + Serialize,
          {
              serde::ser::SerializeSeq::serialize_element(self, value)
          }
      *)
      Definition serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : mut_ref Self)
          (value : ref T)
          : M ltac:(serde_json.error.Result unit) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_field" := {
        Notations.double_colon := serialize_field (T := T);
      }.
      
      (*
          fn end(self) -> Result<Value> {
              serde::ser::SerializeSeq::end(self)
          }
      *)
      Definition end_
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_end_ :
        Notations.DoubleColon Self "end_" := {
        Notations.double_colon := end_;
      }.
      
      Global Instance ℐ : serde.ser.SerializeTupleStruct.Trait Self := {
        serde.ser.SerializeTupleStruct.Ok := Ok;
        serde.ser.SerializeTupleStruct.Error := Error;
        serde.ser.SerializeTupleStruct.serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_field (T := T);
        serde.ser.SerializeTupleStruct.end_ := end_;
      }.
    End Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
    End Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
    
    Module  Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
    Section Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
      Definition Self : Set := serde_json.value.ser.SerializeTupleVariant.t.
      
      (*
          type Ok = Value;
      *)
      Definition Ok : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn serialize_field<T>(&mut self, value: &T) -> Result<()>
          where
              T: ?Sized + Serialize,
          {
              self.vec.push(tri!(to_value(value)));
              Ok(())
          }
      *)
      Definition serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : mut_ref Self)
          (value : ref T)
          : M ltac:(serde_json.error.Result unit) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_field" := {
        Notations.double_colon := serialize_field (T := T);
      }.
      
      (*
          fn end(self) -> Result<Value> {
              let mut object = Map::new();
      
              object.insert(self.name, Value::Array(self.vec));
      
              Ok(Value::Object(object))
          }
      *)
      Definition end_
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_end_ :
        Notations.DoubleColon Self "end_" := {
        Notations.double_colon := end_;
      }.
      
      Global Instance ℐ : serde.ser.SerializeTupleVariant.Trait Self := {
        serde.ser.SerializeTupleVariant.Ok := Ok;
        serde.ser.SerializeTupleVariant.Error := Error;
        serde.ser.SerializeTupleVariant.serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_field (T := T);
        serde.ser.SerializeTupleVariant.end_ := end_;
      }.
    End Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
    End Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
    
    Module  Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
    Section Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
      Definition Self : Set := serde_json.value.ser.SerializeMap.t.
      
      (*
          type Ok = Value;
      *)
      Definition Ok : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn serialize_key<T>(&mut self, key: &T) -> Result<()>
          where
              T: ?Sized + Serialize,
          {
              match self {
                  SerializeMap::Map { next_key, .. } => {
                      *next_key = Some(tri!(key.serialize(MapKeySerializer)));
                      Ok(())
                  }
                  #[cfg(feature = "arbitrary_precision")]
                  SerializeMap::Number { .. } => unreachable!(),
                  #[cfg(feature = "raw_value")]
                  SerializeMap::RawValue { .. } => unreachable!(),
              }
          }
      *)
      Definition serialize_key
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : mut_ref Self)
          (key : ref T)
          : M ltac:(serde_json.error.Result unit) :=
        let* self := M.alloc self in
        let* key := M.alloc key in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_key
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_key" := {
        Notations.double_colon := serialize_key (T := T);
      }.
      
      (*
          fn serialize_value<T>(&mut self, value: &T) -> Result<()>
          where
              T: ?Sized + Serialize,
          {
              match self {
                  SerializeMap::Map { map, next_key } => {
                      let key = next_key.take();
                      // Panic because this indicates a bug in the program rather than an
                      // expected failure.
                      let key = key.expect("serialize_value called before serialize_key");
                      map.insert(key, tri!(to_value(value)));
                      Ok(())
                  }
                  #[cfg(feature = "arbitrary_precision")]
                  SerializeMap::Number { .. } => unreachable!(),
                  #[cfg(feature = "raw_value")]
                  SerializeMap::RawValue { .. } => unreachable!(),
              }
          }
      *)
      Definition serialize_value
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : mut_ref Self)
          (value : ref T)
          : M ltac:(serde_json.error.Result unit) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_value
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_value" := {
        Notations.double_colon := serialize_value (T := T);
      }.
      
      (*
          fn end(self) -> Result<Value> {
              match self {
                  SerializeMap::Map { map, .. } => Ok(Value::Object(map)),
                  #[cfg(feature = "arbitrary_precision")]
                  SerializeMap::Number { .. } => unreachable!(),
                  #[cfg(feature = "raw_value")]
                  SerializeMap::RawValue { .. } => unreachable!(),
              }
          }
      *)
      Definition end_
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_end_ :
        Notations.DoubleColon Self "end_" := {
        Notations.double_colon := end_;
      }.
      
      Global Instance ℐ : serde.ser.SerializeMap.Required.Trait Self := {
        serde.ser.SerializeMap.Ok := Ok;
        serde.ser.SerializeMap.Error := Error;
        serde.ser.SerializeMap.serialize_key
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_key (T := T);
        serde.ser.SerializeMap.serialize_value
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_value (T := T);
        serde.ser.SerializeMap.end_ := end_;
        serde.ser.SerializeMap.serialize_entry := Datatypes.None;
      }.
    End Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
    End Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
    
    Module  MapKeySerializer.
    Section MapKeySerializer.
      Inductive t : Set := Build.
    End MapKeySerializer.
    End MapKeySerializer.
    
    (*
    fn key_must_be_a_string() -> Error {
        Error::syntax(ErrorCode::KeyMustBeAString, 0, 0)
    }
    *)
    Definition key_must_be_a_string : M serde_json.error.Error.t := M.read foo.
    
    (*
    fn float_key_must_be_finite() -> Error {
        Error::syntax(ErrorCode::FloatKeyMustBeFinite, 0, 0)
    }
    *)
    Definition float_key_must_be_finite : M serde_json.error.Error.t :=
      M.read foo.
    
    Module  Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
    Section Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
      Definition Self : Set := serde_json.value.ser.MapKeySerializer.t.
      
      (*
          type Ok = String;
      *)
      Definition Ok : Set := alloc.string.String.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          type SerializeSeq = Impossible<String, Error>;
      *)
      Definition SerializeSeq : Set :=
        serde.ser.impossible.Impossible.t
            alloc.string.String.t
            serde_json.error.Error.t.
      
      (*
          type SerializeTuple = Impossible<String, Error>;
      *)
      Definition SerializeTuple : Set :=
        serde.ser.impossible.Impossible.t
            alloc.string.String.t
            serde_json.error.Error.t.
      
      (*
          type SerializeTupleStruct = Impossible<String, Error>;
      *)
      Definition SerializeTupleStruct : Set :=
        serde.ser.impossible.Impossible.t
            alloc.string.String.t
            serde_json.error.Error.t.
      
      (*
          type SerializeTupleVariant = Impossible<String, Error>;
      *)
      Definition SerializeTupleVariant : Set :=
        serde.ser.impossible.Impossible.t
            alloc.string.String.t
            serde_json.error.Error.t.
      
      (*
          type SerializeMap = Impossible<String, Error>;
      *)
      Definition SerializeMap : Set :=
        serde.ser.impossible.Impossible.t
            alloc.string.String.t
            serde_json.error.Error.t.
      
      (*
          type SerializeStruct = Impossible<String, Error>;
      *)
      Definition SerializeStruct : Set :=
        serde.ser.impossible.Impossible.t
            alloc.string.String.t
            serde_json.error.Error.t.
      
      (*
          type SerializeStructVariant = Impossible<String, Error>;
      *)
      Definition SerializeStructVariant : Set :=
        serde.ser.impossible.Impossible.t
            alloc.string.String.t
            serde_json.error.Error.t.
      
      (*
          fn serialize_unit_variant(
              self,
              _name: &'static str,
              _variant_index: u32,
              variant: &'static str,
          ) -> Result<String> {
              Ok(variant.to_owned())
          }
      *)
      Definition serialize_unit_variant
          (self : Self)
          (_name : ref str.t)
          (_variant_index : u32.t)
          (variant : ref str.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variant_index := M.alloc _variant_index in
        let* variant := M.alloc variant in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_unit_variant :
        Notations.DoubleColon Self "serialize_unit_variant" := {
        Notations.double_colon := serialize_unit_variant;
      }.
      
      (*
          fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<String>
          where
              T: ?Sized + Serialize,
          {
              value.serialize(self)
          }
      *)
      Definition serialize_newtype_struct
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : Self)
          (_name : ref str.t)
          (value : ref T)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_newtype_struct
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_newtype_struct" := {
        Notations.double_colon := serialize_newtype_struct (T := T);
      }.
      
      (*
          fn serialize_bool(self, value: bool) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_bool
          (self : Self)
          (value : bool.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_bool :
        Notations.DoubleColon Self "serialize_bool" := {
        Notations.double_colon := serialize_bool;
      }.
      
      (*
          fn serialize_i8(self, value: i8) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_i8
          (self : Self)
          (value : i8.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i8 :
        Notations.DoubleColon Self "serialize_i8" := {
        Notations.double_colon := serialize_i8;
      }.
      
      (*
          fn serialize_i16(self, value: i16) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_i16
          (self : Self)
          (value : i16.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i16 :
        Notations.DoubleColon Self "serialize_i16" := {
        Notations.double_colon := serialize_i16;
      }.
      
      (*
          fn serialize_i32(self, value: i32) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_i32
          (self : Self)
          (value : i32.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i32 :
        Notations.DoubleColon Self "serialize_i32" := {
        Notations.double_colon := serialize_i32;
      }.
      
      (*
          fn serialize_i64(self, value: i64) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_i64
          (self : Self)
          (value : i64.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_i64 :
        Notations.DoubleColon Self "serialize_i64" := {
        Notations.double_colon := serialize_i64;
      }.
      
      (*
          fn serialize_u8(self, value: u8) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_u8
          (self : Self)
          (value : u8.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u8 :
        Notations.DoubleColon Self "serialize_u8" := {
        Notations.double_colon := serialize_u8;
      }.
      
      (*
          fn serialize_u16(self, value: u16) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_u16
          (self : Self)
          (value : u16.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u16 :
        Notations.DoubleColon Self "serialize_u16" := {
        Notations.double_colon := serialize_u16;
      }.
      
      (*
          fn serialize_u32(self, value: u32) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_u32
          (self : Self)
          (value : u32.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u32 :
        Notations.DoubleColon Self "serialize_u32" := {
        Notations.double_colon := serialize_u32;
      }.
      
      (*
          fn serialize_u64(self, value: u64) -> Result<String> {
              Ok(value.to_string())
          }
      *)
      Definition serialize_u64
          (self : Self)
          (value : u64.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_u64 :
        Notations.DoubleColon Self "serialize_u64" := {
        Notations.double_colon := serialize_u64;
      }.
      
      (*
          fn serialize_f32(self, value: f32) -> Result<String> {
              if value.is_finite() {
                  Ok(ryu::Buffer::new().format_finite(value).to_owned())
              } else {
                  Err(float_key_must_be_finite())
              }
          }
      *)
      Definition serialize_f32
          (self : Self)
          (value : f32.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_f32 :
        Notations.DoubleColon Self "serialize_f32" := {
        Notations.double_colon := serialize_f32;
      }.
      
      (*
          fn serialize_f64(self, value: f64) -> Result<String> {
              if value.is_finite() {
                  Ok(ryu::Buffer::new().format_finite(value).to_owned())
              } else {
                  Err(float_key_must_be_finite())
              }
          }
      *)
      Definition serialize_f64
          (self : Self)
          (value : f64.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_f64 :
        Notations.DoubleColon Self "serialize_f64" := {
        Notations.double_colon := serialize_f64;
      }.
      
      (*
          fn serialize_char(self, value: char) -> Result<String> {
              Ok({
                  let mut s = String::new();
                  s.push(value);
                  s
              })
          }
      *)
      Definition serialize_char
          (self : Self)
          (value : char.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_char :
        Notations.DoubleColon Self "serialize_char" := {
        Notations.double_colon := serialize_char;
      }.
      
      (*
          fn serialize_str(self, value: &str) -> Result<String> {
              Ok(value.to_owned())
          }
      *)
      Definition serialize_str
          (self : Self)
          (value : ref str.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_str :
        Notations.DoubleColon Self "serialize_str" := {
        Notations.double_colon := serialize_str;
      }.
      
      (*
          fn serialize_bytes(self, _value: &[u8]) -> Result<String> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_bytes
          (self : Self)
          (_value : ref (slice u8.t))
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* _value := M.alloc _value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_bytes :
        Notations.DoubleColon Self "serialize_bytes" := {
        Notations.double_colon := serialize_bytes;
      }.
      
      (*
          fn serialize_unit(self) -> Result<String> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_unit
          (self : Self)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_unit :
        Notations.DoubleColon Self "serialize_unit" := {
        Notations.double_colon := serialize_unit;
      }.
      
      (*
          fn serialize_unit_struct(self, _name: &'static str) -> Result<String> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_unit_struct
          (self : Self)
          (_name : ref str.t)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_unit_struct :
        Notations.DoubleColon Self "serialize_unit_struct" := {
        Notations.double_colon := serialize_unit_struct;
      }.
      
      (*
          fn serialize_newtype_variant<T>(
              self,
              _name: &'static str,
              _variant_index: u32,
              _variant: &'static str,
              _value: &T,
          ) -> Result<String>
          where
              T: ?Sized + Serialize,
          {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_newtype_variant
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : Self)
          (_name : ref str.t)
          (_variant_index : u32.t)
          (_variant : ref str.t)
          (_value : ref T)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variant_index := M.alloc _variant_index in
        let* _variant := M.alloc _variant in
        let* _value := M.alloc _value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_newtype_variant
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_newtype_variant" := {
        Notations.double_colon := serialize_newtype_variant (T := T);
      }.
      
      (*
          fn serialize_none(self) -> Result<String> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_none
          (self : Self)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_none :
        Notations.DoubleColon Self "serialize_none" := {
        Notations.double_colon := serialize_none;
      }.
      
      (*
          fn serialize_some<T>(self, _value: &T) -> Result<String>
          where
              T: ?Sized + Serialize,
          {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_some
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : Self)
          (_value : ref T)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* _value := M.alloc _value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_some
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_some" := {
        Notations.double_colon := serialize_some (T := T);
      }.
      
      (*
          fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_seq
          (self : Self)
          (_len : core.option.Option.t usize.t)
          : M ltac:(serde_json.error.Result SerializeSeq) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_seq :
        Notations.DoubleColon Self "serialize_seq" := {
        Notations.double_colon := serialize_seq;
      }.
      
      (*
          fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_tuple
          (self : Self)
          (_len : usize.t)
          : M ltac:(serde_json.error.Result SerializeTuple) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_tuple :
        Notations.DoubleColon Self "serialize_tuple" := {
        Notations.double_colon := serialize_tuple;
      }.
      
      (*
          fn serialize_tuple_struct(
              self,
              _name: &'static str,
              _len: usize,
          ) -> Result<Self::SerializeTupleStruct> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_tuple_struct
          (self : Self)
          (_name : ref str.t)
          (_len : usize.t)
          : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_tuple_struct :
        Notations.DoubleColon Self "serialize_tuple_struct" := {
        Notations.double_colon := serialize_tuple_struct;
      }.
      
      (*
          fn serialize_tuple_variant(
              self,
              _name: &'static str,
              _variant_index: u32,
              _variant: &'static str,
              _len: usize,
          ) -> Result<Self::SerializeTupleVariant> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_tuple_variant
          (self : Self)
          (_name : ref str.t)
          (_variant_index : u32.t)
          (_variant : ref str.t)
          (_len : usize.t)
          : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variant_index := M.alloc _variant_index in
        let* _variant := M.alloc _variant in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_tuple_variant :
        Notations.DoubleColon Self "serialize_tuple_variant" := {
        Notations.double_colon := serialize_tuple_variant;
      }.
      
      (*
          fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_map
          (self : Self)
          (_len : core.option.Option.t usize.t)
          : M ltac:(serde_json.error.Result SerializeMap) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_map :
        Notations.DoubleColon Self "serialize_map" := {
        Notations.double_colon := serialize_map;
      }.
      
      (*
          fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_struct
          (self : Self)
          (_name : ref str.t)
          (_len : usize.t)
          : M ltac:(serde_json.error.Result SerializeStruct) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_struct :
        Notations.DoubleColon Self "serialize_struct" := {
        Notations.double_colon := serialize_struct;
      }.
      
      (*
          fn serialize_struct_variant(
              self,
              _name: &'static str,
              _variant_index: u32,
              _variant: &'static str,
              _len: usize,
          ) -> Result<Self::SerializeStructVariant> {
              Err(key_must_be_a_string())
          }
      *)
      Definition serialize_struct_variant
          (self : Self)
          (_name : ref str.t)
          (_variant_index : u32.t)
          (_variant : ref str.t)
          (_len : usize.t)
          : M ltac:(serde_json.error.Result SerializeStructVariant) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variant_index := M.alloc _variant_index in
        let* _variant := M.alloc _variant in
        let* _len := M.alloc _len in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_struct_variant :
        Notations.DoubleColon Self "serialize_struct_variant" := {
        Notations.double_colon := serialize_struct_variant;
      }.
      
      (*
          fn collect_str<T>(self, value: &T) -> Result<String>
          where
              T: ?Sized + Display,
          {
              Ok(value.to_string())
          }
      *)
      Definition collect_str
          {T : Set}
          {ℋ_0 : core.fmt.Display.Trait T}
          (self : Self)
          (value : ref T)
          : M ltac:(serde_json.error.Result alloc.string.String.t) :=
        let* self := M.alloc self in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_collect_str
          {T : Set}
          {ℋ_0 : core.fmt.Display.Trait T} :
        Notations.DoubleColon Self "collect_str" := {
        Notations.double_colon := collect_str (T := T);
      }.
      
      Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
        serde.ser.Serializer.Ok := Ok;
        serde.ser.Serializer.Error := Error;
        serde.ser.Serializer.SerializeSeq := SerializeSeq;
        serde.ser.Serializer.SerializeTuple := SerializeTuple;
        serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
        serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
        serde.ser.Serializer.SerializeMap := SerializeMap;
        serde.ser.Serializer.SerializeStruct := SerializeStruct;
        serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
        serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
        serde.ser.Serializer.serialize_newtype_struct
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_newtype_struct (T := T);
        serde.ser.Serializer.serialize_bool := serialize_bool;
        serde.ser.Serializer.serialize_i8 := serialize_i8;
        serde.ser.Serializer.serialize_i16 := serialize_i16;
        serde.ser.Serializer.serialize_i32 := serialize_i32;
        serde.ser.Serializer.serialize_i64 := serialize_i64;
        serde.ser.Serializer.serialize_u8 := serialize_u8;
        serde.ser.Serializer.serialize_u16 := serialize_u16;
        serde.ser.Serializer.serialize_u32 := serialize_u32;
        serde.ser.Serializer.serialize_u64 := serialize_u64;
        serde.ser.Serializer.serialize_f32 := serialize_f32;
        serde.ser.Serializer.serialize_f64 := serialize_f64;
        serde.ser.Serializer.serialize_char := serialize_char;
        serde.ser.Serializer.serialize_str := serialize_str;
        serde.ser.Serializer.serialize_bytes := serialize_bytes;
        serde.ser.Serializer.serialize_unit := serialize_unit;
        serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
        serde.ser.Serializer.serialize_newtype_variant
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_newtype_variant (T := T);
        serde.ser.Serializer.serialize_none := serialize_none;
        serde.ser.Serializer.serialize_some
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_some (T := T);
        serde.ser.Serializer.serialize_seq := serialize_seq;
        serde.ser.Serializer.serialize_tuple := serialize_tuple;
        serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
        serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
        serde.ser.Serializer.serialize_map := serialize_map;
        serde.ser.Serializer.serialize_struct := serialize_struct;
        serde.ser.Serializer.serialize_struct_variant :=
          serialize_struct_variant;
        serde.ser.Serializer.collect_str
          {T : Set}
          {ℋ_0 : core.fmt.Display.Trait T} :=
          Datatypes.Some (collect_str (T := T));
        serde.ser.Serializer.serialize_i128 := Datatypes.None;
        serde.ser.Serializer.serialize_u128 := Datatypes.None;
        serde.ser.Serializer.collect_seq := Datatypes.None;
        serde.ser.Serializer.collect_map := Datatypes.None;
        serde.ser.Serializer.is_human_readable := Datatypes.None;
      }.
    End Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
    End Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
    
    Module  Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
    Section Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
      Definition Self : Set := serde_json.value.ser.SerializeMap.t.
      
      (*
          type Ok = Value;
      *)
      Definition Ok : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
          where
              T: ?Sized + Serialize,
          {
              match self {
                  SerializeMap::Map { .. } => serde::ser::SerializeMap::serialize_entry(self, key, value),
                  #[cfg(feature = "arbitrary_precision")]
                  SerializeMap::Number { out_value } => {
                      if key == crate::number::TOKEN {
                          *out_value = Some(tri!(value.serialize(NumberValueEmitter)));
                          Ok(())
                      } else {
                          Err(invalid_number())
                      }
                  }
                  #[cfg(feature = "raw_value")]
                  SerializeMap::RawValue { out_value } => {
                      if key == crate::raw::TOKEN {
                          *out_value = Some(tri!(value.serialize(RawValueEmitter)));
                          Ok(())
                      } else {
                          Err(invalid_raw_value())
                      }
                  }
              }
          }
      *)
      Definition serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : mut_ref Self)
          (key : ref str.t)
          (value : ref T)
          : M ltac:(serde_json.error.Result unit) :=
        let* self := M.alloc self in
        let* key := M.alloc key in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_field" := {
        Notations.double_colon := serialize_field (T := T);
      }.
      
      (*
          fn end(self) -> Result<Value> {
              match self {
                  SerializeMap::Map { .. } => serde::ser::SerializeMap::end(self),
                  #[cfg(feature = "arbitrary_precision")]
                  SerializeMap::Number { out_value, .. } => {
                      Ok(out_value.expect("number value was not emitted"))
                  }
                  #[cfg(feature = "raw_value")]
                  SerializeMap::RawValue { out_value, .. } => {
                      Ok(out_value.expect("raw value was not emitted"))
                  }
              }
          }
      *)
      Definition end_
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_end_ :
        Notations.DoubleColon Self "end_" := {
        Notations.double_colon := end_;
      }.
      
      Global Instance ℐ : serde.ser.SerializeStruct.Required.Trait Self := {
        serde.ser.SerializeStruct.Ok := Ok;
        serde.ser.SerializeStruct.Error := Error;
        serde.ser.SerializeStruct.serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_field (T := T);
        serde.ser.SerializeStruct.end_ := end_;
        serde.ser.SerializeStruct.skip_field := Datatypes.None;
      }.
    End Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
    End Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
    
    Module  Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
    Section Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
      Definition Self : Set := serde_json.value.ser.SerializeStructVariant.t.
      
      (*
          type Ok = Value;
      *)
      Definition Ok : Set := serde_json.value.Value.t.
      
      (*
          type Error = Error;
      *)
      Definition Error : Set := serde_json.error.Error.t.
      
      (*
          fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
          where
              T: ?Sized + Serialize,
          {
              self.map.insert(String::from(key), tri!(to_value(value)));
              Ok(())
          }
      *)
      Definition serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : mut_ref Self)
          (key : ref str.t)
          (value : ref T)
          : M ltac:(serde_json.error.Result unit) :=
        let* self := M.alloc self in
        let* key := M.alloc key in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "serialize_field" := {
        Notations.double_colon := serialize_field (T := T);
      }.
      
      (*
          fn end(self) -> Result<Value> {
              let mut object = Map::new();
      
              object.insert(self.name, Value::Object(self.map));
      
              Ok(Value::Object(object))
          }
      *)
      Definition end_
          (self : Self)
          : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_end_ :
        Notations.DoubleColon Self "end_" := {
        Notations.double_colon := end_;
      }.
      
      Global Instance ℐ :
        serde.ser.SerializeStructVariant.Required.Trait Self := {
        serde.ser.SerializeStructVariant.Ok := Ok;
        serde.ser.SerializeStructVariant.Error := Error;
        serde.ser.SerializeStructVariant.serialize_field
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :=
          serialize_field (T := T);
        serde.ser.SerializeStructVariant.end_ := end_;
        serde.ser.SerializeStructVariant.skip_field := Datatypes.None;
      }.
    End Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
    End Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
  End ser.
  
  (*
  pub fn to_value<T>(value: T) -> Result<Value, Error>
  where
      T: Serialize,
  {
      value.serialize(Serializer)
  }
  *)
  Definition to_value
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (value : T)
      :
        M
          (core.result.Result.t
            serde_json.value.Value.t
            serde_json.error.Error.t) :=
    let* value := M.alloc value in
    M.read foo.
  
  (*
  pub fn from_value<T>(value: Value) -> Result<T, Error>
  where
      T: DeserializeOwned,
  {
      T::deserialize(value)
  }
  *)
  Definition from_value
      {T : Set}
      {ℋ_0 : serde.de.DeserializeOwned.Trait T}
      (value : serde_json.value.Value.t)
      : M (core.result.Result.t T serde_json.error.Error.t) :=
    let* value := M.alloc value in
    M.read foo.
End value.

Module Value.
  Inductive t : Set :=
  | Null
  | Bool (_ : bool.t)
  | Number (_ : serde_json.number.Number.t)
  | String (_ : alloc.string.String.t)
  | Array (_ : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A)
  |
    Object
    (_ : serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t).
  
  Definition Get_Bool_0 :=
    Ref.map
      (fun α => match α with | Bool α0 => Some α0 | _ => None end)
      (fun β α => match α with | Bool _ => Some (Bool β) | _ => None end).
  
  Definition Get_Number_0 :=
    Ref.map
      (fun α => match α with | Number α0 => Some α0 | _ => None end)
      (fun β α => match α with | Number _ => Some (Number β) | _ => None end).
  
  Definition Get_String_0 :=
    Ref.map
      (fun α => match α with | String α0 => Some α0 | _ => None end)
      (fun β α => match α with | String _ => Some (String β) | _ => None end).
  
  Definition Get_Array_0 :=
    Ref.map
      (fun α => match α with | Array α0 => Some α0 | _ => None end)
      (fun β α => match α with | Array _ => Some (Array β) | _ => None end).
  
  Definition Get_Object_0 :=
    Ref.map
      (fun α => match α with | Object α0 => Some α0 | _ => None end)
      (fun β α => match α with | Object _ => Some (Object β) | _ => None end).
End Value.

Module  Impl_core_clone_Clone_for_serde_json_value_Value_t.
Section Impl_core_clone_Clone_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M serde_json.value.Value.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_serde_json_value_Value_t.
End Impl_core_clone_Clone_for_serde_json_value_Value_t.

Module  Impl_core_marker_StructuralEq_for_serde_json_value_Value_t.
Section Impl_core_marker_StructuralEq_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_serde_json_value_Value_t.
End Impl_core_marker_StructuralEq_for_serde_json_value_Value_t.

Module  Impl_core_cmp_Eq_for_serde_json_value_Value_t.
Section Impl_core_cmp_Eq_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_serde_json_value_Value_t.
End Impl_core_cmp_Eq_for_serde_json_value_Value_t.

Module  Impl_core_marker_StructuralPartialEq_for_serde_json_value_Value_t.
Section Impl_core_marker_StructuralPartialEq_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_serde_json_value_Value_t.
End Impl_core_marker_StructuralPartialEq_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_for_serde_json_value_Value_t.

Module  Impl_core_fmt_Debug_for_serde_json_value_Value_t.
Section Impl_core_fmt_Debug_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
          match self {
              Value::Null => formatter.write_str("Null"),
              Value::Bool(boolean) => write!(formatter, "Bool({})", boolean),
              Value::Number(number) => Debug::fmt(number, formatter),
              Value::String(string) => write!(formatter, "String({:?})", string),
              Value::Array(vec) => {
                  tri!(formatter.write_str("Array "));
                  Debug::fmt(vec, formatter)
              }
              Value::Object(map) => {
                  tri!(formatter.write_str("Object "));
                  Debug::fmt(map, formatter)
              }
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_serde_json_value_Value_t.
End Impl_core_fmt_Debug_for_serde_json_value_Value_t.

Module  Impl_core_fmt_Display_for_serde_json_value_Value_t.
Section Impl_core_fmt_Display_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
          struct WriterFormatter<'a, 'b: 'a> {
              inner: &'a mut fmt::Formatter<'b>,
          }
  
          impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {
              fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                  // Safety: the serializer below only emits valid utf8 when using
                  // the default formatter.
                  let s = unsafe { str::from_utf8_unchecked(buf) };
                  tri!(self.inner.write_str(s).map_err(io_error));
                  Ok(buf.len())
              }
  
              fn flush(&mut self) -> io::Result<()> {
                  Ok(())
              }
          }
  
          fn io_error(_: fmt::Error) -> io::Error {
              // Error value does not matter because Display impl just maps it
              // back to fmt::Error.
              io::Error::new(io::ErrorKind::Other, "fmt error")
          }
  
          let alternate = f.alternate();
          let mut wr = WriterFormatter { inner: f };
          if alternate {
              // {:#}
              super::ser::to_writer_pretty(&mut wr, self).map_err(|_| fmt::Error)
          } else {
              // {}
              super::ser::to_writer(&mut wr, self).map_err(|_| fmt::Error)
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_serde_json_value_Value_t.
End Impl_core_fmt_Display_for_serde_json_value_Value_t.

Module  WriterFormatter.
Section WriterFormatter.
  Record t : Set := {
    inner : mut_ref core.fmt.Formatter.t;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End WriterFormatter.
End WriterFormatter.

Module  Impl_std_io_Write_for_serde_json_value_fmt_WriterFormatter_t.
Section Impl_std_io_Write_for_serde_json_value_fmt_WriterFormatter_t.
  Definition Self : Set := serde_json.value.fmt.WriterFormatter.t.
  
  (*
              fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                  // Safety: the serializer below only emits valid utf8 when using
                  // the default formatter.
                  let s = unsafe { str::from_utf8_unchecked(buf) };
                  tri!(self.inner.write_str(s).map_err(io_error));
                  Ok(buf.len())
              }
  *)
  Definition write
      (self : mut_ref Self)
      (buf : ref (slice u8.t))
      : M ltac:(std.io.error.Result usize.t) :=
    let* self := M.alloc self in
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_write :
    Notations.DoubleColon Self "write" := {
    Notations.double_colon := write;
  }.
  
  (*
              fn flush(&mut self) -> io::Result<()> {
                  Ok(())
              }
  *)
  Definition flush (self : mut_ref Self) : M ltac:(std.io.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_flush :
    Notations.DoubleColon Self "flush" := {
    Notations.double_colon := flush;
  }.
  
  Global Instance ℐ : std.io.Write.Required.Trait Self := {
    std.io.Write.write := write;
    std.io.Write.flush := flush;
    std.io.Write.write_vectored := Datatypes.None;
    std.io.Write.is_write_vectored := Datatypes.None;
    std.io.Write.write_all := Datatypes.None;
    std.io.Write.write_all_vectored := Datatypes.None;
    std.io.Write.write_fmt := Datatypes.None;
    std.io.Write.by_ref := Datatypes.None;
  }.
End Impl_std_io_Write_for_serde_json_value_fmt_WriterFormatter_t.
End Impl_std_io_Write_for_serde_json_value_fmt_WriterFormatter_t.

(*
        fn io_error(_: fmt::Error) -> io::Error {
            // Error value does not matter because Display impl just maps it
            // back to fmt::Error.
            io::Error::new(io::ErrorKind::Other, "fmt error")
        }
*)
Definition io_error (arg : core.fmt.Error.t) : M std.io.error.Error.t :=
  let* arg := M.alloc arg in
  M.read foo.

(*
fn parse_index(s: &str) -> Option<usize> {
    if s.starts_with('+') || (s.starts_with('0') && s.len() != 1) {
        return None;
    }
    s.parse().ok()
}
*)
Definition parse_index (s : ref str.t) : M (core.option.Option.t usize.t) :=
  let* s := M.alloc s in
  M.read foo.

Module  Impl_serde_json_value_Value_t_3.
Section Impl_serde_json_value_Value_t_3.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      pub fn get<I: Index>(&self, index: I) -> Option<&Value> {
          index.index_into(self)
      }
  *)
  Definition get
      {I : Set}
      {ℋ_0 : serde_json.value.index.Index.Trait I}
      (self : ref Self)
      (index : I)
      : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* index := M.alloc index in
    M.read foo.
  
  Global Instance AssociatedFunction_get
      {I : Set}
      {ℋ_0 : serde_json.value.index.Index.Trait I} :
    Notations.DoubleColon Self "get" := {
    Notations.double_colon := get (I := I);
  }.
  
  (*
      pub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value> {
          index.index_into_mut(self)
      }
  *)
  Definition get_mut
      {I : Set}
      {ℋ_0 : serde_json.value.index.Index.Trait I}
      (self : mut_ref Self)
      (index : I)
      : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* index := M.alloc index in
    M.read foo.
  
  Global Instance AssociatedFunction_get_mut
      {I : Set}
      {ℋ_0 : serde_json.value.index.Index.Trait I} :
    Notations.DoubleColon Self "get_mut" := {
    Notations.double_colon := get_mut (I := I);
  }.
  
  (*
      pub fn is_object(&self) -> bool {
          self.as_object().is_some()
      }
  *)
  Definition is_object (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_object :
    Notations.DoubleColon Self "is_object" := {
    Notations.double_colon := is_object;
  }.
  
  (*
      pub fn as_object(&self) -> Option<&Map<String, Value>> {
          match self {
              Value::Object(map) => Some(map),
              _ => None,
          }
      }
  *)
  Definition as_object
      (self : ref Self)
      :
        M
          (core.option.Option.t
            (ref
              (serde_json.map.Map.t
                alloc.string.String.t
                serde_json.value.Value.t))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_object :
    Notations.DoubleColon Self "as_object" := {
    Notations.double_colon := as_object;
  }.
  
  (*
      pub fn as_object_mut(&mut self) -> Option<&mut Map<String, Value>> {
          match self {
              Value::Object(map) => Some(map),
              _ => None,
          }
      }
  *)
  Definition as_object_mut
      (self : mut_ref Self)
      :
        M
          (core.option.Option.t
            (mut_ref
              (serde_json.map.Map.t
                alloc.string.String.t
                serde_json.value.Value.t))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_object_mut :
    Notations.DoubleColon Self "as_object_mut" := {
    Notations.double_colon := as_object_mut;
  }.
  
  (*
      pub fn is_array(&self) -> bool {
          self.as_array().is_some()
      }
  *)
  Definition is_array (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_array :
    Notations.DoubleColon Self "is_array" := {
    Notations.double_colon := is_array;
  }.
  
  (*
      pub fn as_array(&self) -> Option<&Vec<Value>> {
          match self {
              Value::Array(array) => Some(array),
              _ => None,
          }
      }
  *)
  Definition as_array
      (self : ref Self)
      :
        M
          (core.option.Option.t
            (ref
              (alloc.vec.Vec.t
                serde_json.value.Value.t
                alloc.vec.Vec.Default.A))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_array :
    Notations.DoubleColon Self "as_array" := {
    Notations.double_colon := as_array;
  }.
  
  (*
      pub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>> {
          match self {
              Value::Array(list) => Some(list),
              _ => None,
          }
      }
  *)
  Definition as_array_mut
      (self : mut_ref Self)
      :
        M
          (core.option.Option.t
            (mut_ref
              (alloc.vec.Vec.t
                serde_json.value.Value.t
                alloc.vec.Vec.Default.A))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_array_mut :
    Notations.DoubleColon Self "as_array_mut" := {
    Notations.double_colon := as_array_mut;
  }.
  
  (*
      pub fn is_string(&self) -> bool {
          self.as_str().is_some()
      }
  *)
  Definition is_string (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_string :
    Notations.DoubleColon Self "is_string" := {
    Notations.double_colon := is_string;
  }.
  
  (*
      pub fn as_str(&self) -> Option<&str> {
          match self {
              Value::String(s) => Some(s),
              _ => None,
          }
      }
  *)
  Definition as_str (self : ref Self) : M (core.option.Option.t (ref str.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_str :
    Notations.DoubleColon Self "as_str" := {
    Notations.double_colon := as_str;
  }.
  
  (*
      pub fn is_number(&self) -> bool {
          match *self {
              Value::Number(_) => true,
              _ => false,
          }
      }
  *)
  Definition is_number (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_number :
    Notations.DoubleColon Self "is_number" := {
    Notations.double_colon := is_number;
  }.
  
  (*
      pub fn as_number(&self) -> Option<&Number> {
          match self {
              Value::Number(number) => Some(number),
              _ => None,
          }
      }
  *)
  Definition as_number
      (self : ref Self)
      : M (core.option.Option.t (ref serde_json.number.Number.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_number :
    Notations.DoubleColon Self "as_number" := {
    Notations.double_colon := as_number;
  }.
  
  (*
      pub fn is_i64(&self) -> bool {
          match self {
              Value::Number(n) => n.is_i64(),
              _ => false,
          }
      }
  *)
  Definition is_i64 (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_i64 :
    Notations.DoubleColon Self "is_i64" := {
    Notations.double_colon := is_i64;
  }.
  
  (*
      pub fn is_u64(&self) -> bool {
          match self {
              Value::Number(n) => n.is_u64(),
              _ => false,
          }
      }
  *)
  Definition is_u64 (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_u64 :
    Notations.DoubleColon Self "is_u64" := {
    Notations.double_colon := is_u64;
  }.
  
  (*
      pub fn is_f64(&self) -> bool {
          match self {
              Value::Number(n) => n.is_f64(),
              _ => false,
          }
      }
  *)
  Definition is_f64 (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_f64 :
    Notations.DoubleColon Self "is_f64" := {
    Notations.double_colon := is_f64;
  }.
  
  (*
      pub fn as_i64(&self) -> Option<i64> {
          match self {
              Value::Number(n) => n.as_i64(),
              _ => None,
          }
      }
  *)
  Definition as_i64 (self : ref Self) : M (core.option.Option.t i64.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_i64 :
    Notations.DoubleColon Self "as_i64" := {
    Notations.double_colon := as_i64;
  }.
  
  (*
      pub fn as_u64(&self) -> Option<u64> {
          match self {
              Value::Number(n) => n.as_u64(),
              _ => None,
          }
      }
  *)
  Definition as_u64 (self : ref Self) : M (core.option.Option.t u64.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_u64 :
    Notations.DoubleColon Self "as_u64" := {
    Notations.double_colon := as_u64;
  }.
  
  (*
      pub fn as_f64(&self) -> Option<f64> {
          match self {
              Value::Number(n) => n.as_f64(),
              _ => None,
          }
      }
  *)
  Definition as_f64 (self : ref Self) : M (core.option.Option.t f64.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_f64 :
    Notations.DoubleColon Self "as_f64" := {
    Notations.double_colon := as_f64;
  }.
  
  (*
      pub fn is_boolean(&self) -> bool {
          self.as_bool().is_some()
      }
  *)
  Definition is_boolean (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_boolean :
    Notations.DoubleColon Self "is_boolean" := {
    Notations.double_colon := is_boolean;
  }.
  
  (*
      pub fn as_bool(&self) -> Option<bool> {
          match *self {
              Value::Bool(b) => Some(b),
              _ => None,
          }
      }
  *)
  Definition as_bool (self : ref Self) : M (core.option.Option.t bool.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_bool :
    Notations.DoubleColon Self "as_bool" := {
    Notations.double_colon := as_bool;
  }.
  
  (*
      pub fn is_null(&self) -> bool {
          self.as_null().is_some()
      }
  *)
  Definition is_null (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_null :
    Notations.DoubleColon Self "is_null" := {
    Notations.double_colon := is_null;
  }.
  
  (*
      pub fn as_null(&self) -> Option<()> {
          match *self {
              Value::Null => Some(()),
              _ => None,
          }
      }
  *)
  Definition as_null (self : ref Self) : M (core.option.Option.t unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_null :
    Notations.DoubleColon Self "as_null" := {
    Notations.double_colon := as_null;
  }.
  
  (*
      pub fn pointer(&self, pointer: &str) -> Option<&Value> {
          if pointer.is_empty() {
              return Some(self);
          }
          if !pointer.starts_with('/') {
              return None;
          }
          pointer
              .split('/')
              .skip(1)
              .map(|x| x.replace("~1", "/").replace("~0", "~"))
              .try_fold(self, |target, token| match target {
                  Value::Object(map) => map.get(&token),
                  Value::Array(list) => parse_index(&token).and_then(|x| list.get(x)),
                  _ => None,
              })
      }
  *)
  Definition pointer
      (self : ref Self)
      (pointer : ref str.t)
      : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* pointer := M.alloc pointer in
    M.read foo.
  
  Global Instance AssociatedFunction_pointer :
    Notations.DoubleColon Self "pointer" := {
    Notations.double_colon := pointer;
  }.
  
  (*
      pub fn pointer_mut(&mut self, pointer: &str) -> Option<&mut Value> {
          if pointer.is_empty() {
              return Some(self);
          }
          if !pointer.starts_with('/') {
              return None;
          }
          pointer
              .split('/')
              .skip(1)
              .map(|x| x.replace("~1", "/").replace("~0", "~"))
              .try_fold(self, |target, token| match target {
                  Value::Object(map) => map.get_mut(&token),
                  Value::Array(list) => parse_index(&token).and_then(move |x| list.get_mut(x)),
                  _ => None,
              })
      }
  *)
  Definition pointer_mut
      (self : mut_ref Self)
      (pointer : ref str.t)
      : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* pointer := M.alloc pointer in
    M.read foo.
  
  Global Instance AssociatedFunction_pointer_mut :
    Notations.DoubleColon Self "pointer_mut" := {
    Notations.double_colon := pointer_mut;
  }.
  
  (*
      pub fn take(&mut self) -> Value {
          mem::replace(self, Value::Null)
      }
  *)
  Definition take (self : mut_ref Self) : M serde_json.value.Value.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_serde_json_value_Value_t_3.
End Impl_serde_json_value_Value_t_3.

Module  Impl_core_default_Default_for_serde_json_value_Value_t.
Section Impl_core_default_Default_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn default() -> Value {
          Value::Null
      }
  *)
  Definition default : M serde_json.value.Value.t := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_serde_json_value_Value_t.
End Impl_core_default_Default_for_serde_json_value_Value_t.

Module Wrap_de_1.
Module de.
  Module  Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
  Section Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            struct ValueVisitor;
    
            impl<'de> Visitor<'de> for ValueVisitor {
                type Value = Value;
    
                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("any valid JSON value")
                }
    
                #[inline]
                fn visit_bool<E>(self, value: bool) -> Result<Value, E> {
                    Ok(Value::Bool(value))
                }
    
                #[inline]
                fn visit_i64<E>(self, value: i64) -> Result<Value, E> {
                    Ok(Value::Number(value.into()))
                }
    
                #[inline]
                fn visit_u64<E>(self, value: u64) -> Result<Value, E> {
                    Ok(Value::Number(value.into()))
                }
    
                #[inline]
                fn visit_f64<E>(self, value: f64) -> Result<Value, E> {
                    Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))
                }
    
                #[cfg(any(feature = "std", feature = "alloc"))]
                #[inline]
                fn visit_str<E>(self, value: &str) -> Result<Value, E>
                where
                    E: serde::de::Error,
                {
                    self.visit_string(String::from(value))
                }
    
                #[cfg(any(feature = "std", feature = "alloc"))]
                #[inline]
                fn visit_string<E>(self, value: String) -> Result<Value, E> {
                    Ok(Value::String(value))
                }
    
                #[inline]
                fn visit_none<E>(self) -> Result<Value, E> {
                    Ok(Value::Null)
                }
    
                #[inline]
                fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    Deserialize::deserialize(deserializer)
                }
    
                #[inline]
                fn visit_unit<E>(self) -> Result<Value, E> {
                    Ok(Value::Null)
                }
    
                #[inline]
                fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>
                where
                    V: SeqAccess<'de>,
                {
                    let mut vec = Vec::new();
    
                    while let Some(elem) = tri!(visitor.next_element()) {
                        vec.push(elem);
                    }
    
                    Ok(Value::Array(vec))
                }
    
                #[cfg(any(feature = "std", feature = "alloc"))]
                fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>
                where
                    V: MapAccess<'de>,
                {
                    match tri!(visitor.next_key_seed(KeyClassifier)) {
                        #[cfg(feature = "arbitrary_precision")]
                        Some(KeyClass::Number) => {
                            let number: NumberFromString = tri!(visitor.next_value());
                            Ok(Value::Number(number.value))
                        }
                        #[cfg(feature = "raw_value")]
                        Some(KeyClass::RawValue) => {
                            let value = tri!(visitor.next_value_seed(crate::raw::BoxedFromString));
                            crate::from_str(value.get()).map_err(de::Error::custom)
                        }
                        Some(KeyClass::Map(first_key)) => {
                            let mut values = Map::new();
    
                            values.insert(first_key, tri!(visitor.next_value()));
                            while let Some((key, value)) = tri!(visitor.next_entry()) {
                                values.insert(key, value);
                            }
    
                            Ok(Value::Object(values))
                        }
                        None => Ok(Value::Object(Map::new())),
                    }
                }
            }
    
            deserializer.deserialize_any(ValueVisitor)
        }
    *)
    Definition deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D}
        (deserializer : D)
        :
          M
            (core.result.Result.t
              serde_json.value.Value.t
              D::type["Error"].t) :=
      let* deserializer := M.alloc deserializer in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D} :
      Notations.DoubleColon Self "deserialize" := {
      Notations.double_colon := deserialize (D := D);
    }.
    
    Global Instance ℐ : serde.de.Deserialize.Required.Trait Self := {
      serde.de.Deserialize.deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D} :=
        deserialize (D := D);
      serde.de.Deserialize.deserialize_in_place := Datatypes.None;
    }.
  End Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
  End Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
  
  Module  Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
  Section Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        type Err = Error;
    *)
    Definition Err : Set := serde_json.error.Error.t.
    
    (*
        fn from_str(s: &str) -> Result<Value, Error> {
            super::super::de::from_str(s)
        }
    *)
    Definition from_str
        (s : ref str.t)
        :
          M
            (core.result.Result.t
              serde_json.value.Value.t
              serde_json.error.Error.t) :=
      let* s := M.alloc s in
      M.read foo.
    
    Global Instance AssociatedFunction_from_str :
      Notations.DoubleColon Self "from_str" := {
      Notations.double_colon := from_str;
    }.
    
    Global Instance ℐ : core.str.traits.FromStr.Trait Self := {
      core.str.traits.FromStr.Err := Err;
      core.str.traits.FromStr.from_str := from_str;
    }.
  End Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
  End Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
  
  (*
  fn visit_array<'de, V>(array: Vec<Value>, visitor: V) -> Result<V::Value, Error>
  where
      V: Visitor<'de>,
  {
      let len = array.len();
      let mut deserializer = SeqDeserializer::new(array);
      let seq = tri!(visitor.visit_seq(&mut deserializer));
      let remaining = deserializer.iter.len();
      if remaining == 0 {
          Ok(seq)
      } else {
          Err(serde::de::Error::invalid_length(
              len,
              &"fewer elements in array",
          ))
      }
  }
  *)
  Definition visit_array
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (array_
        :
        alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* array_ := M.alloc array_ in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  (*
  fn visit_object<'de, V>(object: Map<String, Value>, visitor: V) -> Result<V::Value, Error>
  where
      V: Visitor<'de>,
  {
      let len = object.len();
      let mut deserializer = MapDeserializer::new(object);
      let map = tri!(visitor.visit_map(&mut deserializer));
      let remaining = deserializer.iter.len();
      if remaining == 0 {
          Ok(map)
      } else {
          Err(serde::de::Error::invalid_length(
              len,
              &"fewer elements in map",
          ))
      }
  }
  *)
  Definition visit_object
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (object
        :
        serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* object := M.alloc object in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Module  Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
  Section Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Null => visitor.visit_unit(),
                Value::Bool(v) => visitor.visit_bool(v),
                Value::Number(n) => n.deserialize_any(visitor),
                #[cfg(any(feature = "std", feature = "alloc"))]
                Value::String(v) => visitor.visit_string(v),
                Value::Array(v) => visit_array(v, visitor),
                Value::Object(v) => visit_object(v, visitor),
            }
        }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Null => visitor.visit_none(),
                _ => visitor.visit_some(self),
            }
        }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
        fn deserialize_enum<V>(
            self,
            _name: &str,
            _variants: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            let (variant, value) = match self {
                Value::Object(value) => {
                    let mut iter = value.into_iter();
                    let (variant, value) = match iter.next() {
                        Some(v) => v,
                        None => {
                            return Err(serde::de::Error::invalid_value(
                                Unexpected::Map,
                                &"map with a single key",
                            ));
                        }
                    };
                    // enums are encoded in json as maps with a single key:value pair
                    if iter.next().is_some() {
                        return Err(serde::de::Error::invalid_value(
                            Unexpected::Map,
                            &"map with a single key",
                        ));
                    }
                    (variant, Some(value))
                }
                Value::String(variant) => (variant, None),
                other => {
                    return Err(serde::de::Error::invalid_type(
                        other.unexpected(),
                        &"string or map",
                    ));
                }
            };
    
            visitor.visit_enum(EnumDeserializer { variant, value })
        }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_variants : ref (slice (ref str.t)))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variants := M.alloc _variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
        fn deserialize_newtype_struct<V>(
            self,
            name: &'static str,
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            #[cfg(feature = "raw_value")]
            {
                if name == crate::raw::TOKEN {
                    return visitor.visit_map(crate::raw::OwnedRawDeserializer {
                        raw_value: Some(self.to_string()),
                    });
                }
            }
    
            let _ = name;
            visitor.visit_newtype_struct(self)
        }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
        fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Bool(v) => visitor.visit_bool(v),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
        fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_string(visitor)
        }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
        fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_string(visitor)
        }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
        fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                #[cfg(any(feature = "std", feature = "alloc"))]
                Value::String(v) => visitor.visit_string(v),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
        fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_byte_buf(visitor)
        }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
        fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                #[cfg(any(feature = "std", feature = "alloc"))]
                Value::String(v) => visitor.visit_string(v),
                Value::Array(v) => visit_array(v, visitor),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
        fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Null => visitor.visit_unit(),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
        fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_unit(visitor)
        }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
        fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Array(v) => visit_array(v, visitor),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
        fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_seq(visitor)
        }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
        fn deserialize_tuple_struct<V>(
            self,
            _name: &'static str,
            _len: usize,
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_seq(visitor)
        }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_len : usize.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
        fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Object(v) => visit_object(v, visitor),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
        fn deserialize_struct<V>(
            self,
            _name: &'static str,
            _fields: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Array(v) => visit_array(v, visitor),
                Value::Object(v) => visit_object(v, visitor),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_fields : ref (slice (ref str.t)))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _fields := M.alloc _fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
        fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_string(visitor)
        }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
        fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            drop(self);
            visitor.visit_unit()
        }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
  End Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
  
  Module  EnumDeserializer.
  Section EnumDeserializer.
    Record t : Set := {
      variant : alloc.string.String.t;
      value : core.option.Option.t serde_json.value.Value.t;
    }.
    
    Definition Get_variant :=
      Ref.map
        (fun α => Some α.(variant))
        (fun β α => Some (α <| variant := β |>)).
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End EnumDeserializer.
  End EnumDeserializer.
  
  Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
  Section Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
    Definition Self : Set := serde_json.value.de.EnumDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        type Variant = VariantDeserializer;
    *)
    Definition Variant : Set := serde_json.value.de.VariantDeserializer.t.
    
    (*
        fn variant_seed<V>(self, seed: V) -> Result<(V::Value, VariantDeserializer), Error>
        where
            V: DeserializeSeed<'de>,
        {
            let variant = self.variant.into_deserializer();
            let visitor = VariantDeserializer { value: self.value };
            seed.deserialize(variant).map(|v| (v, visitor))
        }
    *)
    Definition variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V}
        (self : Self)
        (seed : V)
        :
          M
            (core.result.Result.t
              (V::type["Value"].t * serde_json.value.de.VariantDeserializer.t)
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
      Notations.DoubleColon Self "variant_seed" := {
      Notations.double_colon := variant_seed (V := V);
    }.
    
    Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
      serde.de.EnumAccess.Error := Error;
      serde.de.EnumAccess.Variant := Variant;
      serde.de.EnumAccess.variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
        variant_seed (V := V);
      serde.de.EnumAccess.variant := Datatypes.None;
    }.
  End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
  End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
  
  Module  Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
  Section Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        type Deserializer = Self;
    *)
    Definition Deserializer : Set := Self.
    
    (*
        fn into_deserializer(self) -> Self::Deserializer {
            self
        }
    *)
    Definition into_deserializer (self : Self) : M Deserializer :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_deserializer :
      Notations.DoubleColon Self "into_deserializer" := {
      Notations.double_colon := into_deserializer;
    }.
    
    Global Instance ℐ :
      serde.de.IntoDeserializer.Trait Self (E := serde_json.error.Error.t) := {
      serde.de.IntoDeserializer.Deserializer := Deserializer;
      serde.de.IntoDeserializer.into_deserializer := into_deserializer;
    }.
  End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
  End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
  
  Module  Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
  Section Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
        type Deserializer = Self;
    *)
    Definition Deserializer : Set := Self.
    
    (*
        fn into_deserializer(self) -> Self::Deserializer {
            self
        }
    *)
    Definition into_deserializer (self : Self) : M Deserializer :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_deserializer :
      Notations.DoubleColon Self "into_deserializer" := {
      Notations.double_colon := into_deserializer;
    }.
    
    Global Instance ℐ :
      serde.de.IntoDeserializer.Trait Self (E := serde_json.error.Error.t) := {
      serde.de.IntoDeserializer.Deserializer := Deserializer;
      serde.de.IntoDeserializer.into_deserializer := into_deserializer;
    }.
  End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
  End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
  
  Module  VariantDeserializer.
  Section VariantDeserializer.
    Record t : Set := {
      value : core.option.Option.t serde_json.value.Value.t;
    }.
    
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End VariantDeserializer.
  End VariantDeserializer.
  
  Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
  Section Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
    Definition Self : Set := serde_json.value.de.VariantDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn unit_variant(self) -> Result<(), Error> {
            match self.value {
                Some(value) => Deserialize::deserialize(value),
                None => Ok(()),
            }
        }
    *)
    Definition unit_variant
        (self : Self)
        : M (core.result.Result.t unit serde_json.error.Error.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_unit_variant :
      Notations.DoubleColon Self "unit_variant" := {
      Notations.double_colon := unit_variant;
    }.
    
    (*
        fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.value {
                Some(value) => seed.deserialize(value),
                None => Err(serde::de::Error::invalid_type(
                    Unexpected::UnitVariant,
                    &"newtype variant",
                )),
            }
        }
    *)
    Definition newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              T::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "newtype_variant_seed" := {
      Notations.double_colon := newtype_variant_seed (T := T);
    }.
    
    (*
        fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self.value {
                Some(Value::Array(v)) => {
                    if v.is_empty() {
                        visitor.visit_unit()
                    } else {
                        visit_array(v, visitor)
                    }
                }
                Some(other) => Err(serde::de::Error::invalid_type(
                    other.unexpected(),
                    &"tuple variant",
                )),
                None => Err(serde::de::Error::invalid_type(
                    Unexpected::UnitVariant,
                    &"tuple variant",
                )),
            }
        }
    *)
    Definition tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "tuple_variant" := {
      Notations.double_colon := tuple_variant (V := V);
    }.
    
    (*
        fn struct_variant<V>(
            self,
            _fields: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self.value {
                Some(Value::Object(v)) => visit_object(v, visitor),
                Some(other) => Err(serde::de::Error::invalid_type(
                    other.unexpected(),
                    &"struct variant",
                )),
                None => Err(serde::de::Error::invalid_type(
                    Unexpected::UnitVariant,
                    &"struct variant",
                )),
            }
        }
    *)
    Definition struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_fields : ref (slice (ref str.t)))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _fields := M.alloc _fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "struct_variant" := {
      Notations.double_colon := struct_variant (V := V);
    }.
    
    Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
      serde.de.VariantAccess.Error := Error;
      serde.de.VariantAccess.unit_variant := unit_variant;
      serde.de.VariantAccess.newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        newtype_variant_seed (T := T);
      serde.de.VariantAccess.tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        tuple_variant (V := V);
      serde.de.VariantAccess.struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        struct_variant (V := V);
      serde.de.VariantAccess.newtype_variant := Datatypes.None;
    }.
  End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
  End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
  
  Module  SeqDeserializer.
  Section SeqDeserializer.
    Record t : Set := {
      iter :
        alloc.vec.into_iter.IntoIter.t
          serde_json.value.Value.t
          alloc.vec.into_iter.IntoIter.Default.A;
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  End SeqDeserializer.
  End SeqDeserializer.
  
  Module  Impl_serde_json_value_de_SeqDeserializer_t_2.
  Section Impl_serde_json_value_de_SeqDeserializer_t_2.
    Definition Self : Set := serde_json.value.de.SeqDeserializer.t.
    
    (*
        fn new(vec: Vec<Value>) -> Self {
            SeqDeserializer {
                iter: vec.into_iter(),
            }
        }
    *)
    Definition new
        (vec : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A)
        : M Self :=
      let* vec := M.alloc vec in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_value_de_SeqDeserializer_t_2.
  End Impl_serde_json_value_de_SeqDeserializer_t_2.
  
  Module  Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
  Section Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
    Definition Self : Set := serde_json.value.de.SeqDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.iter.next() {
                Some(value) => seed.deserialize(value).map(Some),
                None => Ok(None),
            }
        }
    *)
    Definition next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : mut_ref Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              (core.option.Option.t T::type["Value"].t)
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "next_element_seed" := {
      Notations.double_colon := next_element_seed (T := T);
    }.
    
    (*
        fn size_hint(&self) -> Option<usize> {
            match self.iter.size_hint() {
                (lower, Some(upper)) if lower == upper => Some(upper),
                _ => None,
            }
        }
    *)
    Definition size_hint (self : ref Self) : M (core.option.Option.t usize.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
      serde.de.SeqAccess.Error := Error;
      serde.de.SeqAccess.next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        next_element_seed (T := T);
      serde.de.SeqAccess.size_hint := Datatypes.Some size_hint;
      serde.de.SeqAccess.next_element := Datatypes.None;
    }.
  End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
  End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
  
  Module  MapDeserializer.
  Section MapDeserializer.
    Record t : Set := {
      iter :
        core.iter.traits.collect.IntoIterator.IntoIter
          (Self := serde_json.map.Map.t
            alloc.string.String.t
            serde_json.value.Value.t)
          (Trait := ltac:(refine _));
      value : core.option.Option.t serde_json.value.Value.t;
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End MapDeserializer.
  End MapDeserializer.
  
  Module  Impl_serde_json_value_de_MapDeserializer_t_2.
  Section Impl_serde_json_value_de_MapDeserializer_t_2.
    Definition Self : Set := serde_json.value.de.MapDeserializer.t.
    
    (*
        fn new(map: Map<String, Value>) -> Self {
            MapDeserializer {
                iter: map.into_iter(),
                value: None,
            }
        }
    *)
    Definition new
        (map
          :
          serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
        : M Self :=
      let* map := M.alloc map in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_value_de_MapDeserializer_t_2.
  End Impl_serde_json_value_de_MapDeserializer_t_2.
  
  Module  Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
  Section Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
    Definition Self : Set := serde_json.value.de.MapDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.iter.next() {
                Some((key, value)) => {
                    self.value = Some(value);
                    let key_de = MapKeyDeserializer {
                        key: Cow::Owned(key),
                    };
                    seed.deserialize(key_de).map(Some)
                }
                None => Ok(None),
            }
        }
    *)
    Definition next_key_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : mut_ref Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              (core.option.Option.t T::type["Value"].t)
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_key_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "next_key_seed" := {
      Notations.double_colon := next_key_seed (T := T);
    }.
    
    (*
        fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.value.take() {
                Some(value) => seed.deserialize(value),
                None => Err(serde::de::Error::custom("value is missing")),
            }
        }
    *)
    Definition next_value_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : mut_ref Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              T::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_value_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "next_value_seed" := {
      Notations.double_colon := next_value_seed (T := T);
    }.
    
    (*
        fn size_hint(&self) -> Option<usize> {
            match self.iter.size_hint() {
                (lower, Some(upper)) if lower == upper => Some(upper),
                _ => None,
            }
        }
    *)
    Definition size_hint (self : ref Self) : M (core.option.Option.t usize.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
      serde.de.MapAccess.Error := Error;
      serde.de.MapAccess.next_key_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        next_key_seed (T := T);
      serde.de.MapAccess.next_value_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        next_value_seed (T := T);
      serde.de.MapAccess.size_hint := Datatypes.Some size_hint;
      serde.de.MapAccess.next_entry_seed := Datatypes.None;
      serde.de.MapAccess.next_key := Datatypes.None;
      serde.de.MapAccess.next_value := Datatypes.None;
      serde.de.MapAccess.next_entry := Datatypes.None;
    }.
  End Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
  End Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
  
  (*
  fn visit_array_ref<'de, V>(array: &'de [Value], visitor: V) -> Result<V::Value, Error>
  where
      V: Visitor<'de>,
  {
      let len = array.len();
      let mut deserializer = SeqRefDeserializer::new(array);
      let seq = tri!(visitor.visit_seq(&mut deserializer));
      let remaining = deserializer.iter.len();
      if remaining == 0 {
          Ok(seq)
      } else {
          Err(serde::de::Error::invalid_length(
              len,
              &"fewer elements in array",
          ))
      }
  }
  *)
  Definition visit_array_ref
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (array_ : ref (slice serde_json.value.Value.t))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* array_ := M.alloc array_ in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  (*
  fn visit_object_ref<'de, V>(object: &'de Map<String, Value>, visitor: V) -> Result<V::Value, Error>
  where
      V: Visitor<'de>,
  {
      let len = object.len();
      let mut deserializer = MapRefDeserializer::new(object);
      let map = tri!(visitor.visit_map(&mut deserializer));
      let remaining = deserializer.iter.len();
      if remaining == 0 {
          Ok(map)
      } else {
          Err(serde::de::Error::invalid_length(
              len,
              &"fewer elements in map",
          ))
      }
  }
  *)
  Definition visit_object_ref
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (object
        :
        ref
          (serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* object := M.alloc object in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Module  Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
  Section Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Null => visitor.visit_unit(),
                Value::Bool(v) => visitor.visit_bool( *v),
                Value::Number(n) => n.deserialize_any(visitor),
                Value::String(v) => visitor.visit_borrowed_str(v),
                Value::Array(v) => visit_array_ref(v, visitor),
                Value::Object(v) => visit_object_ref(v, visitor),
            }
        }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self {
                    Value::Number(n) => n.deserialize_any(visitor),
                    _ => Err(self.invalid_type(&visitor)),
                }
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match *self {
                Value::Null => visitor.visit_none(),
                _ => visitor.visit_some(self),
            }
        }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
        fn deserialize_enum<V>(
            self,
            _name: &str,
            _variants: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            let (variant, value) = match self {
                Value::Object(value) => {
                    let mut iter = value.into_iter();
                    let (variant, value) = match iter.next() {
                        Some(v) => v,
                        None => {
                            return Err(serde::de::Error::invalid_value(
                                Unexpected::Map,
                                &"map with a single key",
                            ));
                        }
                    };
                    // enums are encoded in json as maps with a single key:value pair
                    if iter.next().is_some() {
                        return Err(serde::de::Error::invalid_value(
                            Unexpected::Map,
                            &"map with a single key",
                        ));
                    }
                    (variant, Some(value))
                }
                Value::String(variant) => (variant, None),
                other => {
                    return Err(serde::de::Error::invalid_type(
                        other.unexpected(),
                        &"string or map",
                    ));
                }
            };
    
            visitor.visit_enum(EnumRefDeserializer { variant, value })
        }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_variants : ref (slice (ref str.t)))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variants := M.alloc _variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
        fn deserialize_newtype_struct<V>(
            self,
            name: &'static str,
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            #[cfg(feature = "raw_value")]
            {
                if name == crate::raw::TOKEN {
                    return visitor.visit_map(crate::raw::OwnedRawDeserializer {
                        raw_value: Some(self.to_string()),
                    });
                }
            }
    
            let _ = name;
            visitor.visit_newtype_struct(self)
        }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
        fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match *self {
                Value::Bool(v) => visitor.visit_bool(v),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
        fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_str(visitor)
        }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
        fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::String(v) => visitor.visit_borrowed_str(v),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
        fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_str(visitor)
        }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
        fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::String(v) => visitor.visit_borrowed_str(v),
                Value::Array(v) => visit_array_ref(v, visitor),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
        fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_bytes(visitor)
        }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
        fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match *self {
                Value::Null => visitor.visit_unit(),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
        fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_unit(visitor)
        }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
        fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Array(v) => visit_array_ref(v, visitor),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
        fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_seq(visitor)
        }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
        fn deserialize_tuple_struct<V>(
            self,
            _name: &'static str,
            _len: usize,
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_seq(visitor)
        }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_len : usize.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
        fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Object(v) => visit_object_ref(v, visitor),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
        fn deserialize_struct<V>(
            self,
            _name: &'static str,
            _fields: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self {
                Value::Array(v) => visit_array_ref(v, visitor),
                Value::Object(v) => visit_object_ref(v, visitor),
                _ => Err(self.invalid_type(&visitor)),
            }
        }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_fields : ref (slice (ref str.t)))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _fields := M.alloc _fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
        fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_str(visitor)
        }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
        fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_unit()
        }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
  End Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
  
  Module  EnumRefDeserializer.
  Section EnumRefDeserializer.
    Record t : Set := {
      variant : ref str.t;
      value : core.option.Option.t (ref serde_json.value.Value.t);
    }.
    
    Definition Get_variant :=
      Ref.map
        (fun α => Some α.(variant))
        (fun β α => Some (α <| variant := β |>)).
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End EnumRefDeserializer.
  End EnumRefDeserializer.
  
  Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
  Section Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
    Definition Self : Set := serde_json.value.de.EnumRefDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        type Variant = VariantRefDeserializer<'de>;
    *)
    Definition Variant : Set := serde_json.value.de.VariantRefDeserializer.t.
    
    (*
        fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Error>
        where
            V: DeserializeSeed<'de>,
        {
            let variant = self.variant.into_deserializer();
            let visitor = VariantRefDeserializer { value: self.value };
            seed.deserialize(variant).map(|v| (v, visitor))
        }
    *)
    Definition variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V}
        (self : Self)
        (seed : V)
        :
          M
            (core.result.Result.t
              (V::type["Value"].t * Variant)
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
      Notations.DoubleColon Self "variant_seed" := {
      Notations.double_colon := variant_seed (V := V);
    }.
    
    Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
      serde.de.EnumAccess.Error := Error;
      serde.de.EnumAccess.Variant := Variant;
      serde.de.EnumAccess.variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
        variant_seed (V := V);
      serde.de.EnumAccess.variant := Datatypes.None;
    }.
  End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
  End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
  
  Module  VariantRefDeserializer.
  Section VariantRefDeserializer.
    Record t : Set := {
      value : core.option.Option.t (ref serde_json.value.Value.t);
    }.
    
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End VariantRefDeserializer.
  End VariantRefDeserializer.
  
  Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
  Section Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
    Definition Self : Set := serde_json.value.de.VariantRefDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn unit_variant(self) -> Result<(), Error> {
            match self.value {
                Some(value) => Deserialize::deserialize(value),
                None => Ok(()),
            }
        }
    *)
    Definition unit_variant
        (self : Self)
        : M (core.result.Result.t unit serde_json.error.Error.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_unit_variant :
      Notations.DoubleColon Self "unit_variant" := {
      Notations.double_colon := unit_variant;
    }.
    
    (*
        fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.value {
                Some(value) => seed.deserialize(value),
                None => Err(serde::de::Error::invalid_type(
                    Unexpected::UnitVariant,
                    &"newtype variant",
                )),
            }
        }
    *)
    Definition newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              T::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "newtype_variant_seed" := {
      Notations.double_colon := newtype_variant_seed (T := T);
    }.
    
    (*
        fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self.value {
                Some(Value::Array(v)) => {
                    if v.is_empty() {
                        visitor.visit_unit()
                    } else {
                        visit_array_ref(v, visitor)
                    }
                }
                Some(other) => Err(serde::de::Error::invalid_type(
                    other.unexpected(),
                    &"tuple variant",
                )),
                None => Err(serde::de::Error::invalid_type(
                    Unexpected::UnitVariant,
                    &"tuple variant",
                )),
            }
        }
    *)
    Definition tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "tuple_variant" := {
      Notations.double_colon := tuple_variant (V := V);
    }.
    
    (*
        fn struct_variant<V>(
            self,
            _fields: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            match self.value {
                Some(Value::Object(v)) => visit_object_ref(v, visitor),
                Some(other) => Err(serde::de::Error::invalid_type(
                    other.unexpected(),
                    &"struct variant",
                )),
                None => Err(serde::de::Error::invalid_type(
                    Unexpected::UnitVariant,
                    &"struct variant",
                )),
            }
        }
    *)
    Definition struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_fields : ref (slice (ref str.t)))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _fields := M.alloc _fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "struct_variant" := {
      Notations.double_colon := struct_variant (V := V);
    }.
    
    Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
      serde.de.VariantAccess.Error := Error;
      serde.de.VariantAccess.unit_variant := unit_variant;
      serde.de.VariantAccess.newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        newtype_variant_seed (T := T);
      serde.de.VariantAccess.tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        tuple_variant (V := V);
      serde.de.VariantAccess.struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        struct_variant (V := V);
      serde.de.VariantAccess.newtype_variant := Datatypes.None;
    }.
  End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
  End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
  
  Module  SeqRefDeserializer.
  Section SeqRefDeserializer.
    Record t : Set := {
      iter : core.slice.iter.Iter.t serde_json.value.Value.t;
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  End SeqRefDeserializer.
  End SeqRefDeserializer.
  
  Module  Impl_serde_json_value_de_SeqRefDeserializer_t_2.
  Section Impl_serde_json_value_de_SeqRefDeserializer_t_2.
    Definition Self : Set := serde_json.value.de.SeqRefDeserializer.t.
    
    (*
        fn new(slice: &'de [Value]) -> Self {
            SeqRefDeserializer { iter: slice.iter() }
        }
    *)
    Definition new (slice : ref (slice serde_json.value.Value.t)) : M Self :=
      let* slice := M.alloc slice in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_value_de_SeqRefDeserializer_t_2.
  End Impl_serde_json_value_de_SeqRefDeserializer_t_2.
  
  Module  Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
  Section Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
    Definition Self : Set := serde_json.value.de.SeqRefDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.iter.next() {
                Some(value) => seed.deserialize(value).map(Some),
                None => Ok(None),
            }
        }
    *)
    Definition next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : mut_ref Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              (core.option.Option.t T::type["Value"].t)
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "next_element_seed" := {
      Notations.double_colon := next_element_seed (T := T);
    }.
    
    (*
        fn size_hint(&self) -> Option<usize> {
            match self.iter.size_hint() {
                (lower, Some(upper)) if lower == upper => Some(upper),
                _ => None,
            }
        }
    *)
    Definition size_hint (self : ref Self) : M (core.option.Option.t usize.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
      serde.de.SeqAccess.Error := Error;
      serde.de.SeqAccess.next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        next_element_seed (T := T);
      serde.de.SeqAccess.size_hint := Datatypes.Some size_hint;
      serde.de.SeqAccess.next_element := Datatypes.None;
    }.
  End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
  End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
  
  Module  MapRefDeserializer.
  Section MapRefDeserializer.
    Record t : Set := {
      iter :
        core.iter.traits.collect.IntoIterator.IntoIter
          (Self := ref
            (serde_json.map.Map.t
              alloc.string.String.t
              serde_json.value.Value.t))
          (Trait := ltac:(refine _));
      value : core.option.Option.t (ref serde_json.value.Value.t);
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End MapRefDeserializer.
  End MapRefDeserializer.
  
  Module  Impl_serde_json_value_de_MapRefDeserializer_t_2.
  Section Impl_serde_json_value_de_MapRefDeserializer_t_2.
    Definition Self : Set := serde_json.value.de.MapRefDeserializer.t.
    
    (*
        fn new(map: &'de Map<String, Value>) -> Self {
            MapRefDeserializer {
                iter: map.into_iter(),
                value: None,
            }
        }
    *)
    Definition new
        (map
          :
          ref
            (serde_json.map.Map.t
              alloc.string.String.t
              serde_json.value.Value.t))
        : M Self :=
      let* map := M.alloc map in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_value_de_MapRefDeserializer_t_2.
  End Impl_serde_json_value_de_MapRefDeserializer_t_2.
  
  Module  Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
  Section Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
    Definition Self : Set := serde_json.value.de.MapRefDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.iter.next() {
                Some((key, value)) => {
                    self.value = Some(value);
                    let key_de = MapKeyDeserializer {
                        key: Cow::Borrowed(&**key),
                    };
                    seed.deserialize(key_de).map(Some)
                }
                None => Ok(None),
            }
        }
    *)
    Definition next_key_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : mut_ref Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              (core.option.Option.t T::type["Value"].t)
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_key_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "next_key_seed" := {
      Notations.double_colon := next_key_seed (T := T);
    }.
    
    (*
        fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.value.take() {
                Some(value) => seed.deserialize(value),
                None => Err(serde::de::Error::custom("value is missing")),
            }
        }
    *)
    Definition next_value_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : mut_ref Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              T::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_value_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "next_value_seed" := {
      Notations.double_colon := next_value_seed (T := T);
    }.
    
    (*
        fn size_hint(&self) -> Option<usize> {
            match self.iter.size_hint() {
                (lower, Some(upper)) if lower == upper => Some(upper),
                _ => None,
            }
        }
    *)
    Definition size_hint (self : ref Self) : M (core.option.Option.t usize.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
      serde.de.MapAccess.Error := Error;
      serde.de.MapAccess.next_key_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        next_key_seed (T := T);
      serde.de.MapAccess.next_value_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        next_value_seed (T := T);
      serde.de.MapAccess.size_hint := Datatypes.Some size_hint;
      serde.de.MapAccess.next_entry_seed := Datatypes.None;
      serde.de.MapAccess.next_key := Datatypes.None;
      serde.de.MapAccess.next_value := Datatypes.None;
      serde.de.MapAccess.next_entry := Datatypes.None;
    }.
  End Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
  End Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
  
  Module  MapKeyDeserializer.
  Section MapKeyDeserializer.
    Record t : Set := {
      key : alloc.borrow.Cow.t str.t;
    }.
    
    Definition Get_key :=
      Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
  End MapKeyDeserializer.
  End MapKeyDeserializer.
  
  Module  Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
  Section Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
    Definition Self : Set := serde_json.value.de.MapKeyDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            BorrowedCowStrDeserializer::new(self.key).deserialize_any(visitor)
        }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                let mut de = crate::Deserializer::from_str(&self.key);
    
                match tri!(de.peek()) {
                    Some(b'0'..=b'9' | b'-') => {}
                    _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
                }
    
                let number = tri!(de.$using(visitor));
    
                if tri!(de.peek()).is_some() {
                    return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
                }
    
                Ok(number)
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
        fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            if self.key == "true" {
                visitor.visit_bool(true)
            } else if self.key == "false" {
                visitor.visit_bool(false)
            } else {
                Err(serde::de::Error::invalid_type(
                    Unexpected::Str(&self.key),
                    &visitor,
                ))
            }
        }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            // Map keys cannot be null.
            visitor.visit_some(self)
        }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
        fn deserialize_newtype_struct<V>(
            self,
            _name: &'static str,
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_newtype_struct(self)
        }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
        fn deserialize_enum<V>(
            self,
            name: &'static str,
            variants: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: Visitor<'de>,
        {
            self.key
                .into_deserializer()
                .deserialize_enum(name, variants, visitor)
        }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (variants : ref (slice (ref str.t)))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* variants := M.alloc variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (fields : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* fields := M.alloc fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
  End Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
  
  Module  KeyClassifier.
  Section KeyClassifier.
    Inductive t : Set := Build.
  End KeyClassifier.
  End KeyClassifier.
  
  Module KeyClass.
    Inductive t : Set :=
    | Map (_ : alloc.string.String.t).
    
    Definition Get_Map_0 :=
      Ref.map
        (fun α => match α with | Map α0 => Some α0 end)
        (fun β α => match α with | Map _ => Some (Map β) end).
  End KeyClass.
  
  Module  Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
  Section Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
    Definition Self : Set := serde_json.value.de.KeyClassifier.t.
    
    (*
        type Value = KeyClass;
    *)
    Definition Value : Set := serde_json.value.de.KeyClass.t.
    
    (*
        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_str(self)
        }
    *)
    Definition deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D}
        (self : Self)
        (deserializer : D)
        : M (core.result.Result.t Value D::type["Error"].t) :=
      let* self := M.alloc self in
      let* deserializer := M.alloc deserializer in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D} :
      Notations.DoubleColon Self "deserialize" := {
      Notations.double_colon := deserialize (D := D);
    }.
    
    Global Instance ℐ : serde.de.DeserializeSeed.Trait Self := {
      serde.de.DeserializeSeed.Value := Value;
      serde.de.DeserializeSeed.deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D} :=
        deserialize (D := D);
    }.
  End Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
  End Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
  
  Module  Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
  Section Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
    Definition Self : Set := serde_json.value.de.KeyClassifier.t.
    
    (*
        type Value = KeyClass;
    *)
    Definition Value : Set := serde_json.value.de.KeyClass.t.
    
    (*
        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("a string key")
        }
    *)
    Definition expecting
        (self : ref Self)
        (formatter : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* formatter := M.alloc formatter in
      M.read foo.
    
    Global Instance AssociatedFunction_expecting :
      Notations.DoubleColon Self "expecting" := {
      Notations.double_colon := expecting;
    }.
    
    (*
        fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            match s {
                #[cfg(feature = "arbitrary_precision")]
                crate::number::TOKEN => Ok(KeyClass::Number),
                #[cfg(feature = "raw_value")]
                crate::raw::TOKEN => Ok(KeyClass::RawValue),
                _ => Ok(KeyClass::Map(s.to_owned())),
            }
        }
    *)
    Definition visit_str
        {E : Set}
        {ℋ_0 : serde.de.Error.Trait E}
        (self : Self)
        (s : ref str.t)
        : M (core.result.Result.t Value E) :=
      let* self := M.alloc self in
      let* s := M.alloc s in
      M.read foo.
    
    Global Instance AssociatedFunction_visit_str
        {E : Set}
        {ℋ_0 : serde.de.Error.Trait E} :
      Notations.DoubleColon Self "visit_str" := {
      Notations.double_colon := visit_str (E := E);
    }.
    
    (*
        fn visit_string<E>(self, s: String) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            match s.as_str() {
                #[cfg(feature = "arbitrary_precision")]
                crate::number::TOKEN => Ok(KeyClass::Number),
                #[cfg(feature = "raw_value")]
                crate::raw::TOKEN => Ok(KeyClass::RawValue),
                _ => Ok(KeyClass::Map(s)),
            }
        }
    *)
    Definition visit_string
        {E : Set}
        {ℋ_0 : serde.de.Error.Trait E}
        (self : Self)
        (s : alloc.string.String.t)
        : M (core.result.Result.t Value E) :=
      let* self := M.alloc self in
      let* s := M.alloc s in
      M.read foo.
    
    Global Instance AssociatedFunction_visit_string
        {E : Set}
        {ℋ_0 : serde.de.Error.Trait E} :
      Notations.DoubleColon Self "visit_string" := {
      Notations.double_colon := visit_string (E := E);
    }.
    
    Global Instance ℐ : serde.de.Visitor.Required.Trait Self := {
      serde.de.Visitor.Value := Value;
      serde.de.Visitor.expecting := expecting;
      serde.de.Visitor.visit_str {E : Set} {ℋ_0 : serde.de.Error.Trait E} :=
        Datatypes.Some (visit_str (E := E));
      serde.de.Visitor.visit_string {E : Set} {ℋ_0 : serde.de.Error.Trait E} :=
        Datatypes.Some (visit_string (E := E));
      serde.de.Visitor.visit_bool := Datatypes.None;
      serde.de.Visitor.visit_i8 := Datatypes.None;
      serde.de.Visitor.visit_i16 := Datatypes.None;
      serde.de.Visitor.visit_i32 := Datatypes.None;
      serde.de.Visitor.visit_i64 := Datatypes.None;
      serde.de.Visitor.visit_i128 := Datatypes.None;
      serde.de.Visitor.visit_u8 := Datatypes.None;
      serde.de.Visitor.visit_u16 := Datatypes.None;
      serde.de.Visitor.visit_u32 := Datatypes.None;
      serde.de.Visitor.visit_u64 := Datatypes.None;
      serde.de.Visitor.visit_u128 := Datatypes.None;
      serde.de.Visitor.visit_f32 := Datatypes.None;
      serde.de.Visitor.visit_f64 := Datatypes.None;
      serde.de.Visitor.visit_char := Datatypes.None;
      serde.de.Visitor.visit_borrowed_str := Datatypes.None;
      serde.de.Visitor.visit_bytes := Datatypes.None;
      serde.de.Visitor.visit_borrowed_bytes := Datatypes.None;
      serde.de.Visitor.visit_byte_buf := Datatypes.None;
      serde.de.Visitor.visit_none := Datatypes.None;
      serde.de.Visitor.visit_some := Datatypes.None;
      serde.de.Visitor.visit_unit := Datatypes.None;
      serde.de.Visitor.visit_newtype_struct := Datatypes.None;
      serde.de.Visitor.visit_seq := Datatypes.None;
      serde.de.Visitor.visit_map := Datatypes.None;
      serde.de.Visitor.visit_enum := Datatypes.None;
      serde.de.Visitor.__private_visit_untagged_option := Datatypes.None;
    }.
  End Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
  End Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
  
  Module  Impl_serde_json_value_Value_t_4.
  Section Impl_serde_json_value_Value_t_4.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn invalid_type<E>(&self, exp: &dyn Expected) -> E
        where
            E: serde::de::Error,
        {
            serde::de::Error::invalid_type(self.unexpected(), exp)
        }
    *)
    Definition invalid_type
        {E DynT : Set}
        {ℋ_0 : serde.de.Error.Trait E}
        {ℋ_1 : serde.de.Expected.Trait.Trait DynT}
        (self : ref Self)
        (exp : ref DynT)
        : M E :=
      let* self := M.alloc self in
      let* exp := M.alloc exp in
      M.read foo.
    
    Global Instance AssociatedFunction_invalid_type
        {E DynT : Set}
        {ℋ_0 : serde.de.Error.Trait E}
        {ℋ_1 : serde.de.Expected.Trait.Trait DynT} :
      Notations.DoubleColon Self "invalid_type" := {
      Notations.double_colon := invalid_type (E := E) (DynT := DynT);
    }.
    
    (*
        fn unexpected(&self) -> Unexpected {
            match self {
                Value::Null => Unexpected::Unit,
                Value::Bool(b) => Unexpected::Bool( *b),
                Value::Number(n) => n.unexpected(),
                Value::String(s) => Unexpected::Str(s),
                Value::Array(_) => Unexpected::Seq,
                Value::Object(_) => Unexpected::Map,
            }
        }
    *)
    Definition unexpected (self : ref Self) : M serde.de.Unexpected.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_unexpected :
      Notations.DoubleColon Self "unexpected" := {
      Notations.double_colon := unexpected;
    }.
  End Impl_serde_json_value_Value_t_4.
  End Impl_serde_json_value_Value_t_4.
  
  Module  BorrowedCowStrDeserializer.
  Section BorrowedCowStrDeserializer.
    Record t : Set := {
      value : alloc.borrow.Cow.t str.t;
    }.
    
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End BorrowedCowStrDeserializer.
  End BorrowedCowStrDeserializer.
  
  Module  Impl_serde_json_value_de_BorrowedCowStrDeserializer_t_2.
  Section Impl_serde_json_value_de_BorrowedCowStrDeserializer_t_2.
    Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
    
    (*
        fn new(value: Cow<'de, str>) -> Self {
            BorrowedCowStrDeserializer { value }
        }
    *)
    Definition new (value : alloc.borrow.Cow.t str.t) : M Self :=
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_value_de_BorrowedCowStrDeserializer_t_2.
  End Impl_serde_json_value_de_BorrowedCowStrDeserializer_t_2.
  
  Module  Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
  Section Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
    Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
        where
            V: de::Visitor<'de>,
        {
            match self.value {
                Cow::Borrowed(string) => visitor.visit_borrowed_str(string),
                #[cfg(any(feature = "std", feature = "alloc"))]
                Cow::Owned(string) => visitor.visit_string(string),
            }
        }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
        fn deserialize_enum<V>(
            self,
            _name: &str,
            _variants: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: de::Visitor<'de>,
        {
            visitor.visit_enum(self)
        }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_variants : ref (slice (ref str.t)))
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variants := M.alloc _variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (fields : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* fields := M.alloc fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
  End Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
  
  Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
  Section Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
    Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        type Variant = UnitOnly;
    *)
    Definition Variant : Set := serde_json.value.de.UnitOnly.t.
    
    (*
        fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Error>
        where
            T: de::DeserializeSeed<'de>,
        {
            let value = tri!(seed.deserialize(self));
            Ok((value, UnitOnly))
        }
    *)
    Definition variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              (T::type["Value"].t * Variant)
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "variant_seed" := {
      Notations.double_colon := variant_seed (T := T);
    }.
    
    Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
      serde.de.EnumAccess.Error := Error;
      serde.de.EnumAccess.Variant := Variant;
      serde.de.EnumAccess.variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        variant_seed (T := T);
      serde.de.EnumAccess.variant := Datatypes.None;
    }.
  End Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
  End Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
  
  Module  UnitOnly.
  Section UnitOnly.
    Inductive t : Set := Build.
  End UnitOnly.
  End UnitOnly.
  
  Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
  Section Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
    Definition Self : Set := serde_json.value.de.UnitOnly.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn unit_variant(self) -> Result<(), Error> {
            Ok(())
        }
    *)
    Definition unit_variant
        (self : Self)
        : M (core.result.Result.t unit serde_json.error.Error.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_unit_variant :
      Notations.DoubleColon Self "unit_variant" := {
      Notations.double_colon := unit_variant;
    }.
    
    (*
        fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Error>
        where
            T: de::DeserializeSeed<'de>,
        {
            Err(de::Error::invalid_type(
                Unexpected::UnitVariant,
                &"newtype variant",
            ))
        }
    *)
    Definition newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : Self)
        (_seed : T)
        :
          M
            (core.result.Result.t
              T::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _seed := M.alloc _seed in
      M.read foo.
    
    Global Instance AssociatedFunction_newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "newtype_variant_seed" := {
      Notations.double_colon := newtype_variant_seed (T := T);
    }.
    
    (*
        fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Error>
        where
            V: de::Visitor<'de>,
        {
            Err(de::Error::invalid_type(
                Unexpected::UnitVariant,
                &"tuple variant",
            ))
        }
    *)
    Definition tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (_visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "tuple_variant" := {
      Notations.double_colon := tuple_variant (V := V);
    }.
    
    (*
        fn struct_variant<V>(
            self,
            _fields: &'static [&'static str],
            _visitor: V,
        ) -> Result<V::Value, Error>
        where
            V: de::Visitor<'de>,
        {
            Err(de::Error::invalid_type(
                Unexpected::UnitVariant,
                &"struct variant",
            ))
        }
    *)
    Definition struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_fields : ref (slice (ref str.t)))
        (_visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* _fields := M.alloc _fields in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "struct_variant" := {
      Notations.double_colon := struct_variant (V := V);
    }.
    
    Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
      serde.de.VariantAccess.Error := Error;
      serde.de.VariantAccess.unit_variant := unit_variant;
      serde.de.VariantAccess.newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        newtype_variant_seed (T := T);
      serde.de.VariantAccess.tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        tuple_variant (V := V);
      serde.de.VariantAccess.struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        struct_variant (V := V);
      serde.de.VariantAccess.newtype_variant := Datatypes.None;
    }.
  End Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
  End Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
End de.
End Wrap_de_1.
Import Wrap_de_1.

Module  Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
Section Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>
      where
          D: serde::Deserializer<'de>,
      {
          struct ValueVisitor;
  
          impl<'de> Visitor<'de> for ValueVisitor {
              type Value = Value;
  
              fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                  formatter.write_str("any valid JSON value")
              }
  
              #[inline]
              fn visit_bool<E>(self, value: bool) -> Result<Value, E> {
                  Ok(Value::Bool(value))
              }
  
              #[inline]
              fn visit_i64<E>(self, value: i64) -> Result<Value, E> {
                  Ok(Value::Number(value.into()))
              }
  
              #[inline]
              fn visit_u64<E>(self, value: u64) -> Result<Value, E> {
                  Ok(Value::Number(value.into()))
              }
  
              #[inline]
              fn visit_f64<E>(self, value: f64) -> Result<Value, E> {
                  Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))
              }
  
              #[cfg(any(feature = "std", feature = "alloc"))]
              #[inline]
              fn visit_str<E>(self, value: &str) -> Result<Value, E>
              where
                  E: serde::de::Error,
              {
                  self.visit_string(String::from(value))
              }
  
              #[cfg(any(feature = "std", feature = "alloc"))]
              #[inline]
              fn visit_string<E>(self, value: String) -> Result<Value, E> {
                  Ok(Value::String(value))
              }
  
              #[inline]
              fn visit_none<E>(self) -> Result<Value, E> {
                  Ok(Value::Null)
              }
  
              #[inline]
              fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>
              where
                  D: serde::Deserializer<'de>,
              {
                  Deserialize::deserialize(deserializer)
              }
  
              #[inline]
              fn visit_unit<E>(self) -> Result<Value, E> {
                  Ok(Value::Null)
              }
  
              #[inline]
              fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>
              where
                  V: SeqAccess<'de>,
              {
                  let mut vec = Vec::new();
  
                  while let Some(elem) = tri!(visitor.next_element()) {
                      vec.push(elem);
                  }
  
                  Ok(Value::Array(vec))
              }
  
              #[cfg(any(feature = "std", feature = "alloc"))]
              fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>
              where
                  V: MapAccess<'de>,
              {
                  match tri!(visitor.next_key_seed(KeyClassifier)) {
                      #[cfg(feature = "arbitrary_precision")]
                      Some(KeyClass::Number) => {
                          let number: NumberFromString = tri!(visitor.next_value());
                          Ok(Value::Number(number.value))
                      }
                      #[cfg(feature = "raw_value")]
                      Some(KeyClass::RawValue) => {
                          let value = tri!(visitor.next_value_seed(crate::raw::BoxedFromString));
                          crate::from_str(value.get()).map_err(de::Error::custom)
                      }
                      Some(KeyClass::Map(first_key)) => {
                          let mut values = Map::new();
  
                          values.insert(first_key, tri!(visitor.next_value()));
                          while let Some((key, value)) = tri!(visitor.next_entry()) {
                              values.insert(key, value);
                          }
  
                          Ok(Value::Object(values))
                      }
                      None => Ok(Value::Object(Map::new())),
                  }
              }
          }
  
          deserializer.deserialize_any(ValueVisitor)
      }
  *)
  Definition deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D}
      (deserializer : D)
      : M (core.result.Result.t serde_json.value.Value.t D::type["Error"].t) :=
    let* deserializer := M.alloc deserializer in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :
    Notations.DoubleColon Self "deserialize" := {
    Notations.double_colon := deserialize (D := D);
  }.
  
  Global Instance ℐ : serde.de.Deserialize.Required.Trait Self := {
    serde.de.Deserialize.deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :=
      deserialize (D := D);
    serde.de.Deserialize.deserialize_in_place := Datatypes.None;
  }.
End Impl_serde_de_Deserialize_for_serde_json_value_Value_t.
End Impl_serde_de_Deserialize_for_serde_json_value_Value_t.

Module  ValueVisitor.
Section ValueVisitor.
  Inductive t : Set := Build.
End ValueVisitor.
End ValueVisitor.

Module  Impl_serde_de_Visitor_for_serde_json_value_de_deserialize_ValueVisitor_t.
Section Impl_serde_de_Visitor_for_serde_json_value_de_deserialize_ValueVisitor_t.
  Definition Self : Set := serde_json.value.de.deserialize.ValueVisitor.t.
  
  (*
              type Value = Value;
  *)
  Definition Value : Set := serde_json.value.Value.t.
  
  (*
              fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                  formatter.write_str("any valid JSON value")
              }
  *)
  Definition expecting
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_expecting :
    Notations.DoubleColon Self "expecting" := {
    Notations.double_colon := expecting;
  }.
  
  (*
              fn visit_bool<E>(self, value: bool) -> Result<Value, E> {
                  Ok(Value::Bool(value))
              }
  *)
  Definition visit_bool
      {E : Set}
      (self : Self)
      (value : bool.t)
      : M (core.result.Result.t serde_json.value.Value.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_bool {E : Set} :
    Notations.DoubleColon Self "visit_bool" := {
    Notations.double_colon := visit_bool (E := E);
  }.
  
  (*
              fn visit_i64<E>(self, value: i64) -> Result<Value, E> {
                  Ok(Value::Number(value.into()))
              }
  *)
  Definition visit_i64
      {E : Set}
      (self : Self)
      (value : i64.t)
      : M (core.result.Result.t serde_json.value.Value.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_i64 {E : Set} :
    Notations.DoubleColon Self "visit_i64" := {
    Notations.double_colon := visit_i64 (E := E);
  }.
  
  (*
              fn visit_u64<E>(self, value: u64) -> Result<Value, E> {
                  Ok(Value::Number(value.into()))
              }
  *)
  Definition visit_u64
      {E : Set}
      (self : Self)
      (value : u64.t)
      : M (core.result.Result.t serde_json.value.Value.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_u64 {E : Set} :
    Notations.DoubleColon Self "visit_u64" := {
    Notations.double_colon := visit_u64 (E := E);
  }.
  
  (*
              fn visit_f64<E>(self, value: f64) -> Result<Value, E> {
                  Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))
              }
  *)
  Definition visit_f64
      {E : Set}
      (self : Self)
      (value : f64.t)
      : M (core.result.Result.t serde_json.value.Value.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_f64 {E : Set} :
    Notations.DoubleColon Self "visit_f64" := {
    Notations.double_colon := visit_f64 (E := E);
  }.
  
  (*
              fn visit_str<E>(self, value: &str) -> Result<Value, E>
              where
                  E: serde::de::Error,
              {
                  self.visit_string(String::from(value))
              }
  *)
  Definition visit_str
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E}
      (self : Self)
      (value : ref str.t)
      : M (core.result.Result.t serde_json.value.Value.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_str
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E} :
    Notations.DoubleColon Self "visit_str" := {
    Notations.double_colon := visit_str (E := E);
  }.
  
  (*
              fn visit_string<E>(self, value: String) -> Result<Value, E> {
                  Ok(Value::String(value))
              }
  *)
  Definition visit_string
      {E : Set}
      (self : Self)
      (value : alloc.string.String.t)
      : M (core.result.Result.t serde_json.value.Value.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_string {E : Set} :
    Notations.DoubleColon Self "visit_string" := {
    Notations.double_colon := visit_string (E := E);
  }.
  
  (*
              fn visit_none<E>(self) -> Result<Value, E> {
                  Ok(Value::Null)
              }
  *)
  Definition visit_none
      {E : Set}
      (self : Self)
      : M (core.result.Result.t serde_json.value.Value.t E) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_none {E : Set} :
    Notations.DoubleColon Self "visit_none" := {
    Notations.double_colon := visit_none (E := E);
  }.
  
  (*
              fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>
              where
                  D: serde::Deserializer<'de>,
              {
                  Deserialize::deserialize(deserializer)
              }
  *)
  Definition visit_some
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D}
      (self : Self)
      (deserializer : D)
      : M (core.result.Result.t serde_json.value.Value.t D::type["Error"].t) :=
    let* self := M.alloc self in
    let* deserializer := M.alloc deserializer in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_some
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :
    Notations.DoubleColon Self "visit_some" := {
    Notations.double_colon := visit_some (D := D);
  }.
  
  (*
              fn visit_unit<E>(self) -> Result<Value, E> {
                  Ok(Value::Null)
              }
  *)
  Definition visit_unit
      {E : Set}
      (self : Self)
      : M (core.result.Result.t serde_json.value.Value.t E) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_unit {E : Set} :
    Notations.DoubleColon Self "visit_unit" := {
    Notations.double_colon := visit_unit (E := E);
  }.
  
  (*
              fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>
              where
                  V: SeqAccess<'de>,
              {
                  let mut vec = Vec::new();
  
                  while let Some(elem) = tri!(visitor.next_element()) {
                      vec.push(elem);
                  }
  
                  Ok(Value::Array(vec))
              }
  *)
  Definition visit_seq
      {V : Set}
      {ℋ_0 : serde.de.SeqAccess.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t serde_json.value.Value.t V::type["Error"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_seq
      {V : Set}
      {ℋ_0 : serde.de.SeqAccess.Trait V} :
    Notations.DoubleColon Self "visit_seq" := {
    Notations.double_colon := visit_seq (V := V);
  }.
  
  (*
              fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>
              where
                  V: MapAccess<'de>,
              {
                  match tri!(visitor.next_key_seed(KeyClassifier)) {
                      #[cfg(feature = "arbitrary_precision")]
                      Some(KeyClass::Number) => {
                          let number: NumberFromString = tri!(visitor.next_value());
                          Ok(Value::Number(number.value))
                      }
                      #[cfg(feature = "raw_value")]
                      Some(KeyClass::RawValue) => {
                          let value = tri!(visitor.next_value_seed(crate::raw::BoxedFromString));
                          crate::from_str(value.get()).map_err(de::Error::custom)
                      }
                      Some(KeyClass::Map(first_key)) => {
                          let mut values = Map::new();
  
                          values.insert(first_key, tri!(visitor.next_value()));
                          while let Some((key, value)) = tri!(visitor.next_entry()) {
                              values.insert(key, value);
                          }
  
                          Ok(Value::Object(values))
                      }
                      None => Ok(Value::Object(Map::new())),
                  }
              }
  *)
  Definition visit_map
      {V : Set}
      {ℋ_0 : serde.de.MapAccess.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t serde_json.value.Value.t V::type["Error"].t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_map
      {V : Set}
      {ℋ_0 : serde.de.MapAccess.Trait V} :
    Notations.DoubleColon Self "visit_map" := {
    Notations.double_colon := visit_map (V := V);
  }.
  
  Global Instance ℐ : serde.de.Visitor.Required.Trait Self := {
    serde.de.Visitor.Value := Value;
    serde.de.Visitor.expecting := expecting;
    serde.de.Visitor.visit_bool {E : Set} :=
      Datatypes.Some (visit_bool (E := E));
    serde.de.Visitor.visit_i64 {E : Set} := Datatypes.Some (visit_i64 (E := E));
    serde.de.Visitor.visit_u64 {E : Set} := Datatypes.Some (visit_u64 (E := E));
    serde.de.Visitor.visit_f64 {E : Set} := Datatypes.Some (visit_f64 (E := E));
    serde.de.Visitor.visit_str {E : Set} {ℋ_0 : serde.de.Error.Trait E} :=
      Datatypes.Some (visit_str (E := E));
    serde.de.Visitor.visit_string {E : Set} :=
      Datatypes.Some (visit_string (E := E));
    serde.de.Visitor.visit_none {E : Set} :=
      Datatypes.Some (visit_none (E := E));
    serde.de.Visitor.visit_some
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :=
      Datatypes.Some (visit_some (D := D));
    serde.de.Visitor.visit_unit {E : Set} :=
      Datatypes.Some (visit_unit (E := E));
    serde.de.Visitor.visit_seq {V : Set} {ℋ_0 : serde.de.SeqAccess.Trait V} :=
      Datatypes.Some (visit_seq (V := V));
    serde.de.Visitor.visit_map {V : Set} {ℋ_0 : serde.de.MapAccess.Trait V} :=
      Datatypes.Some (visit_map (V := V));
    serde.de.Visitor.visit_i8 := Datatypes.None;
    serde.de.Visitor.visit_i16 := Datatypes.None;
    serde.de.Visitor.visit_i32 := Datatypes.None;
    serde.de.Visitor.visit_i128 := Datatypes.None;
    serde.de.Visitor.visit_u8 := Datatypes.None;
    serde.de.Visitor.visit_u16 := Datatypes.None;
    serde.de.Visitor.visit_u32 := Datatypes.None;
    serde.de.Visitor.visit_u128 := Datatypes.None;
    serde.de.Visitor.visit_f32 := Datatypes.None;
    serde.de.Visitor.visit_char := Datatypes.None;
    serde.de.Visitor.visit_borrowed_str := Datatypes.None;
    serde.de.Visitor.visit_bytes := Datatypes.None;
    serde.de.Visitor.visit_borrowed_bytes := Datatypes.None;
    serde.de.Visitor.visit_byte_buf := Datatypes.None;
    serde.de.Visitor.visit_newtype_struct := Datatypes.None;
    serde.de.Visitor.visit_enum := Datatypes.None;
    serde.de.Visitor.__private_visit_untagged_option := Datatypes.None;
  }.
End Impl_serde_de_Visitor_for_serde_json_value_de_deserialize_ValueVisitor_t.
End Impl_serde_de_Visitor_for_serde_json_value_de_deserialize_ValueVisitor_t.

Module  Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
Section Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      type Err = Error;
  *)
  Definition Err : Set := serde_json.error.Error.t.
  
  (*
      fn from_str(s: &str) -> Result<Value, Error> {
          super::super::de::from_str(s)
      }
  *)
  Definition from_str
      (s : ref str.t)
      :
        M
          (core.result.Result.t
            serde_json.value.Value.t
            serde_json.error.Error.t) :=
    let* s := M.alloc s in
    M.read foo.
  
  Global Instance AssociatedFunction_from_str :
    Notations.DoubleColon Self "from_str" := {
    Notations.double_colon := from_str;
  }.
  
  Global Instance ℐ : core.str.traits.FromStr.Trait Self := {
    core.str.traits.FromStr.Err := Err;
    core.str.traits.FromStr.from_str := from_str;
  }.
End Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.
End Impl_core_str_traits_FromStr_for_serde_json_value_Value_t.

(*
fn visit_array<'de, V>(array: Vec<Value>, visitor: V) -> Result<V::Value, Error>
where
    V: Visitor<'de>,
{
    let len = array.len();
    let mut deserializer = SeqDeserializer::new(array);
    let seq = tri!(visitor.visit_seq(&mut deserializer));
    let remaining = deserializer.iter.len();
    if remaining == 0 {
        Ok(seq)
    } else {
        Err(serde::de::Error::invalid_length(
            len,
            &"fewer elements in array",
        ))
    }
}
*)
Definition visit_array
    {V : Set}
    {ℋ_0 : serde.de.Visitor.Trait V}
    (array_ : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A)
    (visitor : V)
    : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
  let* array_ := M.alloc array_ in
  let* visitor := M.alloc visitor in
  M.read foo.

(*
fn visit_object<'de, V>(object: Map<String, Value>, visitor: V) -> Result<V::Value, Error>
where
    V: Visitor<'de>,
{
    let len = object.len();
    let mut deserializer = MapDeserializer::new(object);
    let map = tri!(visitor.visit_map(&mut deserializer));
    let remaining = deserializer.iter.len();
    if remaining == 0 {
        Ok(map)
    } else {
        Err(serde::de::Error::invalid_length(
            len,
            &"fewer elements in map",
        ))
    }
}
*)
Definition visit_object
    {V : Set}
    {ℋ_0 : serde.de.Visitor.Trait V}
    (object
      :
      serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
    (visitor : V)
    : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
  let* object := M.alloc object in
  let* visitor := M.alloc visitor in
  M.read foo.

Module  Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
Section Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Null => visitor.visit_unit(),
              Value::Bool(v) => visitor.visit_bool(v),
              Value::Number(n) => n.deserialize_any(visitor),
              #[cfg(any(feature = "std", feature = "alloc"))]
              Value::String(v) => visitor.visit_string(v),
              Value::Array(v) => visit_array(v, visitor),
              Value::Object(v) => visit_object(v, visitor),
          }
      }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
      fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Null => visitor.visit_none(),
              _ => visitor.visit_some(self),
          }
      }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
      fn deserialize_enum<V>(
          self,
          _name: &str,
          _variants: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          let (variant, value) = match self {
              Value::Object(value) => {
                  let mut iter = value.into_iter();
                  let (variant, value) = match iter.next() {
                      Some(v) => v,
                      None => {
                          return Err(serde::de::Error::invalid_value(
                              Unexpected::Map,
                              &"map with a single key",
                          ));
                      }
                  };
                  // enums are encoded in json as maps with a single key:value pair
                  if iter.next().is_some() {
                      return Err(serde::de::Error::invalid_value(
                          Unexpected::Map,
                          &"map with a single key",
                      ));
                  }
                  (variant, Some(value))
              }
              Value::String(variant) => (variant, None),
              other => {
                  return Err(serde::de::Error::invalid_type(
                      other.unexpected(),
                      &"string or map",
                  ));
              }
          };
  
          visitor.visit_enum(EnumDeserializer { variant, value })
      }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variants := M.alloc _variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
      fn deserialize_newtype_struct<V>(
          self,
          name: &'static str,
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          #[cfg(feature = "raw_value")]
          {
              if name == crate::raw::TOKEN {
                  return visitor.visit_map(crate::raw::OwnedRawDeserializer {
                      raw_value: Some(self.to_string()),
                  });
              }
          }
  
          let _ = name;
          visitor.visit_newtype_struct(self)
      }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
      fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Bool(v) => visitor.visit_bool(v),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
      fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_string(visitor)
      }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
      fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_string(visitor)
      }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
      fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              #[cfg(any(feature = "std", feature = "alloc"))]
              Value::String(v) => visitor.visit_string(v),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
      fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_byte_buf(visitor)
      }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
      fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              #[cfg(any(feature = "std", feature = "alloc"))]
              Value::String(v) => visitor.visit_string(v),
              Value::Array(v) => visit_array(v, visitor),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
      fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Null => visitor.visit_unit(),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
      fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_unit(visitor)
      }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
      fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Array(v) => visit_array(v, visitor),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
      fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_seq(visitor)
      }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
      fn deserialize_tuple_struct<V>(
          self,
          _name: &'static str,
          _len: usize,
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_seq(visitor)
      }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
      fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Object(v) => visit_object(v, visitor),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
      fn deserialize_struct<V>(
          self,
          _name: &'static str,
          _fields: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Array(v) => visit_array(v, visitor),
              Value::Object(v) => visit_object(v, visitor),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _fields := M.alloc _fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
      fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_string(visitor)
      }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
      fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          drop(self);
          visitor.visit_unit()
      }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_serde_json_value_Value_t.
End Impl_serde_de_Deserializer_for_serde_json_value_Value_t.

Module  EnumDeserializer.
Section EnumDeserializer.
  Record t : Set := {
    variant : alloc.string.String.t;
    value : core.option.Option.t serde_json.value.Value.t;
  }.
  
  Definition Get_variant :=
    Ref.map
      (fun α => Some α.(variant))
      (fun β α => Some (α <| variant := β |>)).
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End EnumDeserializer.
End EnumDeserializer.

Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
Section Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
  Definition Self : Set := serde_json.value.de.EnumDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      type Variant = VariantDeserializer;
  *)
  Definition Variant : Set := serde_json.value.de.VariantDeserializer.t.
  
  (*
      fn variant_seed<V>(self, seed: V) -> Result<(V::Value, VariantDeserializer), Error>
      where
          V: DeserializeSeed<'de>,
      {
          let variant = self.variant.into_deserializer();
          let visitor = VariantDeserializer { value: self.value };
          seed.deserialize(variant).map(|v| (v, visitor))
      }
  *)
  Definition variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V}
      (self : Self)
      (seed : V)
      :
        M
          (core.result.Result.t
            (V::type["Value"].t * serde_json.value.de.VariantDeserializer.t)
            serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
    Notations.DoubleColon Self "variant_seed" := {
    Notations.double_colon := variant_seed (V := V);
  }.
  
  Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
    serde.de.EnumAccess.Error := Error;
    serde.de.EnumAccess.Variant := Variant;
    serde.de.EnumAccess.variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
      variant_seed (V := V);
    serde.de.EnumAccess.variant := Datatypes.None;
  }.
End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.
End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumDeserializer_t.

Module  Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
Section Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      type Deserializer = Self;
  *)
  Definition Deserializer : Set := Self.
  
  (*
      fn into_deserializer(self) -> Self::Deserializer {
          self
      }
  *)
  Definition into_deserializer (self : Self) : M Deserializer :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_deserializer :
    Notations.DoubleColon Self "into_deserializer" := {
    Notations.double_colon := into_deserializer;
  }.
  
  Global Instance ℐ :
    serde.de.IntoDeserializer.Trait Self (E := serde_json.error.Error.t) := {
    serde.de.IntoDeserializer.Deserializer := Deserializer;
    serde.de.IntoDeserializer.into_deserializer := into_deserializer;
  }.
End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.
End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_serde_json_value_Value_t.

Module  Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
Section Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
      type Deserializer = Self;
  *)
  Definition Deserializer : Set := Self.
  
  (*
      fn into_deserializer(self) -> Self::Deserializer {
          self
      }
  *)
  Definition into_deserializer (self : Self) : M Deserializer :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_deserializer :
    Notations.DoubleColon Self "into_deserializer" := {
    Notations.double_colon := into_deserializer;
  }.
  
  Global Instance ℐ :
    serde.de.IntoDeserializer.Trait Self (E := serde_json.error.Error.t) := {
    serde.de.IntoDeserializer.Deserializer := Deserializer;
    serde.de.IntoDeserializer.into_deserializer := into_deserializer;
  }.
End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.
End Impl_serde_de_IntoDeserializer_serde_json_error_Error_t_for_ref_serde_json_value_Value_t.

Module  VariantDeserializer.
Section VariantDeserializer.
  Record t : Set := {
    value : core.option.Option.t serde_json.value.Value.t;
  }.
  
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End VariantDeserializer.
End VariantDeserializer.

Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
Section Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
  Definition Self : Set := serde_json.value.de.VariantDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn unit_variant(self) -> Result<(), Error> {
          match self.value {
              Some(value) => Deserialize::deserialize(value),
              None => Ok(()),
          }
      }
  *)
  Definition unit_variant
      (self : Self)
      : M (core.result.Result.t unit serde_json.error.Error.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_unit_variant :
    Notations.DoubleColon Self "unit_variant" := {
    Notations.double_colon := unit_variant;
  }.
  
  (*
      fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.value {
              Some(value) => seed.deserialize(value),
              None => Err(serde::de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"newtype variant",
              )),
          }
      }
  *)
  Definition newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : Self)
      (seed : T)
      : M (core.result.Result.t T::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "newtype_variant_seed" := {
    Notations.double_colon := newtype_variant_seed (T := T);
  }.
  
  (*
      fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self.value {
              Some(Value::Array(v)) => {
                  if v.is_empty() {
                      visitor.visit_unit()
                  } else {
                      visit_array(v, visitor)
                  }
              }
              Some(other) => Err(serde::de::Error::invalid_type(
                  other.unexpected(),
                  &"tuple variant",
              )),
              None => Err(serde::de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"tuple variant",
              )),
          }
      }
  *)
  Definition tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "tuple_variant" := {
    Notations.double_colon := tuple_variant (V := V);
  }.
  
  (*
      fn struct_variant<V>(
          self,
          _fields: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self.value {
              Some(Value::Object(v)) => visit_object(v, visitor),
              Some(other) => Err(serde::de::Error::invalid_type(
                  other.unexpected(),
                  &"struct variant",
              )),
              None => Err(serde::de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"struct variant",
              )),
          }
      }
  *)
  Definition struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _fields := M.alloc _fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "struct_variant" := {
    Notations.double_colon := struct_variant (V := V);
  }.
  
  Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
    serde.de.VariantAccess.Error := Error;
    serde.de.VariantAccess.unit_variant := unit_variant;
    serde.de.VariantAccess.newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      newtype_variant_seed (T := T);
    serde.de.VariantAccess.tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      tuple_variant (V := V);
    serde.de.VariantAccess.struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      struct_variant (V := V);
    serde.de.VariantAccess.newtype_variant := Datatypes.None;
  }.
End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.
End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantDeserializer_t.

Module  SeqDeserializer.
Section SeqDeserializer.
  Record t : Set := {
    iter :
      alloc.vec.into_iter.IntoIter.t
        serde_json.value.Value.t
        alloc.vec.into_iter.IntoIter.Default.A;
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
End SeqDeserializer.
End SeqDeserializer.

Module  Impl_serde_json_value_de_SeqDeserializer_t_3.
Section Impl_serde_json_value_de_SeqDeserializer_t_3.
  Definition Self : Set := serde_json.value.de.SeqDeserializer.t.
  
  (*
      fn new(vec: Vec<Value>) -> Self {
          SeqDeserializer {
              iter: vec.into_iter(),
          }
      }
  *)
  Definition new
      (vec : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A)
      : M Self :=
    let* vec := M.alloc vec in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_value_de_SeqDeserializer_t_3.
End Impl_serde_json_value_de_SeqDeserializer_t_3.

Module  Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
Section Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
  Definition Self : Set := serde_json.value.de.SeqDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.iter.next() {
              Some(value) => seed.deserialize(value).map(Some),
              None => Ok(None),
          }
      }
  *)
  Definition next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      :
        M
          (core.result.Result.t
            (core.option.Option.t T::type["Value"].t)
            serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_element_seed" := {
    Notations.double_colon := next_element_seed (T := T);
  }.
  
  (*
      fn size_hint(&self) -> Option<usize> {
          match self.iter.size_hint() {
              (lower, Some(upper)) if lower == upper => Some(upper),
              _ => None,
          }
      }
  *)
  Definition size_hint (self : ref Self) : M (core.option.Option.t usize.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
    serde.de.SeqAccess.Error := Error;
    serde.de.SeqAccess.next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_element_seed (T := T);
    serde.de.SeqAccess.size_hint := Datatypes.Some size_hint;
    serde.de.SeqAccess.next_element := Datatypes.None;
  }.
End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.
End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqDeserializer_t.

Module  MapDeserializer.
Section MapDeserializer.
  Record t : Set := {
    iter :
      core.iter.traits.collect.IntoIterator.IntoIter
        (Self := serde_json.map.Map.t
          alloc.string.String.t
          serde_json.value.Value.t)
        (Trait := ltac:(refine _));
    value : core.option.Option.t serde_json.value.Value.t;
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End MapDeserializer.
End MapDeserializer.

Module  Impl_serde_json_value_de_MapDeserializer_t_3.
Section Impl_serde_json_value_de_MapDeserializer_t_3.
  Definition Self : Set := serde_json.value.de.MapDeserializer.t.
  
  (*
      fn new(map: Map<String, Value>) -> Self {
          MapDeserializer {
              iter: map.into_iter(),
              value: None,
          }
      }
  *)
  Definition new
      (map
        :
        serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
      : M Self :=
    let* map := M.alloc map in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_value_de_MapDeserializer_t_3.
End Impl_serde_json_value_de_MapDeserializer_t_3.

Module  Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
Section Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
  Definition Self : Set := serde_json.value.de.MapDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.iter.next() {
              Some((key, value)) => {
                  self.value = Some(value);
                  let key_de = MapKeyDeserializer {
                      key: Cow::Owned(key),
                  };
                  seed.deserialize(key_de).map(Some)
              }
              None => Ok(None),
          }
      }
  *)
  Definition next_key_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      :
        M
          (core.result.Result.t
            (core.option.Option.t T::type["Value"].t)
            serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_key_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_key_seed" := {
    Notations.double_colon := next_key_seed (T := T);
  }.
  
  (*
      fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.value.take() {
              Some(value) => seed.deserialize(value),
              None => Err(serde::de::Error::custom("value is missing")),
          }
      }
  *)
  Definition next_value_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      : M (core.result.Result.t T::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_value_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_value_seed" := {
    Notations.double_colon := next_value_seed (T := T);
  }.
  
  (*
      fn size_hint(&self) -> Option<usize> {
          match self.iter.size_hint() {
              (lower, Some(upper)) if lower == upper => Some(upper),
              _ => None,
          }
      }
  *)
  Definition size_hint (self : ref Self) : M (core.option.Option.t usize.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
    serde.de.MapAccess.Error := Error;
    serde.de.MapAccess.next_key_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_key_seed (T := T);
    serde.de.MapAccess.next_value_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_value_seed (T := T);
    serde.de.MapAccess.size_hint := Datatypes.Some size_hint;
    serde.de.MapAccess.next_entry_seed := Datatypes.None;
    serde.de.MapAccess.next_key := Datatypes.None;
    serde.de.MapAccess.next_value := Datatypes.None;
    serde.de.MapAccess.next_entry := Datatypes.None;
  }.
End Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.
End Impl_serde_de_MapAccess_for_serde_json_value_de_MapDeserializer_t.

(*
fn visit_array_ref<'de, V>(array: &'de [Value], visitor: V) -> Result<V::Value, Error>
where
    V: Visitor<'de>,
{
    let len = array.len();
    let mut deserializer = SeqRefDeserializer::new(array);
    let seq = tri!(visitor.visit_seq(&mut deserializer));
    let remaining = deserializer.iter.len();
    if remaining == 0 {
        Ok(seq)
    } else {
        Err(serde::de::Error::invalid_length(
            len,
            &"fewer elements in array",
        ))
    }
}
*)
Definition visit_array_ref
    {V : Set}
    {ℋ_0 : serde.de.Visitor.Trait V}
    (array_ : ref (slice serde_json.value.Value.t))
    (visitor : V)
    : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
  let* array_ := M.alloc array_ in
  let* visitor := M.alloc visitor in
  M.read foo.

(*
fn visit_object_ref<'de, V>(object: &'de Map<String, Value>, visitor: V) -> Result<V::Value, Error>
where
    V: Visitor<'de>,
{
    let len = object.len();
    let mut deserializer = MapRefDeserializer::new(object);
    let map = tri!(visitor.visit_map(&mut deserializer));
    let remaining = deserializer.iter.len();
    if remaining == 0 {
        Ok(map)
    } else {
        Err(serde::de::Error::invalid_length(
            len,
            &"fewer elements in map",
        ))
    }
}
*)
Definition visit_object_ref
    {V : Set}
    {ℋ_0 : serde.de.Visitor.Trait V}
    (object
      :
      ref (serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t))
    (visitor : V)
    : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
  let* object := M.alloc object in
  let* visitor := M.alloc visitor in
  M.read foo.

Module  Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
Section Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Null => visitor.visit_unit(),
              Value::Bool(v) => visitor.visit_bool( *v),
              Value::Number(n) => n.deserialize_any(visitor),
              Value::String(v) => visitor.visit_borrowed_str(v),
              Value::Array(v) => visit_array_ref(v, visitor),
              Value::Object(v) => visit_object_ref(v, visitor),
          }
      }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self {
                  Value::Number(n) => n.deserialize_any(visitor),
                  _ => Err(self.invalid_type(&visitor)),
              }
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
      fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match *self {
              Value::Null => visitor.visit_none(),
              _ => visitor.visit_some(self),
          }
      }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
      fn deserialize_enum<V>(
          self,
          _name: &str,
          _variants: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          let (variant, value) = match self {
              Value::Object(value) => {
                  let mut iter = value.into_iter();
                  let (variant, value) = match iter.next() {
                      Some(v) => v,
                      None => {
                          return Err(serde::de::Error::invalid_value(
                              Unexpected::Map,
                              &"map with a single key",
                          ));
                      }
                  };
                  // enums are encoded in json as maps with a single key:value pair
                  if iter.next().is_some() {
                      return Err(serde::de::Error::invalid_value(
                          Unexpected::Map,
                          &"map with a single key",
                      ));
                  }
                  (variant, Some(value))
              }
              Value::String(variant) => (variant, None),
              other => {
                  return Err(serde::de::Error::invalid_type(
                      other.unexpected(),
                      &"string or map",
                  ));
              }
          };
  
          visitor.visit_enum(EnumRefDeserializer { variant, value })
      }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variants := M.alloc _variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
      fn deserialize_newtype_struct<V>(
          self,
          name: &'static str,
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          #[cfg(feature = "raw_value")]
          {
              if name == crate::raw::TOKEN {
                  return visitor.visit_map(crate::raw::OwnedRawDeserializer {
                      raw_value: Some(self.to_string()),
                  });
              }
          }
  
          let _ = name;
          visitor.visit_newtype_struct(self)
      }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
      fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match *self {
              Value::Bool(v) => visitor.visit_bool(v),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
      fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_str(visitor)
      }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
      fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::String(v) => visitor.visit_borrowed_str(v),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
      fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_str(visitor)
      }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
      fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::String(v) => visitor.visit_borrowed_str(v),
              Value::Array(v) => visit_array_ref(v, visitor),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
      fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_bytes(visitor)
      }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
      fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match *self {
              Value::Null => visitor.visit_unit(),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
      fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_unit(visitor)
      }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
      fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Array(v) => visit_array_ref(v, visitor),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
      fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_seq(visitor)
      }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
      fn deserialize_tuple_struct<V>(
          self,
          _name: &'static str,
          _len: usize,
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_seq(visitor)
      }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
      fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Object(v) => visit_object_ref(v, visitor),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
      fn deserialize_struct<V>(
          self,
          _name: &'static str,
          _fields: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self {
              Value::Array(v) => visit_array_ref(v, visitor),
              Value::Object(v) => visit_object_ref(v, visitor),
              _ => Err(self.invalid_type(&visitor)),
          }
      }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _fields := M.alloc _fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
      fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_str(visitor)
      }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
      fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_unit()
      }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.
End Impl_serde_de_Deserializer_for_ref_serde_json_value_Value_t.

Module  EnumRefDeserializer.
Section EnumRefDeserializer.
  Record t : Set := {
    variant : ref str.t;
    value : core.option.Option.t (ref serde_json.value.Value.t);
  }.
  
  Definition Get_variant :=
    Ref.map
      (fun α => Some α.(variant))
      (fun β α => Some (α <| variant := β |>)).
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End EnumRefDeserializer.
End EnumRefDeserializer.

Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
Section Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
  Definition Self : Set := serde_json.value.de.EnumRefDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      type Variant = VariantRefDeserializer<'de>;
  *)
  Definition Variant : Set := serde_json.value.de.VariantRefDeserializer.t.
  
  (*
      fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Error>
      where
          V: DeserializeSeed<'de>,
      {
          let variant = self.variant.into_deserializer();
          let visitor = VariantRefDeserializer { value: self.value };
          seed.deserialize(variant).map(|v| (v, visitor))
      }
  *)
  Definition variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V}
      (self : Self)
      (seed : V)
      :
        M
          (core.result.Result.t
            (V::type["Value"].t * Variant)
            serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
    Notations.DoubleColon Self "variant_seed" := {
    Notations.double_colon := variant_seed (V := V);
  }.
  
  Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
    serde.de.EnumAccess.Error := Error;
    serde.de.EnumAccess.Variant := Variant;
    serde.de.EnumAccess.variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
      variant_seed (V := V);
    serde.de.EnumAccess.variant := Datatypes.None;
  }.
End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.
End Impl_serde_de_EnumAccess_for_serde_json_value_de_EnumRefDeserializer_t.

Module  VariantRefDeserializer.
Section VariantRefDeserializer.
  Record t : Set := {
    value : core.option.Option.t (ref serde_json.value.Value.t);
  }.
  
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End VariantRefDeserializer.
End VariantRefDeserializer.

Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
Section Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
  Definition Self : Set := serde_json.value.de.VariantRefDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn unit_variant(self) -> Result<(), Error> {
          match self.value {
              Some(value) => Deserialize::deserialize(value),
              None => Ok(()),
          }
      }
  *)
  Definition unit_variant
      (self : Self)
      : M (core.result.Result.t unit serde_json.error.Error.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_unit_variant :
    Notations.DoubleColon Self "unit_variant" := {
    Notations.double_colon := unit_variant;
  }.
  
  (*
      fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.value {
              Some(value) => seed.deserialize(value),
              None => Err(serde::de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"newtype variant",
              )),
          }
      }
  *)
  Definition newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : Self)
      (seed : T)
      : M (core.result.Result.t T::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "newtype_variant_seed" := {
    Notations.double_colon := newtype_variant_seed (T := T);
  }.
  
  (*
      fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self.value {
              Some(Value::Array(v)) => {
                  if v.is_empty() {
                      visitor.visit_unit()
                  } else {
                      visit_array_ref(v, visitor)
                  }
              }
              Some(other) => Err(serde::de::Error::invalid_type(
                  other.unexpected(),
                  &"tuple variant",
              )),
              None => Err(serde::de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"tuple variant",
              )),
          }
      }
  *)
  Definition tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "tuple_variant" := {
    Notations.double_colon := tuple_variant (V := V);
  }.
  
  (*
      fn struct_variant<V>(
          self,
          _fields: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          match self.value {
              Some(Value::Object(v)) => visit_object_ref(v, visitor),
              Some(other) => Err(serde::de::Error::invalid_type(
                  other.unexpected(),
                  &"struct variant",
              )),
              None => Err(serde::de::Error::invalid_type(
                  Unexpected::UnitVariant,
                  &"struct variant",
              )),
          }
      }
  *)
  Definition struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _fields := M.alloc _fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "struct_variant" := {
    Notations.double_colon := struct_variant (V := V);
  }.
  
  Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
    serde.de.VariantAccess.Error := Error;
    serde.de.VariantAccess.unit_variant := unit_variant;
    serde.de.VariantAccess.newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      newtype_variant_seed (T := T);
    serde.de.VariantAccess.tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      tuple_variant (V := V);
    serde.de.VariantAccess.struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      struct_variant (V := V);
    serde.de.VariantAccess.newtype_variant := Datatypes.None;
  }.
End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.
End Impl_serde_de_VariantAccess_for_serde_json_value_de_VariantRefDeserializer_t.

Module  SeqRefDeserializer.
Section SeqRefDeserializer.
  Record t : Set := {
    iter : core.slice.iter.Iter.t serde_json.value.Value.t;
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
End SeqRefDeserializer.
End SeqRefDeserializer.

Module  Impl_serde_json_value_de_SeqRefDeserializer_t_3.
Section Impl_serde_json_value_de_SeqRefDeserializer_t_3.
  Definition Self : Set := serde_json.value.de.SeqRefDeserializer.t.
  
  (*
      fn new(slice: &'de [Value]) -> Self {
          SeqRefDeserializer { iter: slice.iter() }
      }
  *)
  Definition new (slice : ref (slice serde_json.value.Value.t)) : M Self :=
    let* slice := M.alloc slice in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_value_de_SeqRefDeserializer_t_3.
End Impl_serde_json_value_de_SeqRefDeserializer_t_3.

Module  Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
Section Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
  Definition Self : Set := serde_json.value.de.SeqRefDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.iter.next() {
              Some(value) => seed.deserialize(value).map(Some),
              None => Ok(None),
          }
      }
  *)
  Definition next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      :
        M
          (core.result.Result.t
            (core.option.Option.t T::type["Value"].t)
            serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_element_seed" := {
    Notations.double_colon := next_element_seed (T := T);
  }.
  
  (*
      fn size_hint(&self) -> Option<usize> {
          match self.iter.size_hint() {
              (lower, Some(upper)) if lower == upper => Some(upper),
              _ => None,
          }
      }
  *)
  Definition size_hint (self : ref Self) : M (core.option.Option.t usize.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
    serde.de.SeqAccess.Error := Error;
    serde.de.SeqAccess.next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_element_seed (T := T);
    serde.de.SeqAccess.size_hint := Datatypes.Some size_hint;
    serde.de.SeqAccess.next_element := Datatypes.None;
  }.
End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.
End Impl_serde_de_SeqAccess_for_serde_json_value_de_SeqRefDeserializer_t.

Module  MapRefDeserializer.
Section MapRefDeserializer.
  Record t : Set := {
    iter :
      core.iter.traits.collect.IntoIterator.IntoIter
        (Self := ref
          (serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t))
        (Trait := ltac:(refine _));
    value : core.option.Option.t (ref serde_json.value.Value.t);
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End MapRefDeserializer.
End MapRefDeserializer.

Module  Impl_serde_json_value_de_MapRefDeserializer_t_3.
Section Impl_serde_json_value_de_MapRefDeserializer_t_3.
  Definition Self : Set := serde_json.value.de.MapRefDeserializer.t.
  
  (*
      fn new(map: &'de Map<String, Value>) -> Self {
          MapRefDeserializer {
              iter: map.into_iter(),
              value: None,
          }
      }
  *)
  Definition new
      (map
        :
        ref
          (serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t))
      : M Self :=
    let* map := M.alloc map in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_value_de_MapRefDeserializer_t_3.
End Impl_serde_json_value_de_MapRefDeserializer_t_3.

Module  Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
Section Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
  Definition Self : Set := serde_json.value.de.MapRefDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.iter.next() {
              Some((key, value)) => {
                  self.value = Some(value);
                  let key_de = MapKeyDeserializer {
                      key: Cow::Borrowed(&**key),
                  };
                  seed.deserialize(key_de).map(Some)
              }
              None => Ok(None),
          }
      }
  *)
  Definition next_key_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      :
        M
          (core.result.Result.t
            (core.option.Option.t T::type["Value"].t)
            serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_key_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_key_seed" := {
    Notations.double_colon := next_key_seed (T := T);
  }.
  
  (*
      fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.value.take() {
              Some(value) => seed.deserialize(value),
              None => Err(serde::de::Error::custom("value is missing")),
          }
      }
  *)
  Definition next_value_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      : M (core.result.Result.t T::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_value_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_value_seed" := {
    Notations.double_colon := next_value_seed (T := T);
  }.
  
  (*
      fn size_hint(&self) -> Option<usize> {
          match self.iter.size_hint() {
              (lower, Some(upper)) if lower == upper => Some(upper),
              _ => None,
          }
      }
  *)
  Definition size_hint (self : ref Self) : M (core.option.Option.t usize.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
    serde.de.MapAccess.Error := Error;
    serde.de.MapAccess.next_key_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_key_seed (T := T);
    serde.de.MapAccess.next_value_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_value_seed (T := T);
    serde.de.MapAccess.size_hint := Datatypes.Some size_hint;
    serde.de.MapAccess.next_entry_seed := Datatypes.None;
    serde.de.MapAccess.next_key := Datatypes.None;
    serde.de.MapAccess.next_value := Datatypes.None;
    serde.de.MapAccess.next_entry := Datatypes.None;
  }.
End Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.
End Impl_serde_de_MapAccess_for_serde_json_value_de_MapRefDeserializer_t.

Module  MapKeyDeserializer.
Section MapKeyDeserializer.
  Record t : Set := {
    key : alloc.borrow.Cow.t str.t;
  }.
  
  Definition Get_key :=
    Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
End MapKeyDeserializer.
End MapKeyDeserializer.

Module  Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
Section Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
  Definition Self : Set := serde_json.value.de.MapKeyDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          BorrowedCowStrDeserializer::new(self.key).deserialize_any(visitor)
      }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $method<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              let mut de = crate::Deserializer::from_str(&self.key);
  
              match tri!(de.peek()) {
                  Some(b'0'..=b'9' | b'-') => {}
                  _ => return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0)),
              }
  
              let number = tri!(de.$using(visitor));
  
              if tri!(de.peek()).is_some() {
                  return Err(Error::syntax(ErrorCode::ExpectedNumericKey, 0, 0));
              }
  
              Ok(number)
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
      fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          if self.key == "true" {
              visitor.visit_bool(true)
          } else if self.key == "false" {
              visitor.visit_bool(false)
          } else {
              Err(serde::de::Error::invalid_type(
                  Unexpected::Str(&self.key),
                  &visitor,
              ))
          }
      }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
      fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          // Map keys cannot be null.
          visitor.visit_some(self)
      }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
      fn deserialize_newtype_struct<V>(
          self,
          _name: &'static str,
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_newtype_struct(self)
      }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
      fn deserialize_enum<V>(
          self,
          name: &'static str,
          variants: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: Visitor<'de>,
      {
          self.key
              .into_deserializer()
              .deserialize_enum(name, variants, visitor)
      }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* variants := M.alloc variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* fields := M.alloc fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.
End Impl_serde_de_Deserializer_for_serde_json_value_de_MapKeyDeserializer_t.

Module  KeyClassifier.
Section KeyClassifier.
  Inductive t : Set := Build.
End KeyClassifier.
End KeyClassifier.

Module KeyClass.
  Inductive t : Set :=
  | Map (_ : alloc.string.String.t).
  
  Definition Get_Map_0 :=
    Ref.map
      (fun α => match α with | Map α0 => Some α0 end)
      (fun β α => match α with | Map _ => Some (Map β) end).
End KeyClass.

Module  Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
Section Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
  Definition Self : Set := serde_json.value.de.KeyClassifier.t.
  
  (*
      type Value = KeyClass;
  *)
  Definition Value : Set := serde_json.value.de.KeyClass.t.
  
  (*
      fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
      where
          D: serde::Deserializer<'de>,
      {
          deserializer.deserialize_str(self)
      }
  *)
  Definition deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D}
      (self : Self)
      (deserializer : D)
      : M (core.result.Result.t Value D::type["Error"].t) :=
    let* self := M.alloc self in
    let* deserializer := M.alloc deserializer in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :
    Notations.DoubleColon Self "deserialize" := {
    Notations.double_colon := deserialize (D := D);
  }.
  
  Global Instance ℐ : serde.de.DeserializeSeed.Trait Self := {
    serde.de.DeserializeSeed.Value := Value;
    serde.de.DeserializeSeed.deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :=
      deserialize (D := D);
  }.
End Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.
End Impl_serde_de_DeserializeSeed_for_serde_json_value_de_KeyClassifier_t.

Module  Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
Section Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
  Definition Self : Set := serde_json.value.de.KeyClassifier.t.
  
  (*
      type Value = KeyClass;
  *)
  Definition Value : Set := serde_json.value.de.KeyClass.t.
  
  (*
      fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
          formatter.write_str("a string key")
      }
  *)
  Definition expecting
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_expecting :
    Notations.DoubleColon Self "expecting" := {
    Notations.double_colon := expecting;
  }.
  
  (*
      fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>
      where
          E: de::Error,
      {
          match s {
              #[cfg(feature = "arbitrary_precision")]
              crate::number::TOKEN => Ok(KeyClass::Number),
              #[cfg(feature = "raw_value")]
              crate::raw::TOKEN => Ok(KeyClass::RawValue),
              _ => Ok(KeyClass::Map(s.to_owned())),
          }
      }
  *)
  Definition visit_str
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E}
      (self : Self)
      (s : ref str.t)
      : M (core.result.Result.t Value E) :=
    let* self := M.alloc self in
    let* s := M.alloc s in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_str
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E} :
    Notations.DoubleColon Self "visit_str" := {
    Notations.double_colon := visit_str (E := E);
  }.
  
  (*
      fn visit_string<E>(self, s: String) -> Result<Self::Value, E>
      where
          E: de::Error,
      {
          match s.as_str() {
              #[cfg(feature = "arbitrary_precision")]
              crate::number::TOKEN => Ok(KeyClass::Number),
              #[cfg(feature = "raw_value")]
              crate::raw::TOKEN => Ok(KeyClass::RawValue),
              _ => Ok(KeyClass::Map(s)),
          }
      }
  *)
  Definition visit_string
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E}
      (self : Self)
      (s : alloc.string.String.t)
      : M (core.result.Result.t Value E) :=
    let* self := M.alloc self in
    let* s := M.alloc s in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_string
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E} :
    Notations.DoubleColon Self "visit_string" := {
    Notations.double_colon := visit_string (E := E);
  }.
  
  Global Instance ℐ : serde.de.Visitor.Required.Trait Self := {
    serde.de.Visitor.Value := Value;
    serde.de.Visitor.expecting := expecting;
    serde.de.Visitor.visit_str {E : Set} {ℋ_0 : serde.de.Error.Trait E} :=
      Datatypes.Some (visit_str (E := E));
    serde.de.Visitor.visit_string {E : Set} {ℋ_0 : serde.de.Error.Trait E} :=
      Datatypes.Some (visit_string (E := E));
    serde.de.Visitor.visit_bool := Datatypes.None;
    serde.de.Visitor.visit_i8 := Datatypes.None;
    serde.de.Visitor.visit_i16 := Datatypes.None;
    serde.de.Visitor.visit_i32 := Datatypes.None;
    serde.de.Visitor.visit_i64 := Datatypes.None;
    serde.de.Visitor.visit_i128 := Datatypes.None;
    serde.de.Visitor.visit_u8 := Datatypes.None;
    serde.de.Visitor.visit_u16 := Datatypes.None;
    serde.de.Visitor.visit_u32 := Datatypes.None;
    serde.de.Visitor.visit_u64 := Datatypes.None;
    serde.de.Visitor.visit_u128 := Datatypes.None;
    serde.de.Visitor.visit_f32 := Datatypes.None;
    serde.de.Visitor.visit_f64 := Datatypes.None;
    serde.de.Visitor.visit_char := Datatypes.None;
    serde.de.Visitor.visit_borrowed_str := Datatypes.None;
    serde.de.Visitor.visit_bytes := Datatypes.None;
    serde.de.Visitor.visit_borrowed_bytes := Datatypes.None;
    serde.de.Visitor.visit_byte_buf := Datatypes.None;
    serde.de.Visitor.visit_none := Datatypes.None;
    serde.de.Visitor.visit_some := Datatypes.None;
    serde.de.Visitor.visit_unit := Datatypes.None;
    serde.de.Visitor.visit_newtype_struct := Datatypes.None;
    serde.de.Visitor.visit_seq := Datatypes.None;
    serde.de.Visitor.visit_map := Datatypes.None;
    serde.de.Visitor.visit_enum := Datatypes.None;
    serde.de.Visitor.__private_visit_untagged_option := Datatypes.None;
  }.
End Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.
End Impl_serde_de_Visitor_for_serde_json_value_de_KeyClassifier_t.

Module  Impl_serde_json_value_Value_t_5.
Section Impl_serde_json_value_Value_t_5.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn invalid_type<E>(&self, exp: &dyn Expected) -> E
      where
          E: serde::de::Error,
      {
          serde::de::Error::invalid_type(self.unexpected(), exp)
      }
  *)
  Definition invalid_type
      {E DynT : Set}
      {ℋ_0 : serde.de.Error.Trait E}
      {ℋ_1 : serde.de.Expected.Trait.Trait DynT}
      (self : ref Self)
      (exp : ref DynT)
      : M E :=
    let* self := M.alloc self in
    let* exp := M.alloc exp in
    M.read foo.
  
  Global Instance AssociatedFunction_invalid_type
      {E DynT : Set}
      {ℋ_0 : serde.de.Error.Trait E}
      {ℋ_1 : serde.de.Expected.Trait.Trait DynT} :
    Notations.DoubleColon Self "invalid_type" := {
    Notations.double_colon := invalid_type (E := E) (DynT := DynT);
  }.
  
  (*
      fn unexpected(&self) -> Unexpected {
          match self {
              Value::Null => Unexpected::Unit,
              Value::Bool(b) => Unexpected::Bool( *b),
              Value::Number(n) => n.unexpected(),
              Value::String(s) => Unexpected::Str(s),
              Value::Array(_) => Unexpected::Seq,
              Value::Object(_) => Unexpected::Map,
          }
      }
  *)
  Definition unexpected (self : ref Self) : M serde.de.Unexpected.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_unexpected :
    Notations.DoubleColon Self "unexpected" := {
    Notations.double_colon := unexpected;
  }.
End Impl_serde_json_value_Value_t_5.
End Impl_serde_json_value_Value_t_5.

Module  BorrowedCowStrDeserializer.
Section BorrowedCowStrDeserializer.
  Record t : Set := {
    value : alloc.borrow.Cow.t str.t;
  }.
  
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End BorrowedCowStrDeserializer.
End BorrowedCowStrDeserializer.

Module  Impl_serde_json_value_de_BorrowedCowStrDeserializer_t_3.
Section Impl_serde_json_value_de_BorrowedCowStrDeserializer_t_3.
  Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
  
  (*
      fn new(value: Cow<'de, str>) -> Self {
          BorrowedCowStrDeserializer { value }
      }
  *)
  Definition new (value : alloc.borrow.Cow.t str.t) : M Self :=
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_value_de_BorrowedCowStrDeserializer_t_3.
End Impl_serde_json_value_de_BorrowedCowStrDeserializer_t_3.

Module  Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
Section Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
  Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
      where
          V: de::Visitor<'de>,
      {
          match self.value {
              Cow::Borrowed(string) => visitor.visit_borrowed_str(string),
              #[cfg(any(feature = "std", feature = "alloc"))]
              Cow::Owned(string) => visitor.visit_string(string),
          }
      }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
      fn deserialize_enum<V>(
          self,
          _name: &str,
          _variants: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: de::Visitor<'de>,
      {
          visitor.visit_enum(self)
      }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variants := M.alloc _variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* fields := M.alloc fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
End Impl_serde_de_Deserializer_for_serde_json_value_de_BorrowedCowStrDeserializer_t.

Module  Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
Section Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
  Definition Self : Set := serde_json.value.de.BorrowedCowStrDeserializer.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      type Variant = UnitOnly;
  *)
  Definition Variant : Set := serde_json.value.de.UnitOnly.t.
  
  (*
      fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Error>
      where
          T: de::DeserializeSeed<'de>,
      {
          let value = tri!(seed.deserialize(self));
          Ok((value, UnitOnly))
      }
  *)
  Definition variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : Self)
      (seed : T)
      :
        M
          (core.result.Result.t
            (T::type["Value"].t * Variant)
            serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "variant_seed" := {
    Notations.double_colon := variant_seed (T := T);
  }.
  
  Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
    serde.de.EnumAccess.Error := Error;
    serde.de.EnumAccess.Variant := Variant;
    serde.de.EnumAccess.variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      variant_seed (T := T);
    serde.de.EnumAccess.variant := Datatypes.None;
  }.
End Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.
End Impl_serde_de_EnumAccess_for_serde_json_value_de_BorrowedCowStrDeserializer_t.

Module  UnitOnly.
Section UnitOnly.
  Inductive t : Set := Build.
End UnitOnly.
End UnitOnly.

Module  Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
Section Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
  Definition Self : Set := serde_json.value.de.UnitOnly.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn unit_variant(self) -> Result<(), Error> {
          Ok(())
      }
  *)
  Definition unit_variant
      (self : Self)
      : M (core.result.Result.t unit serde_json.error.Error.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_unit_variant :
    Notations.DoubleColon Self "unit_variant" := {
    Notations.double_colon := unit_variant;
  }.
  
  (*
      fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Error>
      where
          T: de::DeserializeSeed<'de>,
      {
          Err(de::Error::invalid_type(
              Unexpected::UnitVariant,
              &"newtype variant",
          ))
      }
  *)
  Definition newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : Self)
      (_seed : T)
      : M (core.result.Result.t T::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _seed := M.alloc _seed in
    M.read foo.
  
  Global Instance AssociatedFunction_newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "newtype_variant_seed" := {
    Notations.double_colon := newtype_variant_seed (T := T);
  }.
  
  (*
      fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Error>
      where
          V: de::Visitor<'de>,
      {
          Err(de::Error::invalid_type(
              Unexpected::UnitVariant,
              &"tuple variant",
          ))
      }
  *)
  Definition tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (_visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "tuple_variant" := {
    Notations.double_colon := tuple_variant (V := V);
  }.
  
  (*
      fn struct_variant<V>(
          self,
          _fields: &'static [&'static str],
          _visitor: V,
      ) -> Result<V::Value, Error>
      where
          V: de::Visitor<'de>,
      {
          Err(de::Error::invalid_type(
              Unexpected::UnitVariant,
              &"struct variant",
          ))
      }
  *)
  Definition struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_fields : ref (slice (ref str.t)))
      (_visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* _fields := M.alloc _fields in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "struct_variant" := {
    Notations.double_colon := struct_variant (V := V);
  }.
  
  Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
    serde.de.VariantAccess.Error := Error;
    serde.de.VariantAccess.unit_variant := unit_variant;
    serde.de.VariantAccess.newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      newtype_variant_seed (T := T);
    serde.de.VariantAccess.tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      tuple_variant (V := V);
    serde.de.VariantAccess.struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      struct_variant (V := V);
    serde.de.VariantAccess.newtype_variant := Datatypes.None;
  }.
End Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.
End Impl_serde_de_VariantAccess_for_serde_json_value_de_UnitOnly_t.

Module from.
  Module  Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : i8.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := i8.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : i16.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := i16.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : i32.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := i32.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : i64.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := i64.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : isize.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := isize.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : u8.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := u8.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : u16.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := u16.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : u32.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := u32.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : u64.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := u64.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn from(n: $ty) -> Self {
                        Value::Number(n.into())
                    }
    *)
    Definition from (n : usize.t) : M Self :=
      let* n := M.alloc n in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := usize.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: f32) -> Self {
            Number::from_f32(f).map_or(Value::Null, Value::Number)
        }
    *)
    Definition from (f : f32.t) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := f32.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: f64) -> Self {
            Number::from_f64(f).map_or(Value::Null, Value::Number)
        }
    *)
    Definition from (f : f64.t) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := f64.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: bool) -> Self {
            Value::Bool(f)
        }
    *)
    Definition from (f : bool.t) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := bool.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: String) -> Self {
            Value::String(f)
        }
    *)
    Definition from (f : alloc.string.String.t) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := alloc.string.String.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: &str) -> Self {
            Value::String(f.to_string())
        }
    *)
    Definition from (f : ref str.t) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := ref str.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: Cow<'a, str>) -> Self {
            Value::String(f.into_owned())
        }
    *)
    Definition from (f : alloc.borrow.Cow.t str.t) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := alloc.borrow.Cow.t str.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: Number) -> Self {
            Value::Number(f)
        }
    *)
    Definition from (f : serde_json.number.Number.t) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := serde_json.number.Number.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: Map<String, Value>) -> Self {
            Value::Object(f)
        }
    *)
    Definition from
        (f
          :
          serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
        : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := serde_json.map.Map.t
          alloc.string.String.t
          serde_json.value.Value.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
  End Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
    Context {T : Set}.
    
    Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
    
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: Vec<T>) -> Self {
            Value::Array(f.into_iter().map(Into::into).collect())
        }
    *)
    Definition from (f : alloc.vec.Vec.t T alloc.vec.Vec.Default.A) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := alloc.vec.Vec.t T alloc.vec.Vec.Default.A) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
  End Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
    Context {T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait T}
      {ℋ_1 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
    
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(f: &[T]) -> Self {
            Value::Array(f.iter().cloned().map(Into::into).collect())
        }
    *)
    Definition from (f : ref (slice T)) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := ref (slice T)) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
  End Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
  
  Module  Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
  Section Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
    Context {T : Set}.
    
    Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
    
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
            Value::Array(iter.into_iter().map(Into::into).collect())
        }
    *)
    Definition from_iter
        {I : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
        (iter : I)
        : M Self :=
      let* iter := M.alloc iter in
      M.read foo.
    
    Global Instance AssociatedFunction_from_iter
        {I : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :
      Notations.DoubleColon Self "from_iter" := {
      Notations.double_colon := from_iter (I := I);
    }.
    
    Global Instance ℐ :
      core.iter.traits.collect.FromIterator.Trait Self (A := T) := {
      core.iter.traits.collect.FromIterator.from_iter
        {I : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :=
        from_iter (I := I);
    }.
  End Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
  End Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
  
  Module  Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
  Section Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
    Context {K V : Set}.
    
    Context
      {ℋ_0 : core.convert.Into.Trait K (T := alloc.string.String.t)}
      {ℋ_1 : core.convert.Into.Trait V (T := serde_json.value.Value.t)}.
    
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {
            Value::Object(
                iter.into_iter()
                    .map(|(k, v)| (k.into(), v.into()))
                    .collect(),
            )
        }
    *)
    Definition from_iter
        {I : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
        (iter : I)
        : M Self :=
      let* iter := M.alloc iter in
      M.read foo.
    
    Global Instance AssociatedFunction_from_iter
        {I : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :
      Notations.DoubleColon Self "from_iter" := {
      Notations.double_colon := from_iter (I := I);
    }.
    
    Global Instance ℐ :
      core.iter.traits.collect.FromIterator.Trait Self (A := K * V) := {
      core.iter.traits.collect.FromIterator.from_iter
        {I : Set}
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :=
        from_iter (I := I);
    }.
  End Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
  End Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
  Section Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from((): ()) -> Self {
            Value::Null
        }
    *)
    Definition from (Pattern : unit) : M Self :=
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := unit) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
  End Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
  
  Module  Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
  Section Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
    Context {T : Set}.
    
    Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
    
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn from(opt: Option<T>) -> Self {
            match opt {
                None => Value::Null,
                Some(value) => Into::into(value),
            }
        }
    *)
    Definition from (opt : core.option.Option.t T) : M Self :=
      let* opt := M.alloc opt in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := core.option.Option.t T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
  End Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
End from.

Module  Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : i8.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := i8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_i8_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : i16.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := i16.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_i16_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : i32.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := i32.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_i32_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : i64.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := i64.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_i64_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : isize.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := isize.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_isize_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : u8.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_u8_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : u16.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u16.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_u16_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : u32.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u32.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_u32_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : u64.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u64.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_u64_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn from(n: $ty) -> Self {
                      Value::Number(n.into())
                  }
  *)
  Definition from (n : usize.t) : M Self :=
    let* n := M.alloc n in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := usize.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_usize_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: f32) -> Self {
          Number::from_f32(f).map_or(Value::Null, Value::Number)
      }
  *)
  Definition from (f : f32.t) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := f32.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_f32_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: f64) -> Self {
          Number::from_f64(f).map_or(Value::Null, Value::Number)
      }
  *)
  Definition from (f : f64.t) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := f64.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_f64_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: bool) -> Self {
          Value::Bool(f)
      }
  *)
  Definition from (f : bool.t) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := bool.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_bool_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: String) -> Self {
          Value::String(f)
      }
  *)
  Definition from (f : alloc.string.String.t) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := alloc.string.String.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_alloc_string_String_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: &str) -> Self {
          Value::String(f.to_string())
      }
  *)
  Definition from (f : ref str.t) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := ref str.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_ref_str_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: Cow<'a, str>) -> Self {
          Value::String(f.into_owned())
      }
  *)
  Definition from (f : alloc.borrow.Cow.t str.t) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := alloc.borrow.Cow.t str.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: Number) -> Self {
          Value::Number(f)
      }
  *)
  Definition from (f : serde_json.number.Number.t) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := serde_json.number.Number.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_serde_json_number_Number_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
Section Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: Map<String, Value>) -> Self {
          Value::Object(f)
      }
  *)
  Definition from
      (f : serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t)
      : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := serde_json.map.Map.t
        alloc.string.String.t
        serde_json.value.Value.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.
End Impl_core_convert_From_serde_json_map_Map_t_alloc_string_String_t_serde_json_value_Value_t_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
Section Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
  Context {T : Set}.
  
  Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
  
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: Vec<T>) -> Self {
          Value::Array(f.into_iter().map(Into::into).collect())
      }
  *)
  Definition from (f : alloc.vec.Vec.t T alloc.vec.Vec.Default.A) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := alloc.vec.Vec.t T alloc.vec.Vec.Default.A) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.
End Impl_core_convert_From_alloc_vec_Vec_t_T_alloc_vec_Vec_Default_A_for_serde_json_value_Value_t.

Module  Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
Section Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
  Context {T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait T}
    {ℋ_1 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
  
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(f: &[T]) -> Self {
          Value::Array(f.iter().cloned().map(Into::into).collect())
      }
  *)
  Definition from (f : ref (slice T)) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := ref (slice T)) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.
End Impl_core_convert_From_ref_slice_T_for_serde_json_value_Value_t.

Module  Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
Section Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
  Context {T : Set}.
  
  Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
  
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
          Value::Array(iter.into_iter().map(Into::into).collect())
      }
  *)
  Definition from_iter
      {I : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
      (iter : I)
      : M Self :=
    let* iter := M.alloc iter in
    M.read foo.
  
  Global Instance AssociatedFunction_from_iter
      {I : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :
    Notations.DoubleColon Self "from_iter" := {
    Notations.double_colon := from_iter (I := I);
  }.
  
  Global Instance ℐ :
    core.iter.traits.collect.FromIterator.Trait Self (A := T) := {
    core.iter.traits.collect.FromIterator.from_iter
      {I : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :=
      from_iter (I := I);
  }.
End Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.
End Impl_core_iter_traits_collect_FromIterator_T_for_serde_json_value_Value_t.

Module  Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
Section Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.convert.Into.Trait K (T := alloc.string.String.t)}
    {ℋ_1 : core.convert.Into.Trait V (T := serde_json.value.Value.t)}.
  
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {
          Value::Object(
              iter.into_iter()
                  .map(|(k, v)| (k.into(), v.into()))
                  .collect(),
          )
      }
  *)
  Definition from_iter
      {I : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
      (iter : I)
      : M Self :=
    let* iter := M.alloc iter in
    M.read foo.
  
  Global Instance AssociatedFunction_from_iter
      {I : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :
    Notations.DoubleColon Self "from_iter" := {
    Notations.double_colon := from_iter (I := I);
  }.
  
  Global Instance ℐ :
    core.iter.traits.collect.FromIterator.Trait Self (A := K * V) := {
    core.iter.traits.collect.FromIterator.from_iter
      {I : Set}
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I} :=
      from_iter (I := I);
  }.
End Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.
End Impl_core_iter_traits_collect_FromIterator_Tuple_K_V__for_serde_json_value_Value_t.

Module  Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
Section Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from((): ()) -> Self {
          Value::Null
      }
  *)
  Definition from (Pattern : unit) : M Self :=
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := unit) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.
End Impl_core_convert_From_Tuple__for_serde_json_value_Value_t.

Module  Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
Section Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
  Context {T : Set}.
  
  Context {ℋ_0 : core.convert.Into.Trait T (T := serde_json.value.Value.t)}.
  
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn from(opt: Option<T>) -> Self {
          match opt {
              None => Value::Null,
              Some(value) => Into::into(value),
          }
      }
  *)
  Definition from (opt : core.option.Option.t T) : M Self :=
    let* opt := M.alloc opt in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := core.option.Option.t T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.
End Impl_core_convert_From_core_option_Option_t_T_for_serde_json_value_Value_t.

Module index.
  Module  Index.
  Section Index.
    Class Trait (Self : Set) : Type := {
      ℒ_0 :: serde_json.value.index.private.Sealed.Trait Self;
      index_into :
        (ref Self) ->
          (ref serde_json.value.Value.t) ->
          M (core.option.Option.t (ref serde_json.value.Value.t));
      index_into_mut :
        (ref Self) ->
          (mut_ref serde_json.value.Value.t) ->
          M (core.option.Option.t (mut_ref serde_json.value.Value.t));
      index_or_insert :
        (ref Self) ->
          (mut_ref serde_json.value.Value.t) ->
          M (mut_ref serde_json.value.Value.t);
    }.
    
  End Index.
  End Index.
  
  Module  Impl_serde_json_value_index_Index_for_usize_t.
  Section Impl_serde_json_value_index_Index_for_usize_t.
    Definition Self : Set := usize.t.
    
    (*
        fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
            match v {
                Value::Array(vec) => vec.get( *self),
                _ => None,
            }
        }
    *)
    Definition index_into
        (self : ref Self)
        (v : ref serde_json.value.Value.t)
        : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_into :
      Notations.DoubleColon Self "index_into" := {
      Notations.double_colon := index_into;
    }.
    
    (*
        fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
            match v {
                Value::Array(vec) => vec.get_mut( *self),
                _ => None,
            }
        }
    *)
    Definition index_into_mut
        (self : ref Self)
        (v : mut_ref serde_json.value.Value.t)
        : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_into_mut :
      Notations.DoubleColon Self "index_into_mut" := {
      Notations.double_colon := index_into_mut;
    }.
    
    (*
        fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
            match v {
                Value::Array(vec) => {
                    let len = vec.len();
                    vec.get_mut( *self).unwrap_or_else(|| {
                        panic!(
                            "cannot access index {} of JSON array of length {}",
                            self, len
                        )
                    })
                }
                _ => panic!("cannot access index {} of JSON {}", self, Type(v)),
            }
        }
    *)
    Definition index_or_insert
        (self : ref Self)
        (v : mut_ref serde_json.value.Value.t)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_or_insert :
      Notations.DoubleColon Self "index_or_insert" := {
      Notations.double_colon := index_or_insert;
    }.
    
    Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
      serde_json.value.index.Index.index_into := index_into;
      serde_json.value.index.Index.index_into_mut := index_into_mut;
      serde_json.value.index.Index.index_or_insert := index_or_insert;
    }.
  End Impl_serde_json_value_index_Index_for_usize_t.
  End Impl_serde_json_value_index_Index_for_usize_t.
  
  Module  Impl_serde_json_value_index_Index_for_str_t.
  Section Impl_serde_json_value_index_Index_for_str_t.
    Definition Self : Set := str.t.
    
    (*
        fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
            match v {
                Value::Object(map) => map.get(self),
                _ => None,
            }
        }
    *)
    Definition index_into
        (self : ref Self)
        (v : ref serde_json.value.Value.t)
        : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_into :
      Notations.DoubleColon Self "index_into" := {
      Notations.double_colon := index_into;
    }.
    
    (*
        fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
            match v {
                Value::Object(map) => map.get_mut(self),
                _ => None,
            }
        }
    *)
    Definition index_into_mut
        (self : ref Self)
        (v : mut_ref serde_json.value.Value.t)
        : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_into_mut :
      Notations.DoubleColon Self "index_into_mut" := {
      Notations.double_colon := index_into_mut;
    }.
    
    (*
        fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
            if let Value::Null = v {
                *v = Value::Object(Map::new());
            }
            match v {
                Value::Object(map) => map.entry(self.to_owned()).or_insert(Value::Null),
                _ => panic!("cannot access key {:?} in JSON {}", self, Type(v)),
            }
        }
    *)
    Definition index_or_insert
        (self : ref Self)
        (v : mut_ref serde_json.value.Value.t)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_or_insert :
      Notations.DoubleColon Self "index_or_insert" := {
      Notations.double_colon := index_or_insert;
    }.
    
    Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
      serde_json.value.index.Index.index_into := index_into;
      serde_json.value.index.Index.index_into_mut := index_into_mut;
      serde_json.value.index.Index.index_or_insert := index_or_insert;
    }.
  End Impl_serde_json_value_index_Index_for_str_t.
  End Impl_serde_json_value_index_Index_for_str_t.
  
  Module  Impl_serde_json_value_index_Index_for_alloc_string_String_t.
  Section Impl_serde_json_value_index_Index_for_alloc_string_String_t.
    Definition Self : Set := alloc.string.String.t.
    
    (*
        fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
            self[..].index_into(v)
        }
    *)
    Definition index_into
        (self : ref Self)
        (v : ref serde_json.value.Value.t)
        : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_into :
      Notations.DoubleColon Self "index_into" := {
      Notations.double_colon := index_into;
    }.
    
    (*
        fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
            self[..].index_into_mut(v)
        }
    *)
    Definition index_into_mut
        (self : ref Self)
        (v : mut_ref serde_json.value.Value.t)
        : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_into_mut :
      Notations.DoubleColon Self "index_into_mut" := {
      Notations.double_colon := index_into_mut;
    }.
    
    (*
        fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
            self[..].index_or_insert(v)
        }
    *)
    Definition index_or_insert
        (self : ref Self)
        (v : mut_ref serde_json.value.Value.t)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_or_insert :
      Notations.DoubleColon Self "index_or_insert" := {
      Notations.double_colon := index_or_insert;
    }.
    
    Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
      serde_json.value.index.Index.index_into := index_into;
      serde_json.value.index.Index.index_into_mut := index_into_mut;
      serde_json.value.index.Index.index_or_insert := index_or_insert;
    }.
  End Impl_serde_json_value_index_Index_for_alloc_string_String_t.
  End Impl_serde_json_value_index_Index_for_alloc_string_String_t.
  
  Module  Impl_serde_json_value_index_Index_for_ref_T.
  Section Impl_serde_json_value_index_Index_for_ref_T.
    Context {T : Set}.
    
    Context {ℋ_0 : serde_json.value.index.Index.Trait T}.
    
    Definition Self : Set := ref T.
    
    (*
        fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
            ( **self).index_into(v)
        }
    *)
    Definition index_into
        (self : ref Self)
        (v : ref serde_json.value.Value.t)
        : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_into :
      Notations.DoubleColon Self "index_into" := {
      Notations.double_colon := index_into;
    }.
    
    (*
        fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
            ( **self).index_into_mut(v)
        }
    *)
    Definition index_into_mut
        (self : ref Self)
        (v : mut_ref serde_json.value.Value.t)
        : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_into_mut :
      Notations.DoubleColon Self "index_into_mut" := {
      Notations.double_colon := index_into_mut;
    }.
    
    (*
        fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
            ( **self).index_or_insert(v)
        }
    *)
    Definition index_or_insert
        (self : ref Self)
        (v : mut_ref serde_json.value.Value.t)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_index_or_insert :
      Notations.DoubleColon Self "index_or_insert" := {
      Notations.double_colon := index_or_insert;
    }.
    
    Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
      serde_json.value.index.Index.index_into := index_into;
      serde_json.value.index.Index.index_into_mut := index_into_mut;
      serde_json.value.index.Index.index_or_insert := index_or_insert;
    }.
  End Impl_serde_json_value_index_Index_for_ref_T.
  End Impl_serde_json_value_index_Index_for_ref_T.
  
  Module private.
    Module  Sealed.
    Section Sealed.
      Unset Primitive Projections.
      Class Trait (Self : Set) : Type := {
      }.
      Global Set Primitive Projections.
    End Sealed.
    End Sealed.
    
    Module  Impl_serde_json_value_index_private_Sealed_for_usize_t.
    Section Impl_serde_json_value_index_private_Sealed_for_usize_t.
      Definition Self : Set := usize.t.
      
      Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
      }.
    End Impl_serde_json_value_index_private_Sealed_for_usize_t.
    End Impl_serde_json_value_index_private_Sealed_for_usize_t.
    
    Module  Impl_serde_json_value_index_private_Sealed_for_str_t.
    Section Impl_serde_json_value_index_private_Sealed_for_str_t.
      Definition Self : Set := str.t.
      
      Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
      }.
    End Impl_serde_json_value_index_private_Sealed_for_str_t.
    End Impl_serde_json_value_index_private_Sealed_for_str_t.
    
    Module  Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
    Section Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
      Definition Self : Set := alloc.string.String.t.
      
      Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
      }.
    End Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
    End Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
    
    Module  Impl_serde_json_value_index_private_Sealed_for_ref_T.
    Section Impl_serde_json_value_index_private_Sealed_for_ref_T.
      Context {T : Set}.
      
      Context {ℋ_0 : serde_json.value.index.private.Sealed.Trait T}.
      
      Definition Self : Set := ref T.
      
      Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
      }.
    End Impl_serde_json_value_index_private_Sealed_for_ref_T.
    End Impl_serde_json_value_index_private_Sealed_for_ref_T.
  End private.
  
  Module  Type_.
  Section Type_.
    Record t : Set := {
      x0 : ref serde_json.value.Value.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Type_.
  End Type_.
  
  Module  Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
  Section Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
    Definition Self : Set := serde_json.value.index.Type_.t.
    
    (*
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match *self.0 {
                Value::Null => formatter.write_str("null"),
                Value::Bool(_) => formatter.write_str("boolean"),
                Value::Number(_) => formatter.write_str("number"),
                Value::String(_) => formatter.write_str("string"),
                Value::Array(_) => formatter.write_str("array"),
                Value::Object(_) => formatter.write_str("object"),
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (formatter : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* formatter := M.alloc formatter in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
  End Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
  
  Module  Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
  Section Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
    Context {I : Set}.
    
    Context {ℋ_0 : serde_json.value.index.Index.Trait I}.
    
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        type Output = Value;
    *)
    Definition Output : Set := serde_json.value.Value.t.
    
    (*
        fn index(&self, index: I) -> &Value {
            static NULL: Value = Value::Null;
            index.index_into(self).unwrap_or(&NULL)
        }
    *)
    Definition index
        (self : ref Self)
        (index : I)
        : M (ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* index := M.alloc index in
      M.read foo.
    
    Global Instance AssociatedFunction_index :
      Notations.DoubleColon Self "index" := {
      Notations.double_colon := index;
    }.
    
    Global Instance ℐ : core.ops.index.Index.Trait Self (Idx := I) := {
      core.ops.index.Index.Output := Output;
      core.ops.index.Index.index := index;
    }.
  End Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
  End Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
  
  Module  Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
  Section Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
    Context {I : Set}.
    
    Context {ℋ_0 : serde_json.value.index.Index.Trait I}.
    
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn index_mut(&mut self, index: I) -> &mut Value {
            index.index_or_insert(self)
        }
    *)
    Definition index_mut
        (self : mut_ref Self)
        (index : I)
        : M (mut_ref serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* index := M.alloc index in
      M.read foo.
    
    Global Instance AssociatedFunction_index_mut :
      Notations.DoubleColon Self "index_mut" := {
      Notations.double_colon := index_mut;
    }.
    
    Global Instance ℐ : core.ops.index.IndexMut.Trait Self (Idx := I) := {
      core.ops.index.IndexMut.index_mut := index_mut;
    }.
  End Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
  End Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
End index.

Module  Index.
Section Index.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: serde_json.value.index.private.Sealed.Trait Self;
    index_into :
      (ref Self) ->
        (ref serde_json.value.Value.t) ->
        M (core.option.Option.t (ref serde_json.value.Value.t));
    index_into_mut :
      (ref Self) ->
        (mut_ref serde_json.value.Value.t) ->
        M (core.option.Option.t (mut_ref serde_json.value.Value.t));
    index_or_insert :
      (ref Self) ->
        (mut_ref serde_json.value.Value.t) ->
        M (mut_ref serde_json.value.Value.t);
  }.
  
End Index.
End Index.

Module  Impl_serde_json_value_index_Index_for_usize_t.
Section Impl_serde_json_value_index_Index_for_usize_t.
  Definition Self : Set := usize.t.
  
  (*
      fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
          match v {
              Value::Array(vec) => vec.get( *self),
              _ => None,
          }
      }
  *)
  Definition index_into
      (self : ref Self)
      (v : ref serde_json.value.Value.t)
      : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_into :
    Notations.DoubleColon Self "index_into" := {
    Notations.double_colon := index_into;
  }.
  
  (*
      fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
          match v {
              Value::Array(vec) => vec.get_mut( *self),
              _ => None,
          }
      }
  *)
  Definition index_into_mut
      (self : ref Self)
      (v : mut_ref serde_json.value.Value.t)
      : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_into_mut :
    Notations.DoubleColon Self "index_into_mut" := {
    Notations.double_colon := index_into_mut;
  }.
  
  (*
      fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
          match v {
              Value::Array(vec) => {
                  let len = vec.len();
                  vec.get_mut( *self).unwrap_or_else(|| {
                      panic!(
                          "cannot access index {} of JSON array of length {}",
                          self, len
                      )
                  })
              }
              _ => panic!("cannot access index {} of JSON {}", self, Type(v)),
          }
      }
  *)
  Definition index_or_insert
      (self : ref Self)
      (v : mut_ref serde_json.value.Value.t)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_or_insert :
    Notations.DoubleColon Self "index_or_insert" := {
    Notations.double_colon := index_or_insert;
  }.
  
  Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
    serde_json.value.index.Index.index_into := index_into;
    serde_json.value.index.Index.index_into_mut := index_into_mut;
    serde_json.value.index.Index.index_or_insert := index_or_insert;
  }.
End Impl_serde_json_value_index_Index_for_usize_t.
End Impl_serde_json_value_index_Index_for_usize_t.

Module  Impl_serde_json_value_index_Index_for_str_t.
Section Impl_serde_json_value_index_Index_for_str_t.
  Definition Self : Set := str.t.
  
  (*
      fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
          match v {
              Value::Object(map) => map.get(self),
              _ => None,
          }
      }
  *)
  Definition index_into
      (self : ref Self)
      (v : ref serde_json.value.Value.t)
      : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_into :
    Notations.DoubleColon Self "index_into" := {
    Notations.double_colon := index_into;
  }.
  
  (*
      fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
          match v {
              Value::Object(map) => map.get_mut(self),
              _ => None,
          }
      }
  *)
  Definition index_into_mut
      (self : ref Self)
      (v : mut_ref serde_json.value.Value.t)
      : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_into_mut :
    Notations.DoubleColon Self "index_into_mut" := {
    Notations.double_colon := index_into_mut;
  }.
  
  (*
      fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
          if let Value::Null = v {
              *v = Value::Object(Map::new());
          }
          match v {
              Value::Object(map) => map.entry(self.to_owned()).or_insert(Value::Null),
              _ => panic!("cannot access key {:?} in JSON {}", self, Type(v)),
          }
      }
  *)
  Definition index_or_insert
      (self : ref Self)
      (v : mut_ref serde_json.value.Value.t)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_or_insert :
    Notations.DoubleColon Self "index_or_insert" := {
    Notations.double_colon := index_or_insert;
  }.
  
  Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
    serde_json.value.index.Index.index_into := index_into;
    serde_json.value.index.Index.index_into_mut := index_into_mut;
    serde_json.value.index.Index.index_or_insert := index_or_insert;
  }.
End Impl_serde_json_value_index_Index_for_str_t.
End Impl_serde_json_value_index_Index_for_str_t.

Module  Impl_serde_json_value_index_Index_for_alloc_string_String_t.
Section Impl_serde_json_value_index_Index_for_alloc_string_String_t.
  Definition Self : Set := alloc.string.String.t.
  
  (*
      fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
          self[..].index_into(v)
      }
  *)
  Definition index_into
      (self : ref Self)
      (v : ref serde_json.value.Value.t)
      : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_into :
    Notations.DoubleColon Self "index_into" := {
    Notations.double_colon := index_into;
  }.
  
  (*
      fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
          self[..].index_into_mut(v)
      }
  *)
  Definition index_into_mut
      (self : ref Self)
      (v : mut_ref serde_json.value.Value.t)
      : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_into_mut :
    Notations.DoubleColon Self "index_into_mut" := {
    Notations.double_colon := index_into_mut;
  }.
  
  (*
      fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
          self[..].index_or_insert(v)
      }
  *)
  Definition index_or_insert
      (self : ref Self)
      (v : mut_ref serde_json.value.Value.t)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_or_insert :
    Notations.DoubleColon Self "index_or_insert" := {
    Notations.double_colon := index_or_insert;
  }.
  
  Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
    serde_json.value.index.Index.index_into := index_into;
    serde_json.value.index.Index.index_into_mut := index_into_mut;
    serde_json.value.index.Index.index_or_insert := index_or_insert;
  }.
End Impl_serde_json_value_index_Index_for_alloc_string_String_t.
End Impl_serde_json_value_index_Index_for_alloc_string_String_t.

Module  Impl_serde_json_value_index_Index_for_ref_T.
Section Impl_serde_json_value_index_Index_for_ref_T.
  Context {T : Set}.
  
  Context {ℋ_0 : serde_json.value.index.Index.Trait T}.
  
  Definition Self : Set := ref T.
  
  (*
      fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {
          ( **self).index_into(v)
      }
  *)
  Definition index_into
      (self : ref Self)
      (v : ref serde_json.value.Value.t)
      : M (core.option.Option.t (ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_into :
    Notations.DoubleColon Self "index_into" := {
    Notations.double_colon := index_into;
  }.
  
  (*
      fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {
          ( **self).index_into_mut(v)
      }
  *)
  Definition index_into_mut
      (self : ref Self)
      (v : mut_ref serde_json.value.Value.t)
      : M (core.option.Option.t (mut_ref serde_json.value.Value.t)) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_into_mut :
    Notations.DoubleColon Self "index_into_mut" := {
    Notations.double_colon := index_into_mut;
  }.
  
  (*
      fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {
          ( **self).index_or_insert(v)
      }
  *)
  Definition index_or_insert
      (self : ref Self)
      (v : mut_ref serde_json.value.Value.t)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_index_or_insert :
    Notations.DoubleColon Self "index_or_insert" := {
    Notations.double_colon := index_or_insert;
  }.
  
  Global Instance ℐ : serde_json.value.index.Index.Trait Self := {
    serde_json.value.index.Index.index_into := index_into;
    serde_json.value.index.Index.index_into_mut := index_into_mut;
    serde_json.value.index.Index.index_or_insert := index_or_insert;
  }.
End Impl_serde_json_value_index_Index_for_ref_T.
End Impl_serde_json_value_index_Index_for_ref_T.

Module private.
  Module  Sealed.
  Section Sealed.
    Unset Primitive Projections.
    Class Trait (Self : Set) : Type := {
    }.
    Global Set Primitive Projections.
  End Sealed.
  End Sealed.
  
  Module  Impl_serde_json_value_index_private_Sealed_for_usize_t.
  Section Impl_serde_json_value_index_private_Sealed_for_usize_t.
    Definition Self : Set := usize.t.
    
    Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
    }.
  End Impl_serde_json_value_index_private_Sealed_for_usize_t.
  End Impl_serde_json_value_index_private_Sealed_for_usize_t.
  
  Module  Impl_serde_json_value_index_private_Sealed_for_str_t.
  Section Impl_serde_json_value_index_private_Sealed_for_str_t.
    Definition Self : Set := str.t.
    
    Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
    }.
  End Impl_serde_json_value_index_private_Sealed_for_str_t.
  End Impl_serde_json_value_index_private_Sealed_for_str_t.
  
  Module  Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
  Section Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
    Definition Self : Set := alloc.string.String.t.
    
    Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
    }.
  End Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
  End Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
  
  Module  Impl_serde_json_value_index_private_Sealed_for_ref_T.
  Section Impl_serde_json_value_index_private_Sealed_for_ref_T.
    Context {T : Set}.
    
    Context {ℋ_0 : serde_json.value.index.private.Sealed.Trait T}.
    
    Definition Self : Set := ref T.
    
    Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
    }.
  End Impl_serde_json_value_index_private_Sealed_for_ref_T.
  End Impl_serde_json_value_index_private_Sealed_for_ref_T.
End private.

Module  Sealed.
Section Sealed.
  Unset Primitive Projections.
  Class Trait (Self : Set) : Type := {
  }.
  Global Set Primitive Projections.
End Sealed.
End Sealed.

Module  Impl_serde_json_value_index_private_Sealed_for_usize_t.
Section Impl_serde_json_value_index_private_Sealed_for_usize_t.
  Definition Self : Set := usize.t.
  
  Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
  }.
End Impl_serde_json_value_index_private_Sealed_for_usize_t.
End Impl_serde_json_value_index_private_Sealed_for_usize_t.

Module  Impl_serde_json_value_index_private_Sealed_for_str_t.
Section Impl_serde_json_value_index_private_Sealed_for_str_t.
  Definition Self : Set := str.t.
  
  Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
  }.
End Impl_serde_json_value_index_private_Sealed_for_str_t.
End Impl_serde_json_value_index_private_Sealed_for_str_t.

Module  Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
Section Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
  Definition Self : Set := alloc.string.String.t.
  
  Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
  }.
End Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.
End Impl_serde_json_value_index_private_Sealed_for_alloc_string_String_t.

Module  Impl_serde_json_value_index_private_Sealed_for_ref_T.
Section Impl_serde_json_value_index_private_Sealed_for_ref_T.
  Context {T : Set}.
  
  Context {ℋ_0 : serde_json.value.index.private.Sealed.Trait T}.
  
  Definition Self : Set := ref T.
  
  Global Instance ℐ : serde_json.value.index.private.Sealed.Trait Self := {
  }.
End Impl_serde_json_value_index_private_Sealed_for_ref_T.
End Impl_serde_json_value_index_private_Sealed_for_ref_T.

Module  Type_.
Section Type_.
  Record t : Set := {
    x0 : ref serde_json.value.Value.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Type_.
End Type_.

Module  Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
Section Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
  Definition Self : Set := serde_json.value.index.Type_.t.
  
  (*
      fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
          match *self.0 {
              Value::Null => formatter.write_str("null"),
              Value::Bool(_) => formatter.write_str("boolean"),
              Value::Number(_) => formatter.write_str("number"),
              Value::String(_) => formatter.write_str("string"),
              Value::Array(_) => formatter.write_str("array"),
              Value::Object(_) => formatter.write_str("object"),
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_serde_json_value_index_Type__t.
End Impl_core_fmt_Display_for_serde_json_value_index_Type__t.

Module  Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
Section Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
  Context {I : Set}.
  
  Context {ℋ_0 : serde_json.value.index.Index.Trait I}.
  
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      type Output = Value;
  *)
  Definition Output : Set := serde_json.value.Value.t.
  
  (*
      fn index(&self, index: I) -> &Value {
          static NULL: Value = Value::Null;
          index.index_into(self).unwrap_or(&NULL)
      }
  *)
  Definition index
      (self : ref Self)
      (index : I)
      : M (ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* index := M.alloc index in
    M.read foo.
  
  Global Instance AssociatedFunction_index :
    Notations.DoubleColon Self "index" := {
    Notations.double_colon := index;
  }.
  
  Global Instance ℐ : core.ops.index.Index.Trait Self (Idx := I) := {
    core.ops.index.Index.Output := Output;
    core.ops.index.Index.index := index;
  }.
End Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.
End Impl_core_ops_index_Index_I_for_serde_json_value_Value_t.

Definition NULL : M.Val (ref serde_json.value.Value.t) := M.run (M.alloc foo).

Module  Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
Section Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
  Context {I : Set}.
  
  Context {ℋ_0 : serde_json.value.index.Index.Trait I}.
  
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn index_mut(&mut self, index: I) -> &mut Value {
          index.index_or_insert(self)
      }
  *)
  Definition index_mut
      (self : mut_ref Self)
      (index : I)
      : M (mut_ref serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* index := M.alloc index in
    M.read foo.
  
  Global Instance AssociatedFunction_index_mut :
    Notations.DoubleColon Self "index_mut" := {
    Notations.double_colon := index_mut;
  }.
  
  Global Instance ℐ : core.ops.index.IndexMut.Trait Self (Idx := I) := {
    core.ops.index.IndexMut.index_mut := index_mut;
  }.
End Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.
End Impl_core_ops_index_IndexMut_I_for_serde_json_value_Value_t.

Module partial_eq.
  (*
  fn eq_i64(value: &Value, other: i64) -> bool {
      value.as_i64().map_or(false, |i| i == other)
  }
  *)
  Definition eq_i64
      (value : ref serde_json.value.Value.t)
      (other : i64.t)
      : M bool.t :=
    let* value := M.alloc value in
    let* other := M.alloc other in
    M.read foo.
  
  (*
  fn eq_u64(value: &Value, other: u64) -> bool {
      value.as_u64().map_or(false, |i| i == other)
  }
  *)
  Definition eq_u64
      (value : ref serde_json.value.Value.t)
      (other : u64.t)
      : M bool.t :=
    let* value := M.alloc value in
    let* other := M.alloc other in
    M.read foo.
  
  (*
  fn eq_f32(value: &Value, other: f32) -> bool {
      match value {
          Value::Number(n) => n.as_f32().map_or(false, |i| i == other),
          _ => false,
      }
  }
  *)
  Definition eq_f32
      (value : ref serde_json.value.Value.t)
      (other : f32.t)
      : M bool.t :=
    let* value := M.alloc value in
    let* other := M.alloc other in
    M.read foo.
  
  (*
  fn eq_f64(value: &Value, other: f64) -> bool {
      value.as_f64().map_or(false, |i| i == other)
  }
  *)
  Definition eq_f64
      (value : ref serde_json.value.Value.t)
      (other : f64.t)
      : M bool.t :=
    let* value := M.alloc value in
    let* other := M.alloc other in
    M.read foo.
  
  (*
  fn eq_bool(value: &Value, other: bool) -> bool {
      value.as_bool().map_or(false, |i| i == other)
  }
  *)
  Definition eq_bool
      (value : ref serde_json.value.Value.t)
      (other : bool.t)
      : M bool.t :=
    let* value := M.alloc value in
    let* other := M.alloc other in
    M.read foo.
  
  (*
  fn eq_str(value: &Value, other: &str) -> bool {
      value.as_str().map_or(false, |i| i == other)
  }
  *)
  Definition eq_str
      (value : ref serde_json.value.Value.t)
      (other : ref str.t)
      : M bool.t :=
    let* value := M.alloc value in
    let* other := M.alloc other in
    M.read foo.
  
  Module  Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn eq(&self, other: &str) -> bool {
            eq_str(self, other)
        }
    *)
    Definition eq (self : ref Self) (other : ref str.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := str.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn eq(&self, other: &&str) -> bool {
            eq_str(self, *other)
        }
    *)
    Definition eq (self : ref Self) (other : ref (ref str.t)) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := ref str.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
    Definition Self : Set := str.t.
    
    (*
        fn eq(&self, other: &Value) -> bool {
            eq_str(other, self)
        }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
    Definition Self : Set := ref str.t.
    
    (*
        fn eq(&self, other: &Value) -> bool {
            eq_str(other, *self)
        }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
  
  Module  Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn eq(&self, other: &String) -> bool {
            eq_str(self, other.as_str())
        }
    *)
    Definition eq
        (self : ref Self)
        (other : ref alloc.string.String.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := alloc.string.String.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
    Definition Self : Set := alloc.string.String.t.
    
    (*
        fn eq(&self, other: &Value) -> bool {
            eq_str(other, self.as_str())
        }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
  
  Module  Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
    Definition Self : Set := i8.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
  
  Module  Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
    Definition Self : Set := i16.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
  
  Module  Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
    Definition Self : Set := i32.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
  
  Module  Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
    Definition Self : Set := i64.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
  
  Module  Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
    Definition Self : Set := isize.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
  
  Module  Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
    Definition Self : Set := u8.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
  
  Module  Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
    Definition Self : Set := u16.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
  
  Module  Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
    Definition Self : Set := u32.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
  
  Module  Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
    Definition Self : Set := u64.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
  
  Module  Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
    Definition Self : Set := usize.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
  
  Module  Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
    Definition Self : Set := f32.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
  
  Module  Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
    Definition Self : Set := f64.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
  
  Module  Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq(self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
  Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
    Definition Self : Set := bool.t.
    
    (*
                    fn eq(&self, other: &Value) -> bool {
                        $eq(other, *self as _)
                    }
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.value.Value.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := serde_json.value.Value.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
  End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
  
  Module  Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
    Definition Self : Set := ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
  
  Module  Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
  Section Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
    Definition Self : Set := mut_ref serde_json.value.Value.t.
    
    (*
                    fn eq(&self, other: &$ty) -> bool {
                        $eq( *self, *other as _)
                    }
    *)
    Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
  End Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
End partial_eq.

(*
fn eq_i64(value: &Value, other: i64) -> bool {
    value.as_i64().map_or(false, |i| i == other)
}
*)
Definition eq_i64
    (value : ref serde_json.value.Value.t)
    (other : i64.t)
    : M bool.t :=
  let* value := M.alloc value in
  let* other := M.alloc other in
  M.read foo.

(*
fn eq_u64(value: &Value, other: u64) -> bool {
    value.as_u64().map_or(false, |i| i == other)
}
*)
Definition eq_u64
    (value : ref serde_json.value.Value.t)
    (other : u64.t)
    : M bool.t :=
  let* value := M.alloc value in
  let* other := M.alloc other in
  M.read foo.

(*
fn eq_f32(value: &Value, other: f32) -> bool {
    match value {
        Value::Number(n) => n.as_f32().map_or(false, |i| i == other),
        _ => false,
    }
}
*)
Definition eq_f32
    (value : ref serde_json.value.Value.t)
    (other : f32.t)
    : M bool.t :=
  let* value := M.alloc value in
  let* other := M.alloc other in
  M.read foo.

(*
fn eq_f64(value: &Value, other: f64) -> bool {
    value.as_f64().map_or(false, |i| i == other)
}
*)
Definition eq_f64
    (value : ref serde_json.value.Value.t)
    (other : f64.t)
    : M bool.t :=
  let* value := M.alloc value in
  let* other := M.alloc other in
  M.read foo.

(*
fn eq_bool(value: &Value, other: bool) -> bool {
    value.as_bool().map_or(false, |i| i == other)
}
*)
Definition eq_bool
    (value : ref serde_json.value.Value.t)
    (other : bool.t)
    : M bool.t :=
  let* value := M.alloc value in
  let* other := M.alloc other in
  M.read foo.

(*
fn eq_str(value: &Value, other: &str) -> bool {
    value.as_str().map_or(false, |i| i == other)
}
*)
Definition eq_str
    (value : ref serde_json.value.Value.t)
    (other : ref str.t)
    : M bool.t :=
  let* value := M.alloc value in
  let* other := M.alloc other in
  M.read foo.

Module  Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn eq(&self, other: &str) -> bool {
          eq_str(self, other)
      }
  *)
  Definition eq (self : ref Self) (other : ref str.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := str.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_str_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn eq(&self, other: &&str) -> bool {
          eq_str(self, *other)
      }
  *)
  Definition eq (self : ref Self) (other : ref (ref str.t)) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := ref str.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_ref_str_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
  Definition Self : Set := str.t.
  
  (*
      fn eq(&self, other: &Value) -> bool {
          eq_str(other, self)
      }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_str_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
  Definition Self : Set := ref str.t.
  
  (*
      fn eq(&self, other: &Value) -> bool {
          eq_str(other, *self)
      }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_ref_str_t.

Module  Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn eq(&self, other: &String) -> bool {
          eq_str(self, other.as_str())
      }
  *)
  Definition eq
      (self : ref Self)
      (other : ref alloc.string.String.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := alloc.string.String.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_alloc_string_String_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
  Definition Self : Set := alloc.string.String.t.
  
  (*
      fn eq(&self, other: &Value) -> bool {
          eq_str(other, self.as_str())
      }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_alloc_string_String_t.

Module  Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i8_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
  Definition Self : Set := i8.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i8_t.

Module  Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i8_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i8.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i8.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i8_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i16_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
  Definition Self : Set := i16.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i16_t.

Module  Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i16_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i16.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i16.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i16_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i32_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
  Definition Self : Set := i32.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i32_t.

Module  Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i32_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i32_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i64_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
  Definition Self : Set := i64.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_i64_t.

Module  Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i64_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref i64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := i64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_i64_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_isize_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
  Definition Self : Set := isize.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_isize_t.

Module  Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_isize_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref isize.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := isize.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_isize_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u8_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
  Definition Self : Set := u8.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u8_t.

Module  Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u8_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u8.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u8.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u8_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u16_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
  Definition Self : Set := u16.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u16_t.

Module  Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u16_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u16.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u16.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u16_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u32_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
  Definition Self : Set := u32.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u32_t.

Module  Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u32_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u32_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u64_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
  Definition Self : Set := u64.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_u64_t.

Module  Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u64_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref u64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := u64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_u64_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_usize_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
  Definition Self : Set := usize.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_usize_t.

Module  Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_usize_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref usize.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := usize.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_usize_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_f32_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
  Definition Self : Set := f32.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f32_t.

Module  Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_f32_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref f32.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := f32.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_f32_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_f64_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
  Definition Self : Set := f64.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_f64_t.

Module  Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_f64_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref f64.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ : core.cmp.PartialEq.Required.Trait Self (Rhs := f64.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_f64_t_for_mut_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq(self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_bool_t_for_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
Section Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
  Definition Self : Set := bool.t.
  
  (*
                  fn eq(&self, other: &Value) -> bool {
                      $eq(other, *self as _)
                  }
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.value.Value.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := serde_json.value.Value.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.
End Impl_core_cmp_PartialEq_serde_json_value_Value_t_for_bool_t.

Module  Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
  Definition Self : Set := ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_bool_t_for_ref_serde_json_value_Value_t.

Module  Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
Section Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
  Definition Self : Set := mut_ref serde_json.value.Value.t.
  
  (*
                  fn eq(&self, other: &$ty) -> bool {
                      $eq( *self, *other as _)
                  }
  *)
  Definition eq (self : ref Self) (other : ref bool.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self (Rhs := bool.t) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.
End Impl_core_cmp_PartialEq_bool_t_for_mut_ref_serde_json_value_Value_t.

Module Wrap_ser_1.
Module ser.
  Module  Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
  Section Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
    Definition Self : Set := serde_json.value.Value.t.
    
    (*
        fn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            match self {
                Value::Null => serializer.serialize_unit(),
                Value::Bool(b) => serializer.serialize_bool( *b),
                Value::Number(n) => n.serialize(serializer),
                Value::String(s) => serializer.serialize_str(s),
                Value::Array(v) => v.serialize(serializer),
                #[cfg(any(feature = "std", feature = "alloc"))]
                Value::Object(m) => {
                    use serde::ser::SerializeMap;
                    let mut map = tri!(serializer.serialize_map(Some(m.len())));
                    for (k, v) in m {
                        tri!(map.serialize_entry(k, v));
                    }
                    map.end()
                }
            }
        }
    *)
    Definition serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S}
        (self : ref Self)
        (serializer : S)
        : M (core.result.Result.t S::type["Ok"].t S::type["Error"].t) :=
      let* self := M.alloc self in
      let* serializer := M.alloc serializer in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S} :
      Notations.DoubleColon Self "serialize" := {
      Notations.double_colon := serialize (S := S);
    }.
    
    Global Instance ℐ : serde.ser.Serialize.Trait Self := {
      serde.ser.Serialize.serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S} :=
        serialize (S := S);
    }.
  End Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
  End Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
  
  Module  Serializer.
  Section Serializer.
    Inductive t : Set := Build.
  End Serializer.
  End Serializer.
  
  Module  Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
  Section Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
    Definition Self : Set := serde_json.value.ser.Serializer.t.
    
    (*
        type Ok = Value;
    *)
    Definition Ok : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        type SerializeSeq = SerializeVec;
    *)
    Definition SerializeSeq : Set := serde_json.value.ser.SerializeVec.t.
    
    (*
        type SerializeTuple = SerializeVec;
    *)
    Definition SerializeTuple : Set := serde_json.value.ser.SerializeVec.t.
    
    (*
        type SerializeTupleStruct = SerializeVec;
    *)
    Definition SerializeTupleStruct : Set :=
      serde_json.value.ser.SerializeVec.t.
    
    (*
        type SerializeTupleVariant = SerializeTupleVariant;
    *)
    Definition SerializeTupleVariant : Set :=
      serde_json.value.ser.SerializeTupleVariant.t.
    
    (*
        type SerializeMap = SerializeMap;
    *)
    Definition SerializeMap : Set := serde_json.value.ser.SerializeMap.t.
    
    (*
        type SerializeStruct = SerializeMap;
    *)
    Definition SerializeStruct : Set := serde_json.value.ser.SerializeMap.t.
    
    (*
        type SerializeStructVariant = SerializeStructVariant;
    *)
    Definition SerializeStructVariant : Set :=
      serde_json.value.ser.SerializeStructVariant.t.
    
    (*
        fn serialize_bool(self, value: bool) -> Result<Value> {
            Ok(Value::Bool(value))
        }
    *)
    Definition serialize_bool
        (self : Self)
        (value : bool.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_bool :
      Notations.DoubleColon Self "serialize_bool" := {
      Notations.double_colon := serialize_bool;
    }.
    
    (*
        fn serialize_i8(self, value: i8) -> Result<Value> {
            self.serialize_i64(value as i64)
        }
    *)
    Definition serialize_i8
        (self : Self)
        (value : i8.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i8 :
      Notations.DoubleColon Self "serialize_i8" := {
      Notations.double_colon := serialize_i8;
    }.
    
    (*
        fn serialize_i16(self, value: i16) -> Result<Value> {
            self.serialize_i64(value as i64)
        }
    *)
    Definition serialize_i16
        (self : Self)
        (value : i16.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i16 :
      Notations.DoubleColon Self "serialize_i16" := {
      Notations.double_colon := serialize_i16;
    }.
    
    (*
        fn serialize_i32(self, value: i32) -> Result<Value> {
            self.serialize_i64(value as i64)
        }
    *)
    Definition serialize_i32
        (self : Self)
        (value : i32.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i32 :
      Notations.DoubleColon Self "serialize_i32" := {
      Notations.double_colon := serialize_i32;
    }.
    
    (*
        fn serialize_i64(self, value: i64) -> Result<Value> {
            Ok(Value::Number(value.into()))
        }
    *)
    Definition serialize_i64
        (self : Self)
        (value : i64.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i64 :
      Notations.DoubleColon Self "serialize_i64" := {
      Notations.double_colon := serialize_i64;
    }.
    
    (*
        fn serialize_i128(self, value: i128) -> Result<Value> {
            #[cfg(feature = "arbitrary_precision")]
            {
                Ok(Value::Number(value.into()))
            }
    
            #[cfg(not(feature = "arbitrary_precision"))]
            {
                if let Ok(value) = u64::try_from(value) {
                    Ok(Value::Number(value.into()))
                } else if let Ok(value) = i64::try_from(value) {
                    Ok(Value::Number(value.into()))
                } else {
                    Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))
                }
            }
        }
    *)
    Definition serialize_i128
        (self : Self)
        (value : i128.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i128 :
      Notations.DoubleColon Self "serialize_i128" := {
      Notations.double_colon := serialize_i128;
    }.
    
    (*
        fn serialize_u8(self, value: u8) -> Result<Value> {
            self.serialize_u64(value as u64)
        }
    *)
    Definition serialize_u8
        (self : Self)
        (value : u8.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u8 :
      Notations.DoubleColon Self "serialize_u8" := {
      Notations.double_colon := serialize_u8;
    }.
    
    (*
        fn serialize_u16(self, value: u16) -> Result<Value> {
            self.serialize_u64(value as u64)
        }
    *)
    Definition serialize_u16
        (self : Self)
        (value : u16.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u16 :
      Notations.DoubleColon Self "serialize_u16" := {
      Notations.double_colon := serialize_u16;
    }.
    
    (*
        fn serialize_u32(self, value: u32) -> Result<Value> {
            self.serialize_u64(value as u64)
        }
    *)
    Definition serialize_u32
        (self : Self)
        (value : u32.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u32 :
      Notations.DoubleColon Self "serialize_u32" := {
      Notations.double_colon := serialize_u32;
    }.
    
    (*
        fn serialize_u64(self, value: u64) -> Result<Value> {
            Ok(Value::Number(value.into()))
        }
    *)
    Definition serialize_u64
        (self : Self)
        (value : u64.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u64 :
      Notations.DoubleColon Self "serialize_u64" := {
      Notations.double_colon := serialize_u64;
    }.
    
    (*
        fn serialize_u128(self, value: u128) -> Result<Value> {
            #[cfg(feature = "arbitrary_precision")]
            {
                Ok(Value::Number(value.into()))
            }
    
            #[cfg(not(feature = "arbitrary_precision"))]
            {
                if let Ok(value) = u64::try_from(value) {
                    Ok(Value::Number(value.into()))
                } else {
                    Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))
                }
            }
        }
    *)
    Definition serialize_u128
        (self : Self)
        (value : u128.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u128 :
      Notations.DoubleColon Self "serialize_u128" := {
      Notations.double_colon := serialize_u128;
    }.
    
    (*
        fn serialize_f32(self, float: f32) -> Result<Value> {
            Ok(Value::from(float))
        }
    *)
    Definition serialize_f32
        (self : Self)
        (float : f32.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* float := M.alloc float in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_f32 :
      Notations.DoubleColon Self "serialize_f32" := {
      Notations.double_colon := serialize_f32;
    }.
    
    (*
        fn serialize_f64(self, float: f64) -> Result<Value> {
            Ok(Value::from(float))
        }
    *)
    Definition serialize_f64
        (self : Self)
        (float : f64.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* float := M.alloc float in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_f64 :
      Notations.DoubleColon Self "serialize_f64" := {
      Notations.double_colon := serialize_f64;
    }.
    
    (*
        fn serialize_char(self, value: char) -> Result<Value> {
            let mut s = String::new();
            s.push(value);
            Ok(Value::String(s))
        }
    *)
    Definition serialize_char
        (self : Self)
        (value : char.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_char :
      Notations.DoubleColon Self "serialize_char" := {
      Notations.double_colon := serialize_char;
    }.
    
    (*
        fn serialize_str(self, value: &str) -> Result<Value> {
            Ok(Value::String(value.to_owned()))
        }
    *)
    Definition serialize_str
        (self : Self)
        (value : ref str.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_str :
      Notations.DoubleColon Self "serialize_str" := {
      Notations.double_colon := serialize_str;
    }.
    
    (*
        fn serialize_bytes(self, value: &[u8]) -> Result<Value> {
            let vec = value.iter().map(|&b| Value::Number(b.into())).collect();
            Ok(Value::Array(vec))
        }
    *)
    Definition serialize_bytes
        (self : Self)
        (value : ref (slice u8.t))
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_bytes :
      Notations.DoubleColon Self "serialize_bytes" := {
      Notations.double_colon := serialize_bytes;
    }.
    
    (*
        fn serialize_unit(self) -> Result<Value> {
            Ok(Value::Null)
        }
    *)
    Definition serialize_unit
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit :
      Notations.DoubleColon Self "serialize_unit" := {
      Notations.double_colon := serialize_unit;
    }.
    
    (*
        fn serialize_unit_struct(self, _name: &'static str) -> Result<Value> {
            self.serialize_unit()
        }
    *)
    Definition serialize_unit_struct
        (self : Self)
        (_name : ref str.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit_struct :
      Notations.DoubleColon Self "serialize_unit_struct" := {
      Notations.double_colon := serialize_unit_struct;
    }.
    
    (*
        fn serialize_unit_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
        ) -> Result<Value> {
            self.serialize_str(variant)
        }
    *)
    Definition serialize_unit_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit_variant :
      Notations.DoubleColon Self "serialize_unit_variant" := {
      Notations.double_colon := serialize_unit_variant;
    }.
    
    (*
        fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<Value>
        where
            T: ?Sized + Serialize,
        {
            value.serialize(self)
        }
    *)
    Definition serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_name : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_newtype_struct" := {
      Notations.double_colon := serialize_newtype_struct (T := T);
    }.
    
    (*
        fn serialize_newtype_variant<T>(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
            value: &T,
        ) -> Result<Value>
        where
            T: ?Sized + Serialize,
        {
            let mut values = Map::new();
            values.insert(String::from(variant), tri!(to_value(value)));
            Ok(Value::Object(values))
        }
    *)
    Definition serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_newtype_variant" := {
      Notations.double_colon := serialize_newtype_variant (T := T);
    }.
    
    (*
        fn serialize_none(self) -> Result<Value> {
            self.serialize_unit()
        }
    *)
    Definition serialize_none
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_none :
      Notations.DoubleColon Self "serialize_none" := {
      Notations.double_colon := serialize_none;
    }.
    
    (*
        fn serialize_some<T>(self, value: &T) -> Result<Value>
        where
            T: ?Sized + Serialize,
        {
            value.serialize(self)
        }
    *)
    Definition serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_some" := {
      Notations.double_colon := serialize_some (T := T);
    }.
    
    (*
        fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {
            Ok(SerializeVec {
                vec: Vec::with_capacity(len.unwrap_or(0)),
            })
        }
    *)
    Definition serialize_seq
        (self : Self)
        (len : core.option.Option.t usize.t)
        : M ltac:(serde_json.error.Result SerializeSeq) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_seq :
      Notations.DoubleColon Self "serialize_seq" := {
      Notations.double_colon := serialize_seq;
    }.
    
    (*
        fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {
            self.serialize_seq(Some(len))
        }
    *)
    Definition serialize_tuple
        (self : Self)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTuple) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple :
      Notations.DoubleColon Self "serialize_tuple" := {
      Notations.double_colon := serialize_tuple;
    }.
    
    (*
        fn serialize_tuple_struct(
            self,
            _name: &'static str,
            len: usize,
        ) -> Result<Self::SerializeTupleStruct> {
            self.serialize_seq(Some(len))
        }
    *)
    Definition serialize_tuple_struct
        (self : Self)
        (_name : ref str.t)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple_struct :
      Notations.DoubleColon Self "serialize_tuple_struct" := {
      Notations.double_colon := serialize_tuple_struct;
    }.
    
    (*
        fn serialize_tuple_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
            len: usize,
        ) -> Result<Self::SerializeTupleVariant> {
            Ok(SerializeTupleVariant {
                name: String::from(variant),
                vec: Vec::with_capacity(len),
            })
        }
    *)
    Definition serialize_tuple_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple_variant :
      Notations.DoubleColon Self "serialize_tuple_variant" := {
      Notations.double_colon := serialize_tuple_variant;
    }.
    
    (*
        fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {
            Ok(SerializeMap::Map {
                map: Map::new(),
                next_key: None,
            })
        }
    *)
    Definition serialize_map
        (self : Self)
        (_len : core.option.Option.t usize.t)
        : M ltac:(serde_json.error.Result SerializeMap) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_map :
      Notations.DoubleColon Self "serialize_map" := {
      Notations.double_colon := serialize_map;
    }.
    
    (*
        fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct> {
            match name {
                #[cfg(feature = "arbitrary_precision")]
                crate::number::TOKEN => Ok(SerializeMap::Number { out_value: None }),
                #[cfg(feature = "raw_value")]
                crate::raw::TOKEN => Ok(SerializeMap::RawValue { out_value: None }),
                _ => self.serialize_map(Some(len)),
            }
        }
    *)
    Definition serialize_struct
        (self : Self)
        (name : ref str.t)
        (len : usize.t)
        : M ltac:(serde_json.error.Result SerializeStruct) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* len := M.alloc len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_struct :
      Notations.DoubleColon Self "serialize_struct" := {
      Notations.double_colon := serialize_struct;
    }.
    
    (*
        fn serialize_struct_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeStructVariant> {
            Ok(SerializeStructVariant {
                name: String::from(variant),
                map: Map::new(),
            })
        }
    *)
    Definition serialize_struct_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeStructVariant) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_struct_variant :
      Notations.DoubleColon Self "serialize_struct_variant" := {
      Notations.double_colon := serialize_struct_variant;
    }.
    
    (*
        fn collect_str<T>(self, value: &T) -> Result<Value>
        where
            T: ?Sized + Display,
        {
            Ok(Value::String(value.to_string()))
        }
    *)
    Definition collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T}
        (self : Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :
      Notations.DoubleColon Self "collect_str" := {
      Notations.double_colon := collect_str (T := T);
    }.
    
    Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
      serde.ser.Serializer.Ok := Ok;
      serde.ser.Serializer.Error := Error;
      serde.ser.Serializer.SerializeSeq := SerializeSeq;
      serde.ser.Serializer.SerializeTuple := SerializeTuple;
      serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
      serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
      serde.ser.Serializer.SerializeMap := SerializeMap;
      serde.ser.Serializer.SerializeStruct := SerializeStruct;
      serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
      serde.ser.Serializer.serialize_bool := serialize_bool;
      serde.ser.Serializer.serialize_i8 := serialize_i8;
      serde.ser.Serializer.serialize_i16 := serialize_i16;
      serde.ser.Serializer.serialize_i32 := serialize_i32;
      serde.ser.Serializer.serialize_i64 := serialize_i64;
      serde.ser.Serializer.serialize_i128 := Datatypes.Some serialize_i128;
      serde.ser.Serializer.serialize_u8 := serialize_u8;
      serde.ser.Serializer.serialize_u16 := serialize_u16;
      serde.ser.Serializer.serialize_u32 := serialize_u32;
      serde.ser.Serializer.serialize_u64 := serialize_u64;
      serde.ser.Serializer.serialize_u128 := Datatypes.Some serialize_u128;
      serde.ser.Serializer.serialize_f32 := serialize_f32;
      serde.ser.Serializer.serialize_f64 := serialize_f64;
      serde.ser.Serializer.serialize_char := serialize_char;
      serde.ser.Serializer.serialize_str := serialize_str;
      serde.ser.Serializer.serialize_bytes := serialize_bytes;
      serde.ser.Serializer.serialize_unit := serialize_unit;
      serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
      serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
      serde.ser.Serializer.serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_newtype_struct (T := T);
      serde.ser.Serializer.serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_newtype_variant (T := T);
      serde.ser.Serializer.serialize_none := serialize_none;
      serde.ser.Serializer.serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_some (T := T);
      serde.ser.Serializer.serialize_seq := serialize_seq;
      serde.ser.Serializer.serialize_tuple := serialize_tuple;
      serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
      serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
      serde.ser.Serializer.serialize_map := serialize_map;
      serde.ser.Serializer.serialize_struct := serialize_struct;
      serde.ser.Serializer.serialize_struct_variant := serialize_struct_variant;
      serde.ser.Serializer.collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :=
        Datatypes.Some (collect_str (T := T));
      serde.ser.Serializer.collect_seq := Datatypes.None;
      serde.ser.Serializer.collect_map := Datatypes.None;
      serde.ser.Serializer.is_human_readable := Datatypes.None;
    }.
  End Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
  End Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
  
  Module  SerializeVec.
  Section SerializeVec.
    Record t : Set := {
      vec : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A;
    }.
    
    Definition Get_vec :=
      Ref.map (fun α => Some α.(vec)) (fun β α => Some (α <| vec := β |>)).
  End SerializeVec.
  End SerializeVec.
  
  Module  SerializeTupleVariant.
  Section SerializeTupleVariant.
    Record t : Set := {
      name : alloc.string.String.t;
      vec : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A;
    }.
    
    Definition Get_name :=
      Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
    Definition Get_vec :=
      Ref.map (fun α => Some α.(vec)) (fun β α => Some (α <| vec := β |>)).
  End SerializeTupleVariant.
  End SerializeTupleVariant.
  
  Module SerializeMap.
    Module Map.
      Record t : Set := {
        map :
          serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t;
        next_key : core.option.Option.t alloc.string.String.t;
      }.
    End Map.
    
    Inductive t : Set :=
    | Map (_ : Map.t).
    
    Definition Get_Map_map :=
      Ref.map
        (fun α => match α with | Map α => Some α.(Map.map) end)
        (fun β α =>
          match α with | Map α => Some (Map (α <| Map.map := β |>)) end).
    
    Definition Get_Map_next_key :=
      Ref.map
        (fun α => match α with | Map α => Some α.(Map.next_key) end)
        (fun β α =>
          match α with | Map α => Some (Map (α <| Map.next_key := β |>)) end).
  End SerializeMap.
  
  Module  SerializeStructVariant.
  Section SerializeStructVariant.
    Record t : Set := {
      name : alloc.string.String.t;
      map : serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t;
    }.
    
    Definition Get_name :=
      Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
    Definition Get_map :=
      Ref.map (fun α => Some α.(map)) (fun β α => Some (α <| map := β |>)).
  End SerializeStructVariant.
  End SerializeStructVariant.
  
  Module  Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
  Section Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
    Definition Self : Set := serde_json.value.ser.SerializeVec.t.
    
    (*
        type Ok = Value;
    *)
    Definition Ok : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_element<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            self.vec.push(tri!(to_value(value)));
            Ok(())
        }
    *)
    Definition serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_element" := {
      Notations.double_colon := serialize_element (T := T);
    }.
    
    (*
        fn end(self) -> Result<Value> {
            Ok(Value::Array(self.vec))
        }
    *)
    Definition end_
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeSeq.Trait Self := {
      serde.ser.SerializeSeq.Ok := Ok;
      serde.ser.SerializeSeq.Error := Error;
      serde.ser.SerializeSeq.serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_element (T := T);
      serde.ser.SerializeSeq.end_ := end_;
    }.
  End Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
  End Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
  
  Module  Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
  Section Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
    Definition Self : Set := serde_json.value.ser.SerializeVec.t.
    
    (*
        type Ok = Value;
    *)
    Definition Ok : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_element<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            serde::ser::SerializeSeq::serialize_element(self, value)
        }
    *)
    Definition serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_element" := {
      Notations.double_colon := serialize_element (T := T);
    }.
    
    (*
        fn end(self) -> Result<Value> {
            serde::ser::SerializeSeq::end(self)
        }
    *)
    Definition end_
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeTuple.Trait Self := {
      serde.ser.SerializeTuple.Ok := Ok;
      serde.ser.SerializeTuple.Error := Error;
      serde.ser.SerializeTuple.serialize_element
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_element (T := T);
      serde.ser.SerializeTuple.end_ := end_;
    }.
  End Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
  End Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
  
  Module  Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
  Section Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
    Definition Self : Set := serde_json.value.ser.SerializeVec.t.
    
    (*
        type Ok = Value;
    *)
    Definition Ok : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_field<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            serde::ser::SerializeSeq::serialize_element(self, value)
        }
    *)
    Definition serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_field" := {
      Notations.double_colon := serialize_field (T := T);
    }.
    
    (*
        fn end(self) -> Result<Value> {
            serde::ser::SerializeSeq::end(self)
        }
    *)
    Definition end_
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeTupleStruct.Trait Self := {
      serde.ser.SerializeTupleStruct.Ok := Ok;
      serde.ser.SerializeTupleStruct.Error := Error;
      serde.ser.SerializeTupleStruct.serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_field (T := T);
      serde.ser.SerializeTupleStruct.end_ := end_;
    }.
  End Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
  End Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
  
  Module  Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
  Section Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
    Definition Self : Set := serde_json.value.ser.SerializeTupleVariant.t.
    
    (*
        type Ok = Value;
    *)
    Definition Ok : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_field<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            self.vec.push(tri!(to_value(value)));
            Ok(())
        }
    *)
    Definition serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_field" := {
      Notations.double_colon := serialize_field (T := T);
    }.
    
    (*
        fn end(self) -> Result<Value> {
            let mut object = Map::new();
    
            object.insert(self.name, Value::Array(self.vec));
    
            Ok(Value::Object(object))
        }
    *)
    Definition end_
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeTupleVariant.Trait Self := {
      serde.ser.SerializeTupleVariant.Ok := Ok;
      serde.ser.SerializeTupleVariant.Error := Error;
      serde.ser.SerializeTupleVariant.serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_field (T := T);
      serde.ser.SerializeTupleVariant.end_ := end_;
    }.
  End Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
  End Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
  
  Module  Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
  Section Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
    Definition Self : Set := serde_json.value.ser.SerializeMap.t.
    
    (*
        type Ok = Value;
    *)
    Definition Ok : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_key<T>(&mut self, key: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            match self {
                SerializeMap::Map { next_key, .. } => {
                    *next_key = Some(tri!(key.serialize(MapKeySerializer)));
                    Ok(())
                }
                #[cfg(feature = "arbitrary_precision")]
                SerializeMap::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                SerializeMap::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition serialize_key
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (key : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_key
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_key" := {
      Notations.double_colon := serialize_key (T := T);
    }.
    
    (*
        fn serialize_value<T>(&mut self, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            match self {
                SerializeMap::Map { map, next_key } => {
                    let key = next_key.take();
                    // Panic because this indicates a bug in the program rather than an
                    // expected failure.
                    let key = key.expect("serialize_value called before serialize_key");
                    map.insert(key, tri!(to_value(value)));
                    Ok(())
                }
                #[cfg(feature = "arbitrary_precision")]
                SerializeMap::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                SerializeMap::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition serialize_value
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_value
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_value" := {
      Notations.double_colon := serialize_value (T := T);
    }.
    
    (*
        fn end(self) -> Result<Value> {
            match self {
                SerializeMap::Map { map, .. } => Ok(Value::Object(map)),
                #[cfg(feature = "arbitrary_precision")]
                SerializeMap::Number { .. } => unreachable!(),
                #[cfg(feature = "raw_value")]
                SerializeMap::RawValue { .. } => unreachable!(),
            }
        }
    *)
    Definition end_
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeMap.Required.Trait Self := {
      serde.ser.SerializeMap.Ok := Ok;
      serde.ser.SerializeMap.Error := Error;
      serde.ser.SerializeMap.serialize_key
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_key (T := T);
      serde.ser.SerializeMap.serialize_value
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_value (T := T);
      serde.ser.SerializeMap.end_ := end_;
      serde.ser.SerializeMap.serialize_entry := Datatypes.None;
    }.
  End Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
  End Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
  
  Module  MapKeySerializer.
  Section MapKeySerializer.
    Inductive t : Set := Build.
  End MapKeySerializer.
  End MapKeySerializer.
  
  (*
  fn key_must_be_a_string() -> Error {
      Error::syntax(ErrorCode::KeyMustBeAString, 0, 0)
  }
  *)
  Definition key_must_be_a_string : M serde_json.error.Error.t := M.read foo.
  
  (*
  fn float_key_must_be_finite() -> Error {
      Error::syntax(ErrorCode::FloatKeyMustBeFinite, 0, 0)
  }
  *)
  Definition float_key_must_be_finite : M serde_json.error.Error.t :=
    M.read foo.
  
  Module  Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
  Section Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
    Definition Self : Set := serde_json.value.ser.MapKeySerializer.t.
    
    (*
        type Ok = String;
    *)
    Definition Ok : Set := alloc.string.String.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        type SerializeSeq = Impossible<String, Error>;
    *)
    Definition SerializeSeq : Set :=
      serde.ser.impossible.Impossible.t
          alloc.string.String.t
          serde_json.error.Error.t.
    
    (*
        type SerializeTuple = Impossible<String, Error>;
    *)
    Definition SerializeTuple : Set :=
      serde.ser.impossible.Impossible.t
          alloc.string.String.t
          serde_json.error.Error.t.
    
    (*
        type SerializeTupleStruct = Impossible<String, Error>;
    *)
    Definition SerializeTupleStruct : Set :=
      serde.ser.impossible.Impossible.t
          alloc.string.String.t
          serde_json.error.Error.t.
    
    (*
        type SerializeTupleVariant = Impossible<String, Error>;
    *)
    Definition SerializeTupleVariant : Set :=
      serde.ser.impossible.Impossible.t
          alloc.string.String.t
          serde_json.error.Error.t.
    
    (*
        type SerializeMap = Impossible<String, Error>;
    *)
    Definition SerializeMap : Set :=
      serde.ser.impossible.Impossible.t
          alloc.string.String.t
          serde_json.error.Error.t.
    
    (*
        type SerializeStruct = Impossible<String, Error>;
    *)
    Definition SerializeStruct : Set :=
      serde.ser.impossible.Impossible.t
          alloc.string.String.t
          serde_json.error.Error.t.
    
    (*
        type SerializeStructVariant = Impossible<String, Error>;
    *)
    Definition SerializeStructVariant : Set :=
      serde.ser.impossible.Impossible.t
          alloc.string.String.t
          serde_json.error.Error.t.
    
    (*
        fn serialize_unit_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            variant: &'static str,
        ) -> Result<String> {
            Ok(variant.to_owned())
        }
    *)
    Definition serialize_unit_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (variant : ref str.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* variant := M.alloc variant in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit_variant :
      Notations.DoubleColon Self "serialize_unit_variant" := {
      Notations.double_colon := serialize_unit_variant;
    }.
    
    (*
        fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<String>
        where
            T: ?Sized + Serialize,
        {
            value.serialize(self)
        }
    *)
    Definition serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_name : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_newtype_struct" := {
      Notations.double_colon := serialize_newtype_struct (T := T);
    }.
    
    (*
        fn serialize_bool(self, value: bool) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_bool
        (self : Self)
        (value : bool.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_bool :
      Notations.DoubleColon Self "serialize_bool" := {
      Notations.double_colon := serialize_bool;
    }.
    
    (*
        fn serialize_i8(self, value: i8) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_i8
        (self : Self)
        (value : i8.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i8 :
      Notations.DoubleColon Self "serialize_i8" := {
      Notations.double_colon := serialize_i8;
    }.
    
    (*
        fn serialize_i16(self, value: i16) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_i16
        (self : Self)
        (value : i16.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i16 :
      Notations.DoubleColon Self "serialize_i16" := {
      Notations.double_colon := serialize_i16;
    }.
    
    (*
        fn serialize_i32(self, value: i32) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_i32
        (self : Self)
        (value : i32.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i32 :
      Notations.DoubleColon Self "serialize_i32" := {
      Notations.double_colon := serialize_i32;
    }.
    
    (*
        fn serialize_i64(self, value: i64) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_i64
        (self : Self)
        (value : i64.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_i64 :
      Notations.DoubleColon Self "serialize_i64" := {
      Notations.double_colon := serialize_i64;
    }.
    
    (*
        fn serialize_u8(self, value: u8) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_u8
        (self : Self)
        (value : u8.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u8 :
      Notations.DoubleColon Self "serialize_u8" := {
      Notations.double_colon := serialize_u8;
    }.
    
    (*
        fn serialize_u16(self, value: u16) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_u16
        (self : Self)
        (value : u16.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u16 :
      Notations.DoubleColon Self "serialize_u16" := {
      Notations.double_colon := serialize_u16;
    }.
    
    (*
        fn serialize_u32(self, value: u32) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_u32
        (self : Self)
        (value : u32.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u32 :
      Notations.DoubleColon Self "serialize_u32" := {
      Notations.double_colon := serialize_u32;
    }.
    
    (*
        fn serialize_u64(self, value: u64) -> Result<String> {
            Ok(value.to_string())
        }
    *)
    Definition serialize_u64
        (self : Self)
        (value : u64.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_u64 :
      Notations.DoubleColon Self "serialize_u64" := {
      Notations.double_colon := serialize_u64;
    }.
    
    (*
        fn serialize_f32(self, value: f32) -> Result<String> {
            if value.is_finite() {
                Ok(ryu::Buffer::new().format_finite(value).to_owned())
            } else {
                Err(float_key_must_be_finite())
            }
        }
    *)
    Definition serialize_f32
        (self : Self)
        (value : f32.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_f32 :
      Notations.DoubleColon Self "serialize_f32" := {
      Notations.double_colon := serialize_f32;
    }.
    
    (*
        fn serialize_f64(self, value: f64) -> Result<String> {
            if value.is_finite() {
                Ok(ryu::Buffer::new().format_finite(value).to_owned())
            } else {
                Err(float_key_must_be_finite())
            }
        }
    *)
    Definition serialize_f64
        (self : Self)
        (value : f64.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_f64 :
      Notations.DoubleColon Self "serialize_f64" := {
      Notations.double_colon := serialize_f64;
    }.
    
    (*
        fn serialize_char(self, value: char) -> Result<String> {
            Ok({
                let mut s = String::new();
                s.push(value);
                s
            })
        }
    *)
    Definition serialize_char
        (self : Self)
        (value : char.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_char :
      Notations.DoubleColon Self "serialize_char" := {
      Notations.double_colon := serialize_char;
    }.
    
    (*
        fn serialize_str(self, value: &str) -> Result<String> {
            Ok(value.to_owned())
        }
    *)
    Definition serialize_str
        (self : Self)
        (value : ref str.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_str :
      Notations.DoubleColon Self "serialize_str" := {
      Notations.double_colon := serialize_str;
    }.
    
    (*
        fn serialize_bytes(self, _value: &[u8]) -> Result<String> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_bytes
        (self : Self)
        (_value : ref (slice u8.t))
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* _value := M.alloc _value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_bytes :
      Notations.DoubleColon Self "serialize_bytes" := {
      Notations.double_colon := serialize_bytes;
    }.
    
    (*
        fn serialize_unit(self) -> Result<String> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_unit
        (self : Self)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit :
      Notations.DoubleColon Self "serialize_unit" := {
      Notations.double_colon := serialize_unit;
    }.
    
    (*
        fn serialize_unit_struct(self, _name: &'static str) -> Result<String> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_unit_struct
        (self : Self)
        (_name : ref str.t)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_unit_struct :
      Notations.DoubleColon Self "serialize_unit_struct" := {
      Notations.double_colon := serialize_unit_struct;
    }.
    
    (*
        fn serialize_newtype_variant<T>(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _value: &T,
        ) -> Result<String>
        where
            T: ?Sized + Serialize,
        {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (_variant : ref str.t)
        (_value : ref T)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* _variant := M.alloc _variant in
      let* _value := M.alloc _value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_newtype_variant" := {
      Notations.double_colon := serialize_newtype_variant (T := T);
    }.
    
    (*
        fn serialize_none(self) -> Result<String> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_none
        (self : Self)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_none :
      Notations.DoubleColon Self "serialize_none" := {
      Notations.double_colon := serialize_none;
    }.
    
    (*
        fn serialize_some<T>(self, _value: &T) -> Result<String>
        where
            T: ?Sized + Serialize,
        {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (_value : ref T)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* _value := M.alloc _value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_some" := {
      Notations.double_colon := serialize_some (T := T);
    }.
    
    (*
        fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_seq
        (self : Self)
        (_len : core.option.Option.t usize.t)
        : M ltac:(serde_json.error.Result SerializeSeq) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_seq :
      Notations.DoubleColon Self "serialize_seq" := {
      Notations.double_colon := serialize_seq;
    }.
    
    (*
        fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_tuple
        (self : Self)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTuple) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple :
      Notations.DoubleColon Self "serialize_tuple" := {
      Notations.double_colon := serialize_tuple;
    }.
    
    (*
        fn serialize_tuple_struct(
            self,
            _name: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeTupleStruct> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_tuple_struct
        (self : Self)
        (_name : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple_struct :
      Notations.DoubleColon Self "serialize_tuple_struct" := {
      Notations.double_colon := serialize_tuple_struct;
    }.
    
    (*
        fn serialize_tuple_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeTupleVariant> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_tuple_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (_variant : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* _variant := M.alloc _variant in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_tuple_variant :
      Notations.DoubleColon Self "serialize_tuple_variant" := {
      Notations.double_colon := serialize_tuple_variant;
    }.
    
    (*
        fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_map
        (self : Self)
        (_len : core.option.Option.t usize.t)
        : M ltac:(serde_json.error.Result SerializeMap) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_map :
      Notations.DoubleColon Self "serialize_map" := {
      Notations.double_colon := serialize_map;
    }.
    
    (*
        fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_struct
        (self : Self)
        (_name : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeStruct) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_struct :
      Notations.DoubleColon Self "serialize_struct" := {
      Notations.double_colon := serialize_struct;
    }.
    
    (*
        fn serialize_struct_variant(
            self,
            _name: &'static str,
            _variant_index: u32,
            _variant: &'static str,
            _len: usize,
        ) -> Result<Self::SerializeStructVariant> {
            Err(key_must_be_a_string())
        }
    *)
    Definition serialize_struct_variant
        (self : Self)
        (_name : ref str.t)
        (_variant_index : u32.t)
        (_variant : ref str.t)
        (_len : usize.t)
        : M ltac:(serde_json.error.Result SerializeStructVariant) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variant_index := M.alloc _variant_index in
      let* _variant := M.alloc _variant in
      let* _len := M.alloc _len in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_struct_variant :
      Notations.DoubleColon Self "serialize_struct_variant" := {
      Notations.double_colon := serialize_struct_variant;
    }.
    
    (*
        fn collect_str<T>(self, value: &T) -> Result<String>
        where
            T: ?Sized + Display,
        {
            Ok(value.to_string())
        }
    *)
    Definition collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T}
        (self : Self)
        (value : ref T)
        : M ltac:(serde_json.error.Result alloc.string.String.t) :=
      let* self := M.alloc self in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :
      Notations.DoubleColon Self "collect_str" := {
      Notations.double_colon := collect_str (T := T);
    }.
    
    Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
      serde.ser.Serializer.Ok := Ok;
      serde.ser.Serializer.Error := Error;
      serde.ser.Serializer.SerializeSeq := SerializeSeq;
      serde.ser.Serializer.SerializeTuple := SerializeTuple;
      serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
      serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
      serde.ser.Serializer.SerializeMap := SerializeMap;
      serde.ser.Serializer.SerializeStruct := SerializeStruct;
      serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
      serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
      serde.ser.Serializer.serialize_newtype_struct
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_newtype_struct (T := T);
      serde.ser.Serializer.serialize_bool := serialize_bool;
      serde.ser.Serializer.serialize_i8 := serialize_i8;
      serde.ser.Serializer.serialize_i16 := serialize_i16;
      serde.ser.Serializer.serialize_i32 := serialize_i32;
      serde.ser.Serializer.serialize_i64 := serialize_i64;
      serde.ser.Serializer.serialize_u8 := serialize_u8;
      serde.ser.Serializer.serialize_u16 := serialize_u16;
      serde.ser.Serializer.serialize_u32 := serialize_u32;
      serde.ser.Serializer.serialize_u64 := serialize_u64;
      serde.ser.Serializer.serialize_f32 := serialize_f32;
      serde.ser.Serializer.serialize_f64 := serialize_f64;
      serde.ser.Serializer.serialize_char := serialize_char;
      serde.ser.Serializer.serialize_str := serialize_str;
      serde.ser.Serializer.serialize_bytes := serialize_bytes;
      serde.ser.Serializer.serialize_unit := serialize_unit;
      serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
      serde.ser.Serializer.serialize_newtype_variant
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_newtype_variant (T := T);
      serde.ser.Serializer.serialize_none := serialize_none;
      serde.ser.Serializer.serialize_some
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_some (T := T);
      serde.ser.Serializer.serialize_seq := serialize_seq;
      serde.ser.Serializer.serialize_tuple := serialize_tuple;
      serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
      serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
      serde.ser.Serializer.serialize_map := serialize_map;
      serde.ser.Serializer.serialize_struct := serialize_struct;
      serde.ser.Serializer.serialize_struct_variant := serialize_struct_variant;
      serde.ser.Serializer.collect_str
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :=
        Datatypes.Some (collect_str (T := T));
      serde.ser.Serializer.serialize_i128 := Datatypes.None;
      serde.ser.Serializer.serialize_u128 := Datatypes.None;
      serde.ser.Serializer.collect_seq := Datatypes.None;
      serde.ser.Serializer.collect_map := Datatypes.None;
      serde.ser.Serializer.is_human_readable := Datatypes.None;
    }.
  End Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
  End Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
  
  Module  Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
  Section Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
    Definition Self : Set := serde_json.value.ser.SerializeMap.t.
    
    (*
        type Ok = Value;
    *)
    Definition Ok : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            match self {
                SerializeMap::Map { .. } => serde::ser::SerializeMap::serialize_entry(self, key, value),
                #[cfg(feature = "arbitrary_precision")]
                SerializeMap::Number { out_value } => {
                    if key == crate::number::TOKEN {
                        *out_value = Some(tri!(value.serialize(NumberValueEmitter)));
                        Ok(())
                    } else {
                        Err(invalid_number())
                    }
                }
                #[cfg(feature = "raw_value")]
                SerializeMap::RawValue { out_value } => {
                    if key == crate::raw::TOKEN {
                        *out_value = Some(tri!(value.serialize(RawValueEmitter)));
                        Ok(())
                    } else {
                        Err(invalid_raw_value())
                    }
                }
            }
        }
    *)
    Definition serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (key : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_field" := {
      Notations.double_colon := serialize_field (T := T);
    }.
    
    (*
        fn end(self) -> Result<Value> {
            match self {
                SerializeMap::Map { .. } => serde::ser::SerializeMap::end(self),
                #[cfg(feature = "arbitrary_precision")]
                SerializeMap::Number { out_value, .. } => {
                    Ok(out_value.expect("number value was not emitted"))
                }
                #[cfg(feature = "raw_value")]
                SerializeMap::RawValue { out_value, .. } => {
                    Ok(out_value.expect("raw value was not emitted"))
                }
            }
        }
    *)
    Definition end_
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ : serde.ser.SerializeStruct.Required.Trait Self := {
      serde.ser.SerializeStruct.Ok := Ok;
      serde.ser.SerializeStruct.Error := Error;
      serde.ser.SerializeStruct.serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_field (T := T);
      serde.ser.SerializeStruct.end_ := end_;
      serde.ser.SerializeStruct.skip_field := Datatypes.None;
    }.
  End Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
  End Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
  
  Module  Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
  Section Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
    Definition Self : Set := serde_json.value.ser.SerializeStructVariant.t.
    
    (*
        type Ok = Value;
    *)
    Definition Ok : Set := serde_json.value.Value.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
        fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
        where
            T: ?Sized + Serialize,
        {
            self.map.insert(String::from(key), tri!(to_value(value)));
            Ok(())
        }
    *)
    Definition serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : mut_ref Self)
        (key : ref str.t)
        (value : ref T)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      let* key := M.alloc key in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "serialize_field" := {
      Notations.double_colon := serialize_field (T := T);
    }.
    
    (*
        fn end(self) -> Result<Value> {
            let mut object = Map::new();
    
            object.insert(self.name, Value::Object(self.map));
    
            Ok(Value::Object(object))
        }
    *)
    Definition end_
        (self : Self)
        : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_end_ :
      Notations.DoubleColon Self "end_" := {
      Notations.double_colon := end_;
    }.
    
    Global Instance ℐ :
      serde.ser.SerializeStructVariant.Required.Trait Self := {
      serde.ser.SerializeStructVariant.Ok := Ok;
      serde.ser.SerializeStructVariant.Error := Error;
      serde.ser.SerializeStructVariant.serialize_field
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :=
        serialize_field (T := T);
      serde.ser.SerializeStructVariant.end_ := end_;
      serde.ser.SerializeStructVariant.skip_field := Datatypes.None;
    }.
  End Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
  End Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
End ser.
End Wrap_ser_1.
Import Wrap_ser_1.

Module  Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
Section Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
  Definition Self : Set := serde_json.value.Value.t.
  
  (*
      fn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>
      where
          S: ::serde::Serializer,
      {
          match self {
              Value::Null => serializer.serialize_unit(),
              Value::Bool(b) => serializer.serialize_bool( *b),
              Value::Number(n) => n.serialize(serializer),
              Value::String(s) => serializer.serialize_str(s),
              Value::Array(v) => v.serialize(serializer),
              #[cfg(any(feature = "std", feature = "alloc"))]
              Value::Object(m) => {
                  use serde::ser::SerializeMap;
                  let mut map = tri!(serializer.serialize_map(Some(m.len())));
                  for (k, v) in m {
                      tri!(map.serialize_entry(k, v));
                  }
                  map.end()
              }
          }
      }
  *)
  Definition serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S}
      (self : ref Self)
      (serializer : S)
      : M (core.result.Result.t S::type["Ok"].t S::type["Error"].t) :=
    let* self := M.alloc self in
    let* serializer := M.alloc serializer in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S} :
    Notations.DoubleColon Self "serialize" := {
    Notations.double_colon := serialize (S := S);
  }.
  
  Global Instance ℐ : serde.ser.Serialize.Trait Self := {
    serde.ser.Serialize.serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S} :=
      serialize (S := S);
  }.
End Impl_serde_ser_Serialize_for_serde_json_value_Value_t.
End Impl_serde_ser_Serialize_for_serde_json_value_Value_t.

Module  Serializer.
Section Serializer.
  Inductive t : Set := Build.
End Serializer.
End Serializer.

Module  Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
Section Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
  Definition Self : Set := serde_json.value.ser.Serializer.t.
  
  (*
      type Ok = Value;
  *)
  Definition Ok : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      type SerializeSeq = SerializeVec;
  *)
  Definition SerializeSeq : Set := serde_json.value.ser.SerializeVec.t.
  
  (*
      type SerializeTuple = SerializeVec;
  *)
  Definition SerializeTuple : Set := serde_json.value.ser.SerializeVec.t.
  
  (*
      type SerializeTupleStruct = SerializeVec;
  *)
  Definition SerializeTupleStruct : Set := serde_json.value.ser.SerializeVec.t.
  
  (*
      type SerializeTupleVariant = SerializeTupleVariant;
  *)
  Definition SerializeTupleVariant : Set :=
    serde_json.value.ser.SerializeTupleVariant.t.
  
  (*
      type SerializeMap = SerializeMap;
  *)
  Definition SerializeMap : Set := serde_json.value.ser.SerializeMap.t.
  
  (*
      type SerializeStruct = SerializeMap;
  *)
  Definition SerializeStruct : Set := serde_json.value.ser.SerializeMap.t.
  
  (*
      type SerializeStructVariant = SerializeStructVariant;
  *)
  Definition SerializeStructVariant : Set :=
    serde_json.value.ser.SerializeStructVariant.t.
  
  (*
      fn serialize_bool(self, value: bool) -> Result<Value> {
          Ok(Value::Bool(value))
      }
  *)
  Definition serialize_bool
      (self : Self)
      (value : bool.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_bool :
    Notations.DoubleColon Self "serialize_bool" := {
    Notations.double_colon := serialize_bool;
  }.
  
  (*
      fn serialize_i8(self, value: i8) -> Result<Value> {
          self.serialize_i64(value as i64)
      }
  *)
  Definition serialize_i8
      (self : Self)
      (value : i8.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i8 :
    Notations.DoubleColon Self "serialize_i8" := {
    Notations.double_colon := serialize_i8;
  }.
  
  (*
      fn serialize_i16(self, value: i16) -> Result<Value> {
          self.serialize_i64(value as i64)
      }
  *)
  Definition serialize_i16
      (self : Self)
      (value : i16.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i16 :
    Notations.DoubleColon Self "serialize_i16" := {
    Notations.double_colon := serialize_i16;
  }.
  
  (*
      fn serialize_i32(self, value: i32) -> Result<Value> {
          self.serialize_i64(value as i64)
      }
  *)
  Definition serialize_i32
      (self : Self)
      (value : i32.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i32 :
    Notations.DoubleColon Self "serialize_i32" := {
    Notations.double_colon := serialize_i32;
  }.
  
  (*
      fn serialize_i64(self, value: i64) -> Result<Value> {
          Ok(Value::Number(value.into()))
      }
  *)
  Definition serialize_i64
      (self : Self)
      (value : i64.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i64 :
    Notations.DoubleColon Self "serialize_i64" := {
    Notations.double_colon := serialize_i64;
  }.
  
  (*
      fn serialize_i128(self, value: i128) -> Result<Value> {
          #[cfg(feature = "arbitrary_precision")]
          {
              Ok(Value::Number(value.into()))
          }
  
          #[cfg(not(feature = "arbitrary_precision"))]
          {
              if let Ok(value) = u64::try_from(value) {
                  Ok(Value::Number(value.into()))
              } else if let Ok(value) = i64::try_from(value) {
                  Ok(Value::Number(value.into()))
              } else {
                  Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))
              }
          }
      }
  *)
  Definition serialize_i128
      (self : Self)
      (value : i128.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i128 :
    Notations.DoubleColon Self "serialize_i128" := {
    Notations.double_colon := serialize_i128;
  }.
  
  (*
      fn serialize_u8(self, value: u8) -> Result<Value> {
          self.serialize_u64(value as u64)
      }
  *)
  Definition serialize_u8
      (self : Self)
      (value : u8.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u8 :
    Notations.DoubleColon Self "serialize_u8" := {
    Notations.double_colon := serialize_u8;
  }.
  
  (*
      fn serialize_u16(self, value: u16) -> Result<Value> {
          self.serialize_u64(value as u64)
      }
  *)
  Definition serialize_u16
      (self : Self)
      (value : u16.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u16 :
    Notations.DoubleColon Self "serialize_u16" := {
    Notations.double_colon := serialize_u16;
  }.
  
  (*
      fn serialize_u32(self, value: u32) -> Result<Value> {
          self.serialize_u64(value as u64)
      }
  *)
  Definition serialize_u32
      (self : Self)
      (value : u32.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u32 :
    Notations.DoubleColon Self "serialize_u32" := {
    Notations.double_colon := serialize_u32;
  }.
  
  (*
      fn serialize_u64(self, value: u64) -> Result<Value> {
          Ok(Value::Number(value.into()))
      }
  *)
  Definition serialize_u64
      (self : Self)
      (value : u64.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u64 :
    Notations.DoubleColon Self "serialize_u64" := {
    Notations.double_colon := serialize_u64;
  }.
  
  (*
      fn serialize_u128(self, value: u128) -> Result<Value> {
          #[cfg(feature = "arbitrary_precision")]
          {
              Ok(Value::Number(value.into()))
          }
  
          #[cfg(not(feature = "arbitrary_precision"))]
          {
              if let Ok(value) = u64::try_from(value) {
                  Ok(Value::Number(value.into()))
              } else {
                  Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))
              }
          }
      }
  *)
  Definition serialize_u128
      (self : Self)
      (value : u128.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u128 :
    Notations.DoubleColon Self "serialize_u128" := {
    Notations.double_colon := serialize_u128;
  }.
  
  (*
      fn serialize_f32(self, float: f32) -> Result<Value> {
          Ok(Value::from(float))
      }
  *)
  Definition serialize_f32
      (self : Self)
      (float : f32.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* float := M.alloc float in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_f32 :
    Notations.DoubleColon Self "serialize_f32" := {
    Notations.double_colon := serialize_f32;
  }.
  
  (*
      fn serialize_f64(self, float: f64) -> Result<Value> {
          Ok(Value::from(float))
      }
  *)
  Definition serialize_f64
      (self : Self)
      (float : f64.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* float := M.alloc float in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_f64 :
    Notations.DoubleColon Self "serialize_f64" := {
    Notations.double_colon := serialize_f64;
  }.
  
  (*
      fn serialize_char(self, value: char) -> Result<Value> {
          let mut s = String::new();
          s.push(value);
          Ok(Value::String(s))
      }
  *)
  Definition serialize_char
      (self : Self)
      (value : char.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_char :
    Notations.DoubleColon Self "serialize_char" := {
    Notations.double_colon := serialize_char;
  }.
  
  (*
      fn serialize_str(self, value: &str) -> Result<Value> {
          Ok(Value::String(value.to_owned()))
      }
  *)
  Definition serialize_str
      (self : Self)
      (value : ref str.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_str :
    Notations.DoubleColon Self "serialize_str" := {
    Notations.double_colon := serialize_str;
  }.
  
  (*
      fn serialize_bytes(self, value: &[u8]) -> Result<Value> {
          let vec = value.iter().map(|&b| Value::Number(b.into())).collect();
          Ok(Value::Array(vec))
      }
  *)
  Definition serialize_bytes
      (self : Self)
      (value : ref (slice u8.t))
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_bytes :
    Notations.DoubleColon Self "serialize_bytes" := {
    Notations.double_colon := serialize_bytes;
  }.
  
  (*
      fn serialize_unit(self) -> Result<Value> {
          Ok(Value::Null)
      }
  *)
  Definition serialize_unit
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit :
    Notations.DoubleColon Self "serialize_unit" := {
    Notations.double_colon := serialize_unit;
  }.
  
  (*
      fn serialize_unit_struct(self, _name: &'static str) -> Result<Value> {
          self.serialize_unit()
      }
  *)
  Definition serialize_unit_struct
      (self : Self)
      (_name : ref str.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit_struct :
    Notations.DoubleColon Self "serialize_unit_struct" := {
    Notations.double_colon := serialize_unit_struct;
  }.
  
  (*
      fn serialize_unit_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
      ) -> Result<Value> {
          self.serialize_str(variant)
      }
  *)
  Definition serialize_unit_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit_variant :
    Notations.DoubleColon Self "serialize_unit_variant" := {
    Notations.double_colon := serialize_unit_variant;
  }.
  
  (*
      fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<Value>
      where
          T: ?Sized + Serialize,
      {
          value.serialize(self)
      }
  *)
  Definition serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_name : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_newtype_struct" := {
    Notations.double_colon := serialize_newtype_struct (T := T);
  }.
  
  (*
      fn serialize_newtype_variant<T>(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
          value: &T,
      ) -> Result<Value>
      where
          T: ?Sized + Serialize,
      {
          let mut values = Map::new();
          values.insert(String::from(variant), tri!(to_value(value)));
          Ok(Value::Object(values))
      }
  *)
  Definition serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_newtype_variant" := {
    Notations.double_colon := serialize_newtype_variant (T := T);
  }.
  
  (*
      fn serialize_none(self) -> Result<Value> {
          self.serialize_unit()
      }
  *)
  Definition serialize_none
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_none :
    Notations.DoubleColon Self "serialize_none" := {
    Notations.double_colon := serialize_none;
  }.
  
  (*
      fn serialize_some<T>(self, value: &T) -> Result<Value>
      where
          T: ?Sized + Serialize,
      {
          value.serialize(self)
      }
  *)
  Definition serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_some" := {
    Notations.double_colon := serialize_some (T := T);
  }.
  
  (*
      fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {
          Ok(SerializeVec {
              vec: Vec::with_capacity(len.unwrap_or(0)),
          })
      }
  *)
  Definition serialize_seq
      (self : Self)
      (len : core.option.Option.t usize.t)
      : M ltac:(serde_json.error.Result SerializeSeq) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_seq :
    Notations.DoubleColon Self "serialize_seq" := {
    Notations.double_colon := serialize_seq;
  }.
  
  (*
      fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {
          self.serialize_seq(Some(len))
      }
  *)
  Definition serialize_tuple
      (self : Self)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTuple) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple :
    Notations.DoubleColon Self "serialize_tuple" := {
    Notations.double_colon := serialize_tuple;
  }.
  
  (*
      fn serialize_tuple_struct(
          self,
          _name: &'static str,
          len: usize,
      ) -> Result<Self::SerializeTupleStruct> {
          self.serialize_seq(Some(len))
      }
  *)
  Definition serialize_tuple_struct
      (self : Self)
      (_name : ref str.t)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple_struct :
    Notations.DoubleColon Self "serialize_tuple_struct" := {
    Notations.double_colon := serialize_tuple_struct;
  }.
  
  (*
      fn serialize_tuple_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
          len: usize,
      ) -> Result<Self::SerializeTupleVariant> {
          Ok(SerializeTupleVariant {
              name: String::from(variant),
              vec: Vec::with_capacity(len),
          })
      }
  *)
  Definition serialize_tuple_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple_variant :
    Notations.DoubleColon Self "serialize_tuple_variant" := {
    Notations.double_colon := serialize_tuple_variant;
  }.
  
  (*
      fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {
          Ok(SerializeMap::Map {
              map: Map::new(),
              next_key: None,
          })
      }
  *)
  Definition serialize_map
      (self : Self)
      (_len : core.option.Option.t usize.t)
      : M ltac:(serde_json.error.Result SerializeMap) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_map :
    Notations.DoubleColon Self "serialize_map" := {
    Notations.double_colon := serialize_map;
  }.
  
  (*
      fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct> {
          match name {
              #[cfg(feature = "arbitrary_precision")]
              crate::number::TOKEN => Ok(SerializeMap::Number { out_value: None }),
              #[cfg(feature = "raw_value")]
              crate::raw::TOKEN => Ok(SerializeMap::RawValue { out_value: None }),
              _ => self.serialize_map(Some(len)),
          }
      }
  *)
  Definition serialize_struct
      (self : Self)
      (name : ref str.t)
      (len : usize.t)
      : M ltac:(serde_json.error.Result SerializeStruct) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* len := M.alloc len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_struct :
    Notations.DoubleColon Self "serialize_struct" := {
    Notations.double_colon := serialize_struct;
  }.
  
  (*
      fn serialize_struct_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
          _len: usize,
      ) -> Result<Self::SerializeStructVariant> {
          Ok(SerializeStructVariant {
              name: String::from(variant),
              map: Map::new(),
          })
      }
  *)
  Definition serialize_struct_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeStructVariant) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_struct_variant :
    Notations.DoubleColon Self "serialize_struct_variant" := {
    Notations.double_colon := serialize_struct_variant;
  }.
  
  (*
      fn collect_str<T>(self, value: &T) -> Result<Value>
      where
          T: ?Sized + Display,
      {
          Ok(Value::String(value.to_string()))
      }
  *)
  Definition collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T}
      (self : Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :
    Notations.DoubleColon Self "collect_str" := {
    Notations.double_colon := collect_str (T := T);
  }.
  
  Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
    serde.ser.Serializer.Ok := Ok;
    serde.ser.Serializer.Error := Error;
    serde.ser.Serializer.SerializeSeq := SerializeSeq;
    serde.ser.Serializer.SerializeTuple := SerializeTuple;
    serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
    serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
    serde.ser.Serializer.SerializeMap := SerializeMap;
    serde.ser.Serializer.SerializeStruct := SerializeStruct;
    serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
    serde.ser.Serializer.serialize_bool := serialize_bool;
    serde.ser.Serializer.serialize_i8 := serialize_i8;
    serde.ser.Serializer.serialize_i16 := serialize_i16;
    serde.ser.Serializer.serialize_i32 := serialize_i32;
    serde.ser.Serializer.serialize_i64 := serialize_i64;
    serde.ser.Serializer.serialize_i128 := Datatypes.Some serialize_i128;
    serde.ser.Serializer.serialize_u8 := serialize_u8;
    serde.ser.Serializer.serialize_u16 := serialize_u16;
    serde.ser.Serializer.serialize_u32 := serialize_u32;
    serde.ser.Serializer.serialize_u64 := serialize_u64;
    serde.ser.Serializer.serialize_u128 := Datatypes.Some serialize_u128;
    serde.ser.Serializer.serialize_f32 := serialize_f32;
    serde.ser.Serializer.serialize_f64 := serialize_f64;
    serde.ser.Serializer.serialize_char := serialize_char;
    serde.ser.Serializer.serialize_str := serialize_str;
    serde.ser.Serializer.serialize_bytes := serialize_bytes;
    serde.ser.Serializer.serialize_unit := serialize_unit;
    serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
    serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
    serde.ser.Serializer.serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_newtype_struct (T := T);
    serde.ser.Serializer.serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_newtype_variant (T := T);
    serde.ser.Serializer.serialize_none := serialize_none;
    serde.ser.Serializer.serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_some (T := T);
    serde.ser.Serializer.serialize_seq := serialize_seq;
    serde.ser.Serializer.serialize_tuple := serialize_tuple;
    serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
    serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
    serde.ser.Serializer.serialize_map := serialize_map;
    serde.ser.Serializer.serialize_struct := serialize_struct;
    serde.ser.Serializer.serialize_struct_variant := serialize_struct_variant;
    serde.ser.Serializer.collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :=
      Datatypes.Some (collect_str (T := T));
    serde.ser.Serializer.collect_seq := Datatypes.None;
    serde.ser.Serializer.collect_map := Datatypes.None;
    serde.ser.Serializer.is_human_readable := Datatypes.None;
  }.
End Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.
End Impl_serde_ser_Serializer_for_serde_json_value_ser_Serializer_t.

Module  SerializeVec.
Section SerializeVec.
  Record t : Set := {
    vec : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A;
  }.
  
  Definition Get_vec :=
    Ref.map (fun α => Some α.(vec)) (fun β α => Some (α <| vec := β |>)).
End SerializeVec.
End SerializeVec.

Module  SerializeTupleVariant.
Section SerializeTupleVariant.
  Record t : Set := {
    name : alloc.string.String.t;
    vec : alloc.vec.Vec.t serde_json.value.Value.t alloc.vec.Vec.Default.A;
  }.
  
  Definition Get_name :=
    Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
  Definition Get_vec :=
    Ref.map (fun α => Some α.(vec)) (fun β α => Some (α <| vec := β |>)).
End SerializeTupleVariant.
End SerializeTupleVariant.

Module SerializeMap.
  Module Map.
    Record t : Set := {
      map : serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t;
      next_key : core.option.Option.t alloc.string.String.t;
    }.
  End Map.
  
  Inductive t : Set :=
  | Map (_ : Map.t).
  
  Definition Get_Map_map :=
    Ref.map
      (fun α => match α with | Map α => Some α.(Map.map) end)
      (fun β α =>
        match α with | Map α => Some (Map (α <| Map.map := β |>)) end).
  
  Definition Get_Map_next_key :=
    Ref.map
      (fun α => match α with | Map α => Some α.(Map.next_key) end)
      (fun β α =>
        match α with | Map α => Some (Map (α <| Map.next_key := β |>)) end).
End SerializeMap.

Module  SerializeStructVariant.
Section SerializeStructVariant.
  Record t : Set := {
    name : alloc.string.String.t;
    map : serde_json.map.Map.t alloc.string.String.t serde_json.value.Value.t;
  }.
  
  Definition Get_name :=
    Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
  Definition Get_map :=
    Ref.map (fun α => Some α.(map)) (fun β α => Some (α <| map := β |>)).
End SerializeStructVariant.
End SerializeStructVariant.

Module  Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
Section Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
  Definition Self : Set := serde_json.value.ser.SerializeVec.t.
  
  (*
      type Ok = Value;
  *)
  Definition Ok : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_element<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          self.vec.push(tri!(to_value(value)));
          Ok(())
      }
  *)
  Definition serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_element" := {
    Notations.double_colon := serialize_element (T := T);
  }.
  
  (*
      fn end(self) -> Result<Value> {
          Ok(Value::Array(self.vec))
      }
  *)
  Definition end_
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeSeq.Trait Self := {
    serde.ser.SerializeSeq.Ok := Ok;
    serde.ser.SerializeSeq.Error := Error;
    serde.ser.SerializeSeq.serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_element (T := T);
    serde.ser.SerializeSeq.end_ := end_;
  }.
End Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.
End Impl_serde_ser_SerializeSeq_for_serde_json_value_ser_SerializeVec_t.

Module  Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
Section Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
  Definition Self : Set := serde_json.value.ser.SerializeVec.t.
  
  (*
      type Ok = Value;
  *)
  Definition Ok : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_element<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          serde::ser::SerializeSeq::serialize_element(self, value)
      }
  *)
  Definition serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_element" := {
    Notations.double_colon := serialize_element (T := T);
  }.
  
  (*
      fn end(self) -> Result<Value> {
          serde::ser::SerializeSeq::end(self)
      }
  *)
  Definition end_
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeTuple.Trait Self := {
    serde.ser.SerializeTuple.Ok := Ok;
    serde.ser.SerializeTuple.Error := Error;
    serde.ser.SerializeTuple.serialize_element
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_element (T := T);
    serde.ser.SerializeTuple.end_ := end_;
  }.
End Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.
End Impl_serde_ser_SerializeTuple_for_serde_json_value_ser_SerializeVec_t.

Module  Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
Section Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
  Definition Self : Set := serde_json.value.ser.SerializeVec.t.
  
  (*
      type Ok = Value;
  *)
  Definition Ok : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_field<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          serde::ser::SerializeSeq::serialize_element(self, value)
      }
  *)
  Definition serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_field" := {
    Notations.double_colon := serialize_field (T := T);
  }.
  
  (*
      fn end(self) -> Result<Value> {
          serde::ser::SerializeSeq::end(self)
      }
  *)
  Definition end_
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeTupleStruct.Trait Self := {
    serde.ser.SerializeTupleStruct.Ok := Ok;
    serde.ser.SerializeTupleStruct.Error := Error;
    serde.ser.SerializeTupleStruct.serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_field (T := T);
    serde.ser.SerializeTupleStruct.end_ := end_;
  }.
End Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.
End Impl_serde_ser_SerializeTupleStruct_for_serde_json_value_ser_SerializeVec_t.

Module  Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
Section Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
  Definition Self : Set := serde_json.value.ser.SerializeTupleVariant.t.
  
  (*
      type Ok = Value;
  *)
  Definition Ok : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_field<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          self.vec.push(tri!(to_value(value)));
          Ok(())
      }
  *)
  Definition serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_field" := {
    Notations.double_colon := serialize_field (T := T);
  }.
  
  (*
      fn end(self) -> Result<Value> {
          let mut object = Map::new();
  
          object.insert(self.name, Value::Array(self.vec));
  
          Ok(Value::Object(object))
      }
  *)
  Definition end_
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeTupleVariant.Trait Self := {
    serde.ser.SerializeTupleVariant.Ok := Ok;
    serde.ser.SerializeTupleVariant.Error := Error;
    serde.ser.SerializeTupleVariant.serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_field (T := T);
    serde.ser.SerializeTupleVariant.end_ := end_;
  }.
End Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.
End Impl_serde_ser_SerializeTupleVariant_for_serde_json_value_ser_SerializeTupleVariant_t.

Module  Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
Section Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
  Definition Self : Set := serde_json.value.ser.SerializeMap.t.
  
  (*
      type Ok = Value;
  *)
  Definition Ok : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_key<T>(&mut self, key: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          match self {
              SerializeMap::Map { next_key, .. } => {
                  *next_key = Some(tri!(key.serialize(MapKeySerializer)));
                  Ok(())
              }
              #[cfg(feature = "arbitrary_precision")]
              SerializeMap::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              SerializeMap::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition serialize_key
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (key : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_key
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_key" := {
    Notations.double_colon := serialize_key (T := T);
  }.
  
  (*
      fn serialize_value<T>(&mut self, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          match self {
              SerializeMap::Map { map, next_key } => {
                  let key = next_key.take();
                  // Panic because this indicates a bug in the program rather than an
                  // expected failure.
                  let key = key.expect("serialize_value called before serialize_key");
                  map.insert(key, tri!(to_value(value)));
                  Ok(())
              }
              #[cfg(feature = "arbitrary_precision")]
              SerializeMap::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              SerializeMap::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition serialize_value
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_value
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_value" := {
    Notations.double_colon := serialize_value (T := T);
  }.
  
  (*
      fn end(self) -> Result<Value> {
          match self {
              SerializeMap::Map { map, .. } => Ok(Value::Object(map)),
              #[cfg(feature = "arbitrary_precision")]
              SerializeMap::Number { .. } => unreachable!(),
              #[cfg(feature = "raw_value")]
              SerializeMap::RawValue { .. } => unreachable!(),
          }
      }
  *)
  Definition end_
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeMap.Required.Trait Self := {
    serde.ser.SerializeMap.Ok := Ok;
    serde.ser.SerializeMap.Error := Error;
    serde.ser.SerializeMap.serialize_key
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_key (T := T);
    serde.ser.SerializeMap.serialize_value
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_value (T := T);
    serde.ser.SerializeMap.end_ := end_;
    serde.ser.SerializeMap.serialize_entry := Datatypes.None;
  }.
End Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.
End Impl_serde_ser_SerializeMap_for_serde_json_value_ser_SerializeMap_t.

Module  MapKeySerializer.
Section MapKeySerializer.
  Inductive t : Set := Build.
End MapKeySerializer.
End MapKeySerializer.

Module  Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
Section Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
  Definition Self : Set := serde_json.value.ser.MapKeySerializer.t.
  
  (*
      type Ok = String;
  *)
  Definition Ok : Set := alloc.string.String.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      type SerializeSeq = Impossible<String, Error>;
  *)
  Definition SerializeSeq : Set :=
    serde.ser.impossible.Impossible.t
        alloc.string.String.t
        serde_json.error.Error.t.
  
  (*
      type SerializeTuple = Impossible<String, Error>;
  *)
  Definition SerializeTuple : Set :=
    serde.ser.impossible.Impossible.t
        alloc.string.String.t
        serde_json.error.Error.t.
  
  (*
      type SerializeTupleStruct = Impossible<String, Error>;
  *)
  Definition SerializeTupleStruct : Set :=
    serde.ser.impossible.Impossible.t
        alloc.string.String.t
        serde_json.error.Error.t.
  
  (*
      type SerializeTupleVariant = Impossible<String, Error>;
  *)
  Definition SerializeTupleVariant : Set :=
    serde.ser.impossible.Impossible.t
        alloc.string.String.t
        serde_json.error.Error.t.
  
  (*
      type SerializeMap = Impossible<String, Error>;
  *)
  Definition SerializeMap : Set :=
    serde.ser.impossible.Impossible.t
        alloc.string.String.t
        serde_json.error.Error.t.
  
  (*
      type SerializeStruct = Impossible<String, Error>;
  *)
  Definition SerializeStruct : Set :=
    serde.ser.impossible.Impossible.t
        alloc.string.String.t
        serde_json.error.Error.t.
  
  (*
      type SerializeStructVariant = Impossible<String, Error>;
  *)
  Definition SerializeStructVariant : Set :=
    serde.ser.impossible.Impossible.t
        alloc.string.String.t
        serde_json.error.Error.t.
  
  (*
      fn serialize_unit_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          variant: &'static str,
      ) -> Result<String> {
          Ok(variant.to_owned())
      }
  *)
  Definition serialize_unit_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (variant : ref str.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* variant := M.alloc variant in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit_variant :
    Notations.DoubleColon Self "serialize_unit_variant" := {
    Notations.double_colon := serialize_unit_variant;
  }.
  
  (*
      fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<String>
      where
          T: ?Sized + Serialize,
      {
          value.serialize(self)
      }
  *)
  Definition serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_name : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_newtype_struct" := {
    Notations.double_colon := serialize_newtype_struct (T := T);
  }.
  
  (*
      fn serialize_bool(self, value: bool) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_bool
      (self : Self)
      (value : bool.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_bool :
    Notations.DoubleColon Self "serialize_bool" := {
    Notations.double_colon := serialize_bool;
  }.
  
  (*
      fn serialize_i8(self, value: i8) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_i8
      (self : Self)
      (value : i8.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i8 :
    Notations.DoubleColon Self "serialize_i8" := {
    Notations.double_colon := serialize_i8;
  }.
  
  (*
      fn serialize_i16(self, value: i16) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_i16
      (self : Self)
      (value : i16.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i16 :
    Notations.DoubleColon Self "serialize_i16" := {
    Notations.double_colon := serialize_i16;
  }.
  
  (*
      fn serialize_i32(self, value: i32) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_i32
      (self : Self)
      (value : i32.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i32 :
    Notations.DoubleColon Self "serialize_i32" := {
    Notations.double_colon := serialize_i32;
  }.
  
  (*
      fn serialize_i64(self, value: i64) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_i64
      (self : Self)
      (value : i64.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_i64 :
    Notations.DoubleColon Self "serialize_i64" := {
    Notations.double_colon := serialize_i64;
  }.
  
  (*
      fn serialize_u8(self, value: u8) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_u8
      (self : Self)
      (value : u8.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u8 :
    Notations.DoubleColon Self "serialize_u8" := {
    Notations.double_colon := serialize_u8;
  }.
  
  (*
      fn serialize_u16(self, value: u16) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_u16
      (self : Self)
      (value : u16.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u16 :
    Notations.DoubleColon Self "serialize_u16" := {
    Notations.double_colon := serialize_u16;
  }.
  
  (*
      fn serialize_u32(self, value: u32) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_u32
      (self : Self)
      (value : u32.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u32 :
    Notations.DoubleColon Self "serialize_u32" := {
    Notations.double_colon := serialize_u32;
  }.
  
  (*
      fn serialize_u64(self, value: u64) -> Result<String> {
          Ok(value.to_string())
      }
  *)
  Definition serialize_u64
      (self : Self)
      (value : u64.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_u64 :
    Notations.DoubleColon Self "serialize_u64" := {
    Notations.double_colon := serialize_u64;
  }.
  
  (*
      fn serialize_f32(self, value: f32) -> Result<String> {
          if value.is_finite() {
              Ok(ryu::Buffer::new().format_finite(value).to_owned())
          } else {
              Err(float_key_must_be_finite())
          }
      }
  *)
  Definition serialize_f32
      (self : Self)
      (value : f32.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_f32 :
    Notations.DoubleColon Self "serialize_f32" := {
    Notations.double_colon := serialize_f32;
  }.
  
  (*
      fn serialize_f64(self, value: f64) -> Result<String> {
          if value.is_finite() {
              Ok(ryu::Buffer::new().format_finite(value).to_owned())
          } else {
              Err(float_key_must_be_finite())
          }
      }
  *)
  Definition serialize_f64
      (self : Self)
      (value : f64.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_f64 :
    Notations.DoubleColon Self "serialize_f64" := {
    Notations.double_colon := serialize_f64;
  }.
  
  (*
      fn serialize_char(self, value: char) -> Result<String> {
          Ok({
              let mut s = String::new();
              s.push(value);
              s
          })
      }
  *)
  Definition serialize_char
      (self : Self)
      (value : char.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_char :
    Notations.DoubleColon Self "serialize_char" := {
    Notations.double_colon := serialize_char;
  }.
  
  (*
      fn serialize_str(self, value: &str) -> Result<String> {
          Ok(value.to_owned())
      }
  *)
  Definition serialize_str
      (self : Self)
      (value : ref str.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_str :
    Notations.DoubleColon Self "serialize_str" := {
    Notations.double_colon := serialize_str;
  }.
  
  (*
      fn serialize_bytes(self, _value: &[u8]) -> Result<String> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_bytes
      (self : Self)
      (_value : ref (slice u8.t))
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* _value := M.alloc _value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_bytes :
    Notations.DoubleColon Self "serialize_bytes" := {
    Notations.double_colon := serialize_bytes;
  }.
  
  (*
      fn serialize_unit(self) -> Result<String> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_unit
      (self : Self)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit :
    Notations.DoubleColon Self "serialize_unit" := {
    Notations.double_colon := serialize_unit;
  }.
  
  (*
      fn serialize_unit_struct(self, _name: &'static str) -> Result<String> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_unit_struct
      (self : Self)
      (_name : ref str.t)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_unit_struct :
    Notations.DoubleColon Self "serialize_unit_struct" := {
    Notations.double_colon := serialize_unit_struct;
  }.
  
  (*
      fn serialize_newtype_variant<T>(
          self,
          _name: &'static str,
          _variant_index: u32,
          _variant: &'static str,
          _value: &T,
      ) -> Result<String>
      where
          T: ?Sized + Serialize,
      {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (_variant : ref str.t)
      (_value : ref T)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* _variant := M.alloc _variant in
    let* _value := M.alloc _value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_newtype_variant" := {
    Notations.double_colon := serialize_newtype_variant (T := T);
  }.
  
  (*
      fn serialize_none(self) -> Result<String> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_none
      (self : Self)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_none :
    Notations.DoubleColon Self "serialize_none" := {
    Notations.double_colon := serialize_none;
  }.
  
  (*
      fn serialize_some<T>(self, _value: &T) -> Result<String>
      where
          T: ?Sized + Serialize,
      {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (_value : ref T)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* _value := M.alloc _value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_some" := {
    Notations.double_colon := serialize_some (T := T);
  }.
  
  (*
      fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_seq
      (self : Self)
      (_len : core.option.Option.t usize.t)
      : M ltac:(serde_json.error.Result SerializeSeq) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_seq :
    Notations.DoubleColon Self "serialize_seq" := {
    Notations.double_colon := serialize_seq;
  }.
  
  (*
      fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_tuple
      (self : Self)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTuple) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple :
    Notations.DoubleColon Self "serialize_tuple" := {
    Notations.double_colon := serialize_tuple;
  }.
  
  (*
      fn serialize_tuple_struct(
          self,
          _name: &'static str,
          _len: usize,
      ) -> Result<Self::SerializeTupleStruct> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_tuple_struct
      (self : Self)
      (_name : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTupleStruct) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple_struct :
    Notations.DoubleColon Self "serialize_tuple_struct" := {
    Notations.double_colon := serialize_tuple_struct;
  }.
  
  (*
      fn serialize_tuple_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          _variant: &'static str,
          _len: usize,
      ) -> Result<Self::SerializeTupleVariant> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_tuple_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (_variant : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeTupleVariant) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* _variant := M.alloc _variant in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_tuple_variant :
    Notations.DoubleColon Self "serialize_tuple_variant" := {
    Notations.double_colon := serialize_tuple_variant;
  }.
  
  (*
      fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_map
      (self : Self)
      (_len : core.option.Option.t usize.t)
      : M ltac:(serde_json.error.Result SerializeMap) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_map :
    Notations.DoubleColon Self "serialize_map" := {
    Notations.double_colon := serialize_map;
  }.
  
  (*
      fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_struct
      (self : Self)
      (_name : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeStruct) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_struct :
    Notations.DoubleColon Self "serialize_struct" := {
    Notations.double_colon := serialize_struct;
  }.
  
  (*
      fn serialize_struct_variant(
          self,
          _name: &'static str,
          _variant_index: u32,
          _variant: &'static str,
          _len: usize,
      ) -> Result<Self::SerializeStructVariant> {
          Err(key_must_be_a_string())
      }
  *)
  Definition serialize_struct_variant
      (self : Self)
      (_name : ref str.t)
      (_variant_index : u32.t)
      (_variant : ref str.t)
      (_len : usize.t)
      : M ltac:(serde_json.error.Result SerializeStructVariant) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variant_index := M.alloc _variant_index in
    let* _variant := M.alloc _variant in
    let* _len := M.alloc _len in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_struct_variant :
    Notations.DoubleColon Self "serialize_struct_variant" := {
    Notations.double_colon := serialize_struct_variant;
  }.
  
  (*
      fn collect_str<T>(self, value: &T) -> Result<String>
      where
          T: ?Sized + Display,
      {
          Ok(value.to_string())
      }
  *)
  Definition collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T}
      (self : Self)
      (value : ref T)
      : M ltac:(serde_json.error.Result alloc.string.String.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :
    Notations.DoubleColon Self "collect_str" := {
    Notations.double_colon := collect_str (T := T);
  }.
  
  Global Instance ℐ : serde.ser.Serializer.Required.Trait Self := {
    serde.ser.Serializer.Ok := Ok;
    serde.ser.Serializer.Error := Error;
    serde.ser.Serializer.SerializeSeq := SerializeSeq;
    serde.ser.Serializer.SerializeTuple := SerializeTuple;
    serde.ser.Serializer.SerializeTupleStruct := SerializeTupleStruct;
    serde.ser.Serializer.SerializeTupleVariant := SerializeTupleVariant;
    serde.ser.Serializer.SerializeMap := SerializeMap;
    serde.ser.Serializer.SerializeStruct := SerializeStruct;
    serde.ser.Serializer.SerializeStructVariant := SerializeStructVariant;
    serde.ser.Serializer.serialize_unit_variant := serialize_unit_variant;
    serde.ser.Serializer.serialize_newtype_struct
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_newtype_struct (T := T);
    serde.ser.Serializer.serialize_bool := serialize_bool;
    serde.ser.Serializer.serialize_i8 := serialize_i8;
    serde.ser.Serializer.serialize_i16 := serialize_i16;
    serde.ser.Serializer.serialize_i32 := serialize_i32;
    serde.ser.Serializer.serialize_i64 := serialize_i64;
    serde.ser.Serializer.serialize_u8 := serialize_u8;
    serde.ser.Serializer.serialize_u16 := serialize_u16;
    serde.ser.Serializer.serialize_u32 := serialize_u32;
    serde.ser.Serializer.serialize_u64 := serialize_u64;
    serde.ser.Serializer.serialize_f32 := serialize_f32;
    serde.ser.Serializer.serialize_f64 := serialize_f64;
    serde.ser.Serializer.serialize_char := serialize_char;
    serde.ser.Serializer.serialize_str := serialize_str;
    serde.ser.Serializer.serialize_bytes := serialize_bytes;
    serde.ser.Serializer.serialize_unit := serialize_unit;
    serde.ser.Serializer.serialize_unit_struct := serialize_unit_struct;
    serde.ser.Serializer.serialize_newtype_variant
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_newtype_variant (T := T);
    serde.ser.Serializer.serialize_none := serialize_none;
    serde.ser.Serializer.serialize_some
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_some (T := T);
    serde.ser.Serializer.serialize_seq := serialize_seq;
    serde.ser.Serializer.serialize_tuple := serialize_tuple;
    serde.ser.Serializer.serialize_tuple_struct := serialize_tuple_struct;
    serde.ser.Serializer.serialize_tuple_variant := serialize_tuple_variant;
    serde.ser.Serializer.serialize_map := serialize_map;
    serde.ser.Serializer.serialize_struct := serialize_struct;
    serde.ser.Serializer.serialize_struct_variant := serialize_struct_variant;
    serde.ser.Serializer.collect_str
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :=
      Datatypes.Some (collect_str (T := T));
    serde.ser.Serializer.serialize_i128 := Datatypes.None;
    serde.ser.Serializer.serialize_u128 := Datatypes.None;
    serde.ser.Serializer.collect_seq := Datatypes.None;
    serde.ser.Serializer.collect_map := Datatypes.None;
    serde.ser.Serializer.is_human_readable := Datatypes.None;
  }.
End Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.
End Impl_serde_ser_Serializer_for_serde_json_value_ser_MapKeySerializer_t.

Module  Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
Section Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
  Definition Self : Set := serde_json.value.ser.SerializeMap.t.
  
  (*
      type Ok = Value;
  *)
  Definition Ok : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          match self {
              SerializeMap::Map { .. } => serde::ser::SerializeMap::serialize_entry(self, key, value),
              #[cfg(feature = "arbitrary_precision")]
              SerializeMap::Number { out_value } => {
                  if key == crate::number::TOKEN {
                      *out_value = Some(tri!(value.serialize(NumberValueEmitter)));
                      Ok(())
                  } else {
                      Err(invalid_number())
                  }
              }
              #[cfg(feature = "raw_value")]
              SerializeMap::RawValue { out_value } => {
                  if key == crate::raw::TOKEN {
                      *out_value = Some(tri!(value.serialize(RawValueEmitter)));
                      Ok(())
                  } else {
                      Err(invalid_raw_value())
                  }
              }
          }
      }
  *)
  Definition serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (key : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_field" := {
    Notations.double_colon := serialize_field (T := T);
  }.
  
  (*
      fn end(self) -> Result<Value> {
          match self {
              SerializeMap::Map { .. } => serde::ser::SerializeMap::end(self),
              #[cfg(feature = "arbitrary_precision")]
              SerializeMap::Number { out_value, .. } => {
                  Ok(out_value.expect("number value was not emitted"))
              }
              #[cfg(feature = "raw_value")]
              SerializeMap::RawValue { out_value, .. } => {
                  Ok(out_value.expect("raw value was not emitted"))
              }
          }
      }
  *)
  Definition end_
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeStruct.Required.Trait Self := {
    serde.ser.SerializeStruct.Ok := Ok;
    serde.ser.SerializeStruct.Error := Error;
    serde.ser.SerializeStruct.serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_field (T := T);
    serde.ser.SerializeStruct.end_ := end_;
    serde.ser.SerializeStruct.skip_field := Datatypes.None;
  }.
End Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.
End Impl_serde_ser_SerializeStruct_for_serde_json_value_ser_SerializeMap_t.

Module  Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
Section Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
  Definition Self : Set := serde_json.value.ser.SerializeStructVariant.t.
  
  (*
      type Ok = Value;
  *)
  Definition Ok : Set := serde_json.value.Value.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
      fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>
      where
          T: ?Sized + Serialize,
      {
          self.map.insert(String::from(key), tri!(to_value(value)));
          Ok(())
      }
  *)
  Definition serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : mut_ref Self)
      (key : ref str.t)
      (value : ref T)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    let* key := M.alloc key in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "serialize_field" := {
    Notations.double_colon := serialize_field (T := T);
  }.
  
  (*
      fn end(self) -> Result<Value> {
          let mut object = Map::new();
  
          object.insert(self.name, Value::Object(self.map));
  
          Ok(Value::Object(object))
      }
  *)
  Definition end_
      (self : Self)
      : M ltac:(serde_json.error.Result serde_json.value.Value.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_end_ :
    Notations.DoubleColon Self "end_" := {
    Notations.double_colon := end_;
  }.
  
  Global Instance ℐ : serde.ser.SerializeStructVariant.Required.Trait Self := {
    serde.ser.SerializeStructVariant.Ok := Ok;
    serde.ser.SerializeStructVariant.Error := Error;
    serde.ser.SerializeStructVariant.serialize_field
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :=
      serialize_field (T := T);
    serde.ser.SerializeStructVariant.end_ := end_;
    serde.ser.SerializeStructVariant.skip_field := Datatypes.None;
  }.
End Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.
End Impl_serde_ser_SerializeStructVariant_for_serde_json_value_ser_SerializeStructVariant_t.

(*
pub fn to_value<T>(value: T) -> Result<Value, Error>
where
    T: Serialize,
{
    value.serialize(Serializer)
}
*)
Definition to_value
    {T : Set}
    {ℋ_0 : serde.ser.Serialize.Trait T}
    (value : T)
    :
      M
        (core.result.Result.t
          serde_json.value.Value.t
          serde_json.error.Error.t) :=
  let* value := M.alloc value in
  M.read foo.

(*
pub fn from_value<T>(value: Value) -> Result<T, Error>
where
    T: DeserializeOwned,
{
    T::deserialize(value)
}
*)
Definition from_value
    {T : Set}
    {ℋ_0 : serde.de.DeserializeOwned.Trait T}
    (value : serde_json.value.Value.t)
    : M (core.result.Result.t T serde_json.error.Error.t) :=
  let* value := M.alloc value in
  M.read foo.

Module iter.
  Module  LineColIterator.
  Section LineColIterator.
    Context (I : Set).
    
    Record t : Set := {
      iter : I;
      line : usize.t;
      col : usize.t;
      start_of_line : usize.t;
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
    Definition Get_line :=
      Ref.map (fun α => Some α.(line)) (fun β α => Some (α <| line := β |>)).
    Definition Get_col :=
      Ref.map (fun α => Some α.(col)) (fun β α => Some (α <| col := β |>)).
    Definition Get_start_of_line :=
      Ref.map
        (fun α => Some α.(start_of_line))
        (fun β α => Some (α <| start_of_line := β |>)).
  End LineColIterator.
  End LineColIterator.
  
  Module  Impl_serde_json_iter_LineColIterator_t_I.
  Section Impl_serde_json_iter_LineColIterator_t_I.
    Context {I : Set}.
    
    Definition Self : Set := serde_json.iter.LineColIterator.t I.
    
    (*
        pub fn new(iter: I) -> LineColIterator<I> {
            LineColIterator {
                iter,
                line: 1,
                col: 0,
                start_of_line: 0,
            }
        }
    *)
    Definition new (iter : I) : M (serde_json.iter.LineColIterator.t I) :=
      let* iter := M.alloc iter in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        pub fn line(&self) -> usize {
            self.line
        }
    *)
    Definition line (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_line :
      Notations.DoubleColon Self "line" := {
      Notations.double_colon := line;
    }.
    
    (*
        pub fn col(&self) -> usize {
            self.col
        }
    *)
    Definition col (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_col :
      Notations.DoubleColon Self "col" := {
      Notations.double_colon := col;
    }.
    
    (*
        pub fn byte_offset(&self) -> usize {
            self.start_of_line + self.col
        }
    *)
    Definition byte_offset (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_byte_offset :
      Notations.DoubleColon Self "byte_offset" := {
      Notations.double_colon := byte_offset;
    }.
  End Impl_serde_json_iter_LineColIterator_t_I.
  End Impl_serde_json_iter_LineColIterator_t_I.
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_iter_LineColIterator_t_I.
  Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_iter_LineColIterator_t_I.
    Context {I : Set}.
    
    Context {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}.
    
    Definition Self : Set := serde_json.iter.LineColIterator.t I.
    
    (*
        type Item = io::Result<u8>;
    *)
    Definition Item : Set := ltac:(std.io.error.Result u8.t).
    
    (*
        fn next(&mut self) -> Option<io::Result<u8>> {
            match self.iter.next() {
                None => None,
                Some(Ok(b'\n')) => {
                    self.start_of_line += self.col + 1;
                    self.line += 1;
                    self.col = 0;
                    Some(Ok(b'\n'))
                }
                Some(Ok(c)) => {
                    self.col += 1;
                    Some(Ok(c))
                }
                Some(Err(e)) => Some(Err(e)),
            }
        }
    *)
    Definition next
        (self : mut_ref Self)
        : M (core.option.Option.t ltac:(std.io.error.Result u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_iter_LineColIterator_t_I.
  End Impl_core_iter_traits_iterator_Iterator_for_serde_json_iter_LineColIterator_t_I.
End iter.

Module  LineColIterator.
Section LineColIterator.
  Context (I : Set).
  
  Record t : Set := {
    iter : I;
    line : usize.t;
    col : usize.t;
    start_of_line : usize.t;
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  Definition Get_line :=
    Ref.map (fun α => Some α.(line)) (fun β α => Some (α <| line := β |>)).
  Definition Get_col :=
    Ref.map (fun α => Some α.(col)) (fun β α => Some (α <| col := β |>)).
  Definition Get_start_of_line :=
    Ref.map
      (fun α => Some α.(start_of_line))
      (fun β α => Some (α <| start_of_line := β |>)).
End LineColIterator.
End LineColIterator.

Module  Impl_serde_json_iter_LineColIterator_t_I_2.
Section Impl_serde_json_iter_LineColIterator_t_I_2.
  Context {I : Set}.
  
  Definition Self : Set := serde_json.iter.LineColIterator.t I.
  
  (*
      pub fn new(iter: I) -> LineColIterator<I> {
          LineColIterator {
              iter,
              line: 1,
              col: 0,
              start_of_line: 0,
          }
      }
  *)
  Definition new (iter : I) : M (serde_json.iter.LineColIterator.t I) :=
    let* iter := M.alloc iter in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn line(&self) -> usize {
          self.line
      }
  *)
  Definition line (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_line :
    Notations.DoubleColon Self "line" := {
    Notations.double_colon := line;
  }.
  
  (*
      pub fn col(&self) -> usize {
          self.col
      }
  *)
  Definition col (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_col : Notations.DoubleColon Self "col" := {
    Notations.double_colon := col;
  }.
  
  (*
      pub fn byte_offset(&self) -> usize {
          self.start_of_line + self.col
      }
  *)
  Definition byte_offset (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_byte_offset :
    Notations.DoubleColon Self "byte_offset" := {
    Notations.double_colon := byte_offset;
  }.
End Impl_serde_json_iter_LineColIterator_t_I_2.
End Impl_serde_json_iter_LineColIterator_t_I_2.

Module  Impl_core_iter_traits_iterator_Iterator_for_serde_json_iter_LineColIterator_t_I.
Section Impl_core_iter_traits_iterator_Iterator_for_serde_json_iter_LineColIterator_t_I.
  Context {I : Set}.
  
  Context {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}.
  
  Definition Self : Set := serde_json.iter.LineColIterator.t I.
  
  (*
      type Item = io::Result<u8>;
  *)
  Definition Item : Set := ltac:(std.io.error.Result u8.t).
  
  (*
      fn next(&mut self) -> Option<io::Result<u8>> {
          match self.iter.next() {
              None => None,
              Some(Ok(b'\n')) => {
                  self.start_of_line += self.col + 1;
                  self.line += 1;
                  self.col = 0;
                  Some(Ok(b'\n'))
              }
              Some(Ok(c)) => {
                  self.col += 1;
                  Some(Ok(c))
              }
              Some(Err(e)) => Some(Err(e)),
          }
      }
  *)
  Definition next
      (self : mut_ref Self)
      : M (core.option.Option.t ltac:(std.io.error.Result u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_iter_LineColIterator_t_I.
End Impl_core_iter_traits_iterator_Iterator_for_serde_json_iter_LineColIterator_t_I.

Module number.
  Module  Number.
  Section Number.
    Record t : Set := {
      n : serde_json.number.N.t;
    }.
    
    Definition Get_n :=
      Ref.map (fun α => Some α.(n)) (fun β α => Some (α <| n := β |>)).
  End Number.
  End Number.
  
  Module  Impl_core_clone_Clone_for_serde_json_number_Number_t.
  Section Impl_core_clone_Clone_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M serde_json.number.Number.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_serde_json_number_Number_t.
  End Impl_core_clone_Clone_for_serde_json_number_Number_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_serde_json_number_Number_t.
  Section Impl_core_marker_StructuralPartialEq_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_serde_json_number_Number_t.
  End Impl_core_marker_StructuralPartialEq_for_serde_json_number_Number_t.
  
  Module  Impl_core_cmp_PartialEq_for_serde_json_number_Number_t.
  Section Impl_core_cmp_PartialEq_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref serde_json.number.Number.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_serde_json_number_Number_t.
  End Impl_core_cmp_PartialEq_for_serde_json_number_Number_t.
  
  Module  Impl_core_marker_StructuralEq_for_serde_json_number_Number_t.
  Section Impl_core_marker_StructuralEq_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralEq_for_serde_json_number_Number_t.
  End Impl_core_marker_StructuralEq_for_serde_json_number_Number_t.
  
  Module  Impl_core_cmp_Eq_for_serde_json_number_Number_t.
  Section Impl_core_cmp_Eq_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
    Eq
    *)
    Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_assert_receiver_is_total_eq :
      Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
      Notations.double_colon := assert_receiver_is_total_eq;
    }.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq :=
        Datatypes.Some assert_receiver_is_total_eq;
    }.
  End Impl_core_cmp_Eq_for_serde_json_number_Number_t.
  End Impl_core_cmp_Eq_for_serde_json_number_Number_t.
  
  Module  Impl_core_hash_Hash_for_serde_json_number_Number_t.
  Section Impl_core_hash_Hash_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
    Hash
    *)
    Definition hash
        {__H : Set}
        {ℋ_0 : core.hash.Hasher.Trait __H}
        (self : ref Self)
        (state : mut_ref __H)
        : M unit :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_hash
        {__H : Set}
        {ℋ_0 : core.hash.Hasher.Trait __H} :
      Notations.DoubleColon Self "hash" := {
      Notations.double_colon := hash (__H := __H);
    }.
    
    Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
      core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
        hash (__H := __H);
      core.hash.Hash.hash_slice := Datatypes.None;
    }.
  End Impl_core_hash_Hash_for_serde_json_number_Number_t.
  End Impl_core_hash_Hash_for_serde_json_number_Number_t.
  
  Module N.
    Inductive t : Set :=
    | PosInt (_ : u64.t)
    | NegInt (_ : i64.t)
    | Float (_ : f64.t).
    
    Definition Get_PosInt_0 :=
      Ref.map
        (fun α => match α with | PosInt α0 => Some α0 | _ => None end)
        (fun β α => match α with | PosInt _ => Some (PosInt β) | _ => None end).
    
    Definition Get_NegInt_0 :=
      Ref.map
        (fun α => match α with | NegInt α0 => Some α0 | _ => None end)
        (fun β α => match α with | NegInt _ => Some (NegInt β) | _ => None end).
    
    Definition Get_Float_0 :=
      Ref.map
        (fun α => match α with | Float α0 => Some α0 | _ => None end)
        (fun β α => match α with | Float _ => Some (Float β) | _ => None end).
  End N.
  
  Module  Impl_core_marker_Copy_for_serde_json_number_N_t.
  Section Impl_core_marker_Copy_for_serde_json_number_N_t.
    Definition Self : Set := serde_json.number.N.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_serde_json_number_N_t.
  End Impl_core_marker_Copy_for_serde_json_number_N_t.
  
  Module  Impl_core_clone_Clone_for_serde_json_number_N_t.
  Section Impl_core_clone_Clone_for_serde_json_number_N_t.
    Definition Self : Set := serde_json.number.N.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M serde_json.number.N.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_serde_json_number_N_t.
  End Impl_core_clone_Clone_for_serde_json_number_N_t.
  
  Module  Impl_core_cmp_PartialEq_for_serde_json_number_N_t.
  Section Impl_core_cmp_PartialEq_for_serde_json_number_N_t.
    Definition Self : Set := serde_json.number.N.t.
    
    (*
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (N::PosInt(a), N::PosInt(b)) => a == b,
                (N::NegInt(a), N::NegInt(b)) => a == b,
                (N::Float(a), N::Float(b)) => a == b,
                _ => false,
            }
        }
    *)
    Definition eq (self : ref Self) (other : ref Self) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_serde_json_number_N_t.
  End Impl_core_cmp_PartialEq_for_serde_json_number_N_t.
  
  Module  Impl_core_cmp_Eq_for_serde_json_number_N_t.
  Section Impl_core_cmp_Eq_for_serde_json_number_N_t.
    Definition Self : Set := serde_json.number.N.t.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
    }.
  End Impl_core_cmp_Eq_for_serde_json_number_N_t.
  End Impl_core_cmp_Eq_for_serde_json_number_N_t.
  
  Module  Impl_core_hash_Hash_for_serde_json_number_N_t.
  Section Impl_core_hash_Hash_for_serde_json_number_N_t.
    Definition Self : Set := serde_json.number.N.t.
    
    (*
        fn hash<H: Hasher>(&self, h: &mut H) {
            match *self {
                N::PosInt(i) => i.hash(h),
                N::NegInt(i) => i.hash(h),
                N::Float(f) => {
                    if f == 0.0f64 {
                        // There are 2 zero representations, +0 and -0, which
                        // compare equal but have different bits. We use the +0 hash
                        // for both so that hash(+0) == hash(-0).
                        0.0f64.to_bits().hash(h);
                    } else {
                        f.to_bits().hash(h);
                    }
                }
            }
        }
    *)
    Definition hash
        {H : Set}
        {ℋ_0 : core.hash.Hasher.Trait H}
        (self : ref Self)
        (h : mut_ref H)
        : M unit :=
      let* self := M.alloc self in
      let* h := M.alloc h in
      M.read foo.
    
    Global Instance AssociatedFunction_hash
        {H : Set}
        {ℋ_0 : core.hash.Hasher.Trait H} :
      Notations.DoubleColon Self "hash" := {
      Notations.double_colon := hash (H := H);
    }.
    
    Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
      core.hash.Hash.hash {H : Set} {ℋ_0 : core.hash.Hasher.Trait H} :=
        hash (H := H);
      core.hash.Hash.hash_slice := Datatypes.None;
    }.
  End Impl_core_hash_Hash_for_serde_json_number_N_t.
  End Impl_core_hash_Hash_for_serde_json_number_N_t.
  
  Module  Impl_serde_json_number_Number_t.
  Section Impl_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        pub fn is_i64(&self) -> bool {
            #[cfg(not(feature = "arbitrary_precision"))]
            match self.n {
                N::PosInt(v) => v <= i64::max_value() as u64,
                N::NegInt(_) => true,
                N::Float(_) => false,
            }
            #[cfg(feature = "arbitrary_precision")]
            self.as_i64().is_some()
        }
    *)
    Definition is_i64 (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_i64 :
      Notations.DoubleColon Self "is_i64" := {
      Notations.double_colon := is_i64;
    }.
    
    (*
        pub fn is_u64(&self) -> bool {
            #[cfg(not(feature = "arbitrary_precision"))]
            match self.n {
                N::PosInt(_) => true,
                N::NegInt(_) | N::Float(_) => false,
            }
            #[cfg(feature = "arbitrary_precision")]
            self.as_u64().is_some()
        }
    *)
    Definition is_u64 (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_u64 :
      Notations.DoubleColon Self "is_u64" := {
      Notations.double_colon := is_u64;
    }.
    
    (*
        pub fn is_f64(&self) -> bool {
            #[cfg(not(feature = "arbitrary_precision"))]
            match self.n {
                N::Float(_) => true,
                N::PosInt(_) | N::NegInt(_) => false,
            }
            #[cfg(feature = "arbitrary_precision")]
            {
                for c in self.n.chars() {
                    if c == '.' || c == 'e' || c == 'E' {
                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);
                    }
                }
                false
            }
        }
    *)
    Definition is_f64 (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_f64 :
      Notations.DoubleColon Self "is_f64" := {
      Notations.double_colon := is_f64;
    }.
    
    (*
        pub fn as_i64(&self) -> Option<i64> {
            #[cfg(not(feature = "arbitrary_precision"))]
            match self.n {
                N::PosInt(n) => {
                    if n <= i64::max_value() as u64 {
                        Some(n as i64)
                    } else {
                        None
                    }
                }
                N::NegInt(n) => Some(n),
                N::Float(_) => None,
            }
            #[cfg(feature = "arbitrary_precision")]
            self.n.parse().ok()
        }
    *)
    Definition as_i64 (self : ref Self) : M (core.option.Option.t i64.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_i64 :
      Notations.DoubleColon Self "as_i64" := {
      Notations.double_colon := as_i64;
    }.
    
    (*
        pub fn as_u64(&self) -> Option<u64> {
            #[cfg(not(feature = "arbitrary_precision"))]
            match self.n {
                N::PosInt(n) => Some(n),
                N::NegInt(_) | N::Float(_) => None,
            }
            #[cfg(feature = "arbitrary_precision")]
            self.n.parse().ok()
        }
    *)
    Definition as_u64 (self : ref Self) : M (core.option.Option.t u64.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_u64 :
      Notations.DoubleColon Self "as_u64" := {
      Notations.double_colon := as_u64;
    }.
    
    (*
        pub fn as_f64(&self) -> Option<f64> {
            #[cfg(not(feature = "arbitrary_precision"))]
            match self.n {
                N::PosInt(n) => Some(n as f64),
                N::NegInt(n) => Some(n as f64),
                N::Float(n) => Some(n),
            }
            #[cfg(feature = "arbitrary_precision")]
            self.n.parse::<f64>().ok().filter(|float| float.is_finite())
        }
    *)
    Definition as_f64 (self : ref Self) : M (core.option.Option.t f64.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_f64 :
      Notations.DoubleColon Self "as_f64" := {
      Notations.double_colon := as_f64;
    }.
    
    (*
        pub fn from_f64(f: f64) -> Option<Number> {
            if f.is_finite() {
                let n = {
                    #[cfg(not(feature = "arbitrary_precision"))]
                    {
                        N::Float(f)
                    }
                    #[cfg(feature = "arbitrary_precision")]
                    {
                        ryu::Buffer::new().format_finite(f).to_owned()
                    }
                };
                Some(Number { n })
            } else {
                None
            }
        }
    *)
    Definition from_f64
        (f : f64.t)
        : M (core.option.Option.t serde_json.number.Number.t) :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from_f64 :
      Notations.DoubleColon Self "from_f64" := {
      Notations.double_colon := from_f64;
    }.
    
    (*
        pub(crate) fn as_f32(&self) -> Option<f32> {
            #[cfg(not(feature = "arbitrary_precision"))]
            match self.n {
                N::PosInt(n) => Some(n as f32),
                N::NegInt(n) => Some(n as f32),
                N::Float(n) => Some(n as f32),
            }
            #[cfg(feature = "arbitrary_precision")]
            self.n.parse::<f32>().ok().filter(|float| float.is_finite())
        }
    *)
    Definition as_f32 (self : ref Self) : M (core.option.Option.t f32.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_f32 :
      Notations.DoubleColon Self "as_f32" := {
      Notations.double_colon := as_f32;
    }.
    
    (*
        pub(crate) fn from_f32(f: f32) -> Option<Number> {
            if f.is_finite() {
                let n = {
                    #[cfg(not(feature = "arbitrary_precision"))]
                    {
                        N::Float(f as f64)
                    }
                    #[cfg(feature = "arbitrary_precision")]
                    {
                        ryu::Buffer::new().format_finite(f).to_owned()
                    }
                };
                Some(Number { n })
            } else {
                None
            }
        }
    *)
    Definition from_f32
        (f : f32.t)
        : M (core.option.Option.t serde_json.number.Number.t) :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_from_f32 :
      Notations.DoubleColon Self "from_f32" := {
      Notations.double_colon := from_f32;
    }.
  End Impl_serde_json_number_Number_t.
  End Impl_serde_json_number_Number_t.
  
  Module  Impl_core_fmt_Display_for_serde_json_number_Number_t.
  Section Impl_core_fmt_Display_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match self.n {
                N::PosInt(u) => formatter.write_str(itoa::Buffer::new().format(u)),
                N::NegInt(i) => formatter.write_str(itoa::Buffer::new().format(i)),
                N::Float(f) => formatter.write_str(ryu::Buffer::new().format_finite(f)),
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (formatter : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* formatter := M.alloc formatter in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_serde_json_number_Number_t.
  End Impl_core_fmt_Display_for_serde_json_number_Number_t.
  
  Module  Impl_core_fmt_Debug_for_serde_json_number_Number_t.
  Section Impl_core_fmt_Debug_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            write!(formatter, "Number({})", self)
        }
    *)
    Definition fmt
        (self : ref Self)
        (formatter : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* formatter := M.alloc formatter in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_serde_json_number_Number_t.
  End Impl_core_fmt_Debug_for_serde_json_number_Number_t.
  
  Module  Impl_serde_ser_Serialize_for_serde_json_number_Number_t.
  Section Impl_serde_ser_Serialize_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            match self.n {
                N::PosInt(u) => serializer.serialize_u64(u),
                N::NegInt(i) => serializer.serialize_i64(i),
                N::Float(f) => serializer.serialize_f64(f),
            }
        }
    *)
    Definition serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S}
        (self : ref Self)
        (serializer : S)
        : M (core.result.Result.t S::type["Ok"].t S::type["Error"].t) :=
      let* self := M.alloc self in
      let* serializer := M.alloc serializer in
      M.read foo.
    
    Global Instance AssociatedFunction_serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S} :
      Notations.DoubleColon Self "serialize" := {
      Notations.double_colon := serialize (S := S);
    }.
    
    Global Instance ℐ : serde.ser.Serialize.Trait Self := {
      serde.ser.Serialize.serialize
        {S : Set}
        {ℋ_0 : serde.ser.Serializer.Trait S} :=
        serialize (S := S);
    }.
  End Impl_serde_ser_Serialize_for_serde_json_number_Number_t.
  End Impl_serde_ser_Serialize_for_serde_json_number_Number_t.
  
  Module  Impl_serde_de_Deserialize_for_serde_json_number_Number_t.
  Section Impl_serde_de_Deserialize_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        fn deserialize<D>(deserializer: D) -> Result<Number, D::Error>
        where
            D: Deserializer<'de>,
        {
            struct NumberVisitor;
    
            impl<'de> Visitor<'de> for NumberVisitor {
                type Value = Number;
    
                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("a JSON number")
                }
    
                #[inline]
                fn visit_i64<E>(self, value: i64) -> Result<Number, E> {
                    Ok(value.into())
                }
    
                #[inline]
                fn visit_u64<E>(self, value: u64) -> Result<Number, E> {
                    Ok(value.into())
                }
    
                #[inline]
                fn visit_f64<E>(self, value: f64) -> Result<Number, E>
                where
                    E: de::Error,
                {
                    Number::from_f64(value).ok_or_else(|| de::Error::custom("not a JSON number"))
                }
    
                #[cfg(feature = "arbitrary_precision")]
                #[inline]
                fn visit_map<V>(self, mut visitor: V) -> Result<Number, V::Error>
                where
                    V: de::MapAccess<'de>,
                {
                    let value = tri!(visitor.next_key::<NumberKey>());
                    if value.is_none() {
                        return Err(de::Error::invalid_type(Unexpected::Map, &self));
                    }
                    let v: NumberFromString = tri!(visitor.next_value());
                    Ok(v.value)
                }
            }
    
            deserializer.deserialize_any(NumberVisitor)
        }
    *)
    Definition deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D}
        (deserializer : D)
        :
          M
            (core.result.Result.t
              serde_json.number.Number.t
              D::type["Error"].t) :=
      let* deserializer := M.alloc deserializer in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D} :
      Notations.DoubleColon Self "deserialize" := {
      Notations.double_colon := deserialize (D := D);
    }.
    
    Global Instance ℐ : serde.de.Deserialize.Required.Trait Self := {
      serde.de.Deserialize.deserialize
        {D : Set}
        {ℋ_0 : serde.de.Deserializer.Trait D} :=
        deserialize (D := D);
      serde.de.Deserialize.deserialize_in_place := Datatypes.None;
    }.
  End Impl_serde_de_Deserialize_for_serde_json_number_Number_t.
  End Impl_serde_de_Deserialize_for_serde_json_number_Number_t.
  
  Module  Impl_serde_de_Deserializer_for_serde_json_number_Number_t.
  Section Impl_serde_de_Deserializer_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
            fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self.n {
                    N::PosInt(u) => visitor.visit_u64(u),
                    N::NegInt(i) => visitor.visit_i64(i),
                    N::Float(f) => visitor.visit_f64(f),
                }
            }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (fields : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* fields := M.alloc fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (variants : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* variants := M.alloc variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_serde_json_number_Number_t.
  End Impl_serde_de_Deserializer_for_serde_json_number_Number_t.
  
  Module  Impl_serde_de_Deserializer_for_ref_serde_json_number_Number_t.
  Section Impl_serde_de_Deserializer_for_ref_serde_json_number_Number_t.
    Definition Self : Set := ref serde_json.number.Number.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := serde_json.error.Error.t.
    
    (*
            fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                match self.n {
                    N::PosInt(u) => visitor.visit_u64(u),
                    N::NegInt(i) => visitor.visit_i64(i),
                    N::Float(f) => visitor.visit_f64(f),
                }
            }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        :
          M
            (core.result.Result.t
              V::type["Value"].t
              serde_json.error.Error.t) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (fields : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* fields := M.alloc fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (variants : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* variants := M.alloc variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_ref_serde_json_number_Number_t.
  End Impl_serde_de_Deserializer_for_ref_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_serde_json_de_ParserNumber_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_serde_json_de_ParserNumber_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        fn from(value: ParserNumber) -> Self {
            let n = match value {
                ParserNumber::F64(f) => {
                    #[cfg(not(feature = "arbitrary_precision"))]
                    {
                        N::Float(f)
                    }
                    #[cfg(feature = "arbitrary_precision")]
                    {
                        f.to_string()
                    }
                }
                ParserNumber::U64(u) => {
                    #[cfg(not(feature = "arbitrary_precision"))]
                    {
                        N::PosInt(u)
                    }
                    #[cfg(feature = "arbitrary_precision")]
                    {
                        u.to_string()
                    }
                }
                ParserNumber::I64(i) => {
                    #[cfg(not(feature = "arbitrary_precision"))]
                    {
                        N::NegInt(i)
                    }
                    #[cfg(feature = "arbitrary_precision")]
                    {
                        i.to_string()
                    }
                }
                #[cfg(feature = "arbitrary_precision")]
                ParserNumber::String(s) => s,
            };
            Number { n }
        }
    *)
    Definition from (value : serde_json.de.ParserNumber.t) : M Self :=
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := serde_json.de.ParserNumber.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_serde_json_de_ParserNumber_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_serde_json_de_ParserNumber_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_u8_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_u8_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(u: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            { N::PosInt(u as u64) }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(u).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (u : u8.t) : M Self :=
      let* u := M.alloc u in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := u8.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_u8_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_u8_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_u16_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_u16_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(u: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            { N::PosInt(u as u64) }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(u).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (u : u16.t) : M Self :=
      let* u := M.alloc u in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := u16.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_u16_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_u16_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_u32_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_u32_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(u: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            { N::PosInt(u as u64) }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(u).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (u : u32.t) : M Self :=
      let* u := M.alloc u in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := u32.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_u32_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_u32_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_u64_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_u64_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(u: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            { N::PosInt(u as u64) }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(u).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (u : u64.t) : M Self :=
      let* u := M.alloc u in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := u64.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_u64_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_u64_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_usize_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_usize_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(u: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            { N::PosInt(u as u64) }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(u).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (u : usize.t) : M Self :=
      let* u := M.alloc u in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := usize.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_usize_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_usize_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_i8_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_i8_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(i: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            {
                                if i < 0 {
                                    N::NegInt(i as i64)
                                } else {
                                    N::PosInt(i as u64)
                                }
                            }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(i).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (i : i8.t) : M Self :=
      let* i := M.alloc i in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := i8.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_i8_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_i8_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_i16_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_i16_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(i: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            {
                                if i < 0 {
                                    N::NegInt(i as i64)
                                } else {
                                    N::PosInt(i as u64)
                                }
                            }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(i).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (i : i16.t) : M Self :=
      let* i := M.alloc i in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := i16.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_i16_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_i16_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_i32_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_i32_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(i: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            {
                                if i < 0 {
                                    N::NegInt(i as i64)
                                } else {
                                    N::PosInt(i as u64)
                                }
                            }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(i).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (i : i32.t) : M Self :=
      let* i := M.alloc i in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := i32.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_i32_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_i32_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_i64_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_i64_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(i: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            {
                                if i < 0 {
                                    N::NegInt(i as i64)
                                } else {
                                    N::PosInt(i as u64)
                                }
                            }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(i).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (i : i64.t) : M Self :=
      let* i := M.alloc i in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := i64.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_i64_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_i64_t_for_serde_json_number_Number_t.
  
  Module  Impl_core_convert_From_isize_t_for_serde_json_number_Number_t.
  Section Impl_core_convert_From_isize_t_for_serde_json_number_Number_t.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
                    fn from(i: $ty) -> Self {
                        let n = {
                            #[cfg(not(feature = "arbitrary_precision"))]
                            {
                                if i < 0 {
                                    N::NegInt(i as i64)
                                } else {
                                    N::PosInt(i as u64)
                                }
                            }
                            #[cfg(feature = "arbitrary_precision")]
                            {
                                itoa::Buffer::new().format(i).to_owned()
                            }
                        };
                        Number { n }
                    }
    *)
    Definition from (i : isize.t) : M Self :=
      let* i := M.alloc i in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := isize.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_isize_t_for_serde_json_number_Number_t.
  End Impl_core_convert_From_isize_t_for_serde_json_number_Number_t.
  
  Module  Impl_serde_json_number_Number_t_2.
  Section Impl_serde_json_number_Number_t_2.
    Definition Self : Set := serde_json.number.Number.t.
    
    (*
        pub(crate) fn unexpected(&self) -> Unexpected {
            match self.n {
                N::PosInt(u) => Unexpected::Unsigned(u),
                N::NegInt(i) => Unexpected::Signed(i),
                N::Float(f) => Unexpected::Float(f),
            }
        }
    *)
    Definition unexpected (self : ref Self) : M serde.de.Unexpected.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_unexpected :
      Notations.DoubleColon Self "unexpected" := {
      Notations.double_colon := unexpected;
    }.
  End Impl_serde_json_number_Number_t_2.
  End Impl_serde_json_number_Number_t_2.
End number.

Module  Number.
Section Number.
  Record t : Set := {
    n : serde_json.number.N.t;
  }.
  
  Definition Get_n :=
    Ref.map (fun α => Some α.(n)) (fun β α => Some (α <| n := β |>)).
End Number.
End Number.

Module  Impl_core_clone_Clone_for_serde_json_number_Number_t.
Section Impl_core_clone_Clone_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M serde_json.number.Number.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_serde_json_number_Number_t.
End Impl_core_clone_Clone_for_serde_json_number_Number_t.

Module  Impl_core_marker_StructuralPartialEq_for_serde_json_number_Number_t.
Section Impl_core_marker_StructuralPartialEq_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_serde_json_number_Number_t.
End Impl_core_marker_StructuralPartialEq_for_serde_json_number_Number_t.

Module  Impl_core_cmp_PartialEq_for_serde_json_number_Number_t.
Section Impl_core_cmp_PartialEq_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref serde_json.number.Number.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_serde_json_number_Number_t.
End Impl_core_cmp_PartialEq_for_serde_json_number_Number_t.

Module  Impl_core_marker_StructuralEq_for_serde_json_number_Number_t.
Section Impl_core_marker_StructuralEq_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_serde_json_number_Number_t.
End Impl_core_marker_StructuralEq_for_serde_json_number_Number_t.

Module  Impl_core_cmp_Eq_for_serde_json_number_Number_t.
Section Impl_core_cmp_Eq_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_serde_json_number_Number_t.
End Impl_core_cmp_Eq_for_serde_json_number_Number_t.

Module  Impl_core_hash_Hash_for_serde_json_number_Number_t.
Section Impl_core_hash_Hash_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
  Hash
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_serde_json_number_Number_t.
End Impl_core_hash_Hash_for_serde_json_number_Number_t.

Module N.
  Inductive t : Set :=
  | PosInt (_ : u64.t)
  | NegInt (_ : i64.t)
  | Float (_ : f64.t).
  
  Definition Get_PosInt_0 :=
    Ref.map
      (fun α => match α with | PosInt α0 => Some α0 | _ => None end)
      (fun β α => match α with | PosInt _ => Some (PosInt β) | _ => None end).
  
  Definition Get_NegInt_0 :=
    Ref.map
      (fun α => match α with | NegInt α0 => Some α0 | _ => None end)
      (fun β α => match α with | NegInt _ => Some (NegInt β) | _ => None end).
  
  Definition Get_Float_0 :=
    Ref.map
      (fun α => match α with | Float α0 => Some α0 | _ => None end)
      (fun β α => match α with | Float _ => Some (Float β) | _ => None end).
End N.

Module  Impl_core_marker_Copy_for_serde_json_number_N_t.
Section Impl_core_marker_Copy_for_serde_json_number_N_t.
  Definition Self : Set := serde_json.number.N.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_serde_json_number_N_t.
End Impl_core_marker_Copy_for_serde_json_number_N_t.

Module  Impl_core_clone_Clone_for_serde_json_number_N_t.
Section Impl_core_clone_Clone_for_serde_json_number_N_t.
  Definition Self : Set := serde_json.number.N.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M serde_json.number.N.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_serde_json_number_N_t.
End Impl_core_clone_Clone_for_serde_json_number_N_t.

Module  Impl_core_cmp_PartialEq_for_serde_json_number_N_t.
Section Impl_core_cmp_PartialEq_for_serde_json_number_N_t.
  Definition Self : Set := serde_json.number.N.t.
  
  (*
      fn eq(&self, other: &Self) -> bool {
          match (self, other) {
              (N::PosInt(a), N::PosInt(b)) => a == b,
              (N::NegInt(a), N::NegInt(b)) => a == b,
              (N::Float(a), N::Float(b)) => a == b,
              _ => false,
          }
      }
  *)
  Definition eq (self : ref Self) (other : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_serde_json_number_N_t.
End Impl_core_cmp_PartialEq_for_serde_json_number_N_t.

Module  Impl_core_cmp_Eq_for_serde_json_number_N_t.
Section Impl_core_cmp_Eq_for_serde_json_number_N_t.
  Definition Self : Set := serde_json.number.N.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_serde_json_number_N_t.
End Impl_core_cmp_Eq_for_serde_json_number_N_t.

Module  Impl_core_hash_Hash_for_serde_json_number_N_t.
Section Impl_core_hash_Hash_for_serde_json_number_N_t.
  Definition Self : Set := serde_json.number.N.t.
  
  (*
      fn hash<H: Hasher>(&self, h: &mut H) {
          match *self {
              N::PosInt(i) => i.hash(h),
              N::NegInt(i) => i.hash(h),
              N::Float(f) => {
                  if f == 0.0f64 {
                      // There are 2 zero representations, +0 and -0, which
                      // compare equal but have different bits. We use the +0 hash
                      // for both so that hash(+0) == hash(-0).
                      0.0f64.to_bits().hash(h);
                  } else {
                      f.to_bits().hash(h);
                  }
              }
          }
      }
  *)
  Definition hash
      {H : Set}
      {ℋ_0 : core.hash.Hasher.Trait H}
      (self : ref Self)
      (h : mut_ref H)
      : M unit :=
    let* self := M.alloc self in
    let* h := M.alloc h in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {H : Set}
      {ℋ_0 : core.hash.Hasher.Trait H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (H := H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {H : Set} {ℋ_0 : core.hash.Hasher.Trait H} :=
      hash (H := H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_serde_json_number_N_t.
End Impl_core_hash_Hash_for_serde_json_number_N_t.

Module  Impl_serde_json_number_Number_t_3.
Section Impl_serde_json_number_Number_t_3.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      pub fn is_i64(&self) -> bool {
          #[cfg(not(feature = "arbitrary_precision"))]
          match self.n {
              N::PosInt(v) => v <= i64::max_value() as u64,
              N::NegInt(_) => true,
              N::Float(_) => false,
          }
          #[cfg(feature = "arbitrary_precision")]
          self.as_i64().is_some()
      }
  *)
  Definition is_i64 (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_i64 :
    Notations.DoubleColon Self "is_i64" := {
    Notations.double_colon := is_i64;
  }.
  
  (*
      pub fn is_u64(&self) -> bool {
          #[cfg(not(feature = "arbitrary_precision"))]
          match self.n {
              N::PosInt(_) => true,
              N::NegInt(_) | N::Float(_) => false,
          }
          #[cfg(feature = "arbitrary_precision")]
          self.as_u64().is_some()
      }
  *)
  Definition is_u64 (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_u64 :
    Notations.DoubleColon Self "is_u64" := {
    Notations.double_colon := is_u64;
  }.
  
  (*
      pub fn is_f64(&self) -> bool {
          #[cfg(not(feature = "arbitrary_precision"))]
          match self.n {
              N::Float(_) => true,
              N::PosInt(_) | N::NegInt(_) => false,
          }
          #[cfg(feature = "arbitrary_precision")]
          {
              for c in self.n.chars() {
                  if c == '.' || c == 'e' || c == 'E' {
                      return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);
                  }
              }
              false
          }
      }
  *)
  Definition is_f64 (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_f64 :
    Notations.DoubleColon Self "is_f64" := {
    Notations.double_colon := is_f64;
  }.
  
  (*
      pub fn as_i64(&self) -> Option<i64> {
          #[cfg(not(feature = "arbitrary_precision"))]
          match self.n {
              N::PosInt(n) => {
                  if n <= i64::max_value() as u64 {
                      Some(n as i64)
                  } else {
                      None
                  }
              }
              N::NegInt(n) => Some(n),
              N::Float(_) => None,
          }
          #[cfg(feature = "arbitrary_precision")]
          self.n.parse().ok()
      }
  *)
  Definition as_i64 (self : ref Self) : M (core.option.Option.t i64.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_i64 :
    Notations.DoubleColon Self "as_i64" := {
    Notations.double_colon := as_i64;
  }.
  
  (*
      pub fn as_u64(&self) -> Option<u64> {
          #[cfg(not(feature = "arbitrary_precision"))]
          match self.n {
              N::PosInt(n) => Some(n),
              N::NegInt(_) | N::Float(_) => None,
          }
          #[cfg(feature = "arbitrary_precision")]
          self.n.parse().ok()
      }
  *)
  Definition as_u64 (self : ref Self) : M (core.option.Option.t u64.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_u64 :
    Notations.DoubleColon Self "as_u64" := {
    Notations.double_colon := as_u64;
  }.
  
  (*
      pub fn as_f64(&self) -> Option<f64> {
          #[cfg(not(feature = "arbitrary_precision"))]
          match self.n {
              N::PosInt(n) => Some(n as f64),
              N::NegInt(n) => Some(n as f64),
              N::Float(n) => Some(n),
          }
          #[cfg(feature = "arbitrary_precision")]
          self.n.parse::<f64>().ok().filter(|float| float.is_finite())
      }
  *)
  Definition as_f64 (self : ref Self) : M (core.option.Option.t f64.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_f64 :
    Notations.DoubleColon Self "as_f64" := {
    Notations.double_colon := as_f64;
  }.
  
  (*
      pub fn from_f64(f: f64) -> Option<Number> {
          if f.is_finite() {
              let n = {
                  #[cfg(not(feature = "arbitrary_precision"))]
                  {
                      N::Float(f)
                  }
                  #[cfg(feature = "arbitrary_precision")]
                  {
                      ryu::Buffer::new().format_finite(f).to_owned()
                  }
              };
              Some(Number { n })
          } else {
              None
          }
      }
  *)
  Definition from_f64
      (f : f64.t)
      : M (core.option.Option.t serde_json.number.Number.t) :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from_f64 :
    Notations.DoubleColon Self "from_f64" := {
    Notations.double_colon := from_f64;
  }.
  
  (*
      pub(crate) fn as_f32(&self) -> Option<f32> {
          #[cfg(not(feature = "arbitrary_precision"))]
          match self.n {
              N::PosInt(n) => Some(n as f32),
              N::NegInt(n) => Some(n as f32),
              N::Float(n) => Some(n as f32),
          }
          #[cfg(feature = "arbitrary_precision")]
          self.n.parse::<f32>().ok().filter(|float| float.is_finite())
      }
  *)
  Definition as_f32 (self : ref Self) : M (core.option.Option.t f32.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_f32 :
    Notations.DoubleColon Self "as_f32" := {
    Notations.double_colon := as_f32;
  }.
  
  (*
      pub(crate) fn from_f32(f: f32) -> Option<Number> {
          if f.is_finite() {
              let n = {
                  #[cfg(not(feature = "arbitrary_precision"))]
                  {
                      N::Float(f as f64)
                  }
                  #[cfg(feature = "arbitrary_precision")]
                  {
                      ryu::Buffer::new().format_finite(f).to_owned()
                  }
              };
              Some(Number { n })
          } else {
              None
          }
      }
  *)
  Definition from_f32
      (f : f32.t)
      : M (core.option.Option.t serde_json.number.Number.t) :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_from_f32 :
    Notations.DoubleColon Self "from_f32" := {
    Notations.double_colon := from_f32;
  }.
End Impl_serde_json_number_Number_t_3.
End Impl_serde_json_number_Number_t_3.

Module  Impl_core_fmt_Display_for_serde_json_number_Number_t.
Section Impl_core_fmt_Display_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
          match self.n {
              N::PosInt(u) => formatter.write_str(itoa::Buffer::new().format(u)),
              N::NegInt(i) => formatter.write_str(itoa::Buffer::new().format(i)),
              N::Float(f) => formatter.write_str(ryu::Buffer::new().format_finite(f)),
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_serde_json_number_Number_t.
End Impl_core_fmt_Display_for_serde_json_number_Number_t.

Module  Impl_core_fmt_Debug_for_serde_json_number_Number_t.
Section Impl_core_fmt_Debug_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
          write!(formatter, "Number({})", self)
      }
  *)
  Definition fmt
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_serde_json_number_Number_t.
End Impl_core_fmt_Debug_for_serde_json_number_Number_t.

Module  Impl_serde_ser_Serialize_for_serde_json_number_Number_t.
Section Impl_serde_ser_Serialize_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
      where
          S: Serializer,
      {
          match self.n {
              N::PosInt(u) => serializer.serialize_u64(u),
              N::NegInt(i) => serializer.serialize_i64(i),
              N::Float(f) => serializer.serialize_f64(f),
          }
      }
  *)
  Definition serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S}
      (self : ref Self)
      (serializer : S)
      : M (core.result.Result.t S::type["Ok"].t S::type["Error"].t) :=
    let* self := M.alloc self in
    let* serializer := M.alloc serializer in
    M.read foo.
  
  Global Instance AssociatedFunction_serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S} :
    Notations.DoubleColon Self "serialize" := {
    Notations.double_colon := serialize (S := S);
  }.
  
  Global Instance ℐ : serde.ser.Serialize.Trait Self := {
    serde.ser.Serialize.serialize
      {S : Set}
      {ℋ_0 : serde.ser.Serializer.Trait S} :=
      serialize (S := S);
  }.
End Impl_serde_ser_Serialize_for_serde_json_number_Number_t.
End Impl_serde_ser_Serialize_for_serde_json_number_Number_t.

Module  Impl_serde_de_Deserialize_for_serde_json_number_Number_t.
Section Impl_serde_de_Deserialize_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      fn deserialize<D>(deserializer: D) -> Result<Number, D::Error>
      where
          D: Deserializer<'de>,
      {
          struct NumberVisitor;
  
          impl<'de> Visitor<'de> for NumberVisitor {
              type Value = Number;
  
              fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                  formatter.write_str("a JSON number")
              }
  
              #[inline]
              fn visit_i64<E>(self, value: i64) -> Result<Number, E> {
                  Ok(value.into())
              }
  
              #[inline]
              fn visit_u64<E>(self, value: u64) -> Result<Number, E> {
                  Ok(value.into())
              }
  
              #[inline]
              fn visit_f64<E>(self, value: f64) -> Result<Number, E>
              where
                  E: de::Error,
              {
                  Number::from_f64(value).ok_or_else(|| de::Error::custom("not a JSON number"))
              }
  
              #[cfg(feature = "arbitrary_precision")]
              #[inline]
              fn visit_map<V>(self, mut visitor: V) -> Result<Number, V::Error>
              where
                  V: de::MapAccess<'de>,
              {
                  let value = tri!(visitor.next_key::<NumberKey>());
                  if value.is_none() {
                      return Err(de::Error::invalid_type(Unexpected::Map, &self));
                  }
                  let v: NumberFromString = tri!(visitor.next_value());
                  Ok(v.value)
              }
          }
  
          deserializer.deserialize_any(NumberVisitor)
      }
  *)
  Definition deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D}
      (deserializer : D)
      :
        M
          (core.result.Result.t
            serde_json.number.Number.t
            D::type["Error"].t) :=
    let* deserializer := M.alloc deserializer in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :
    Notations.DoubleColon Self "deserialize" := {
    Notations.double_colon := deserialize (D := D);
  }.
  
  Global Instance ℐ : serde.de.Deserialize.Required.Trait Self := {
    serde.de.Deserialize.deserialize
      {D : Set}
      {ℋ_0 : serde.de.Deserializer.Trait D} :=
      deserialize (D := D);
    serde.de.Deserialize.deserialize_in_place := Datatypes.None;
  }.
End Impl_serde_de_Deserialize_for_serde_json_number_Number_t.
End Impl_serde_de_Deserialize_for_serde_json_number_Number_t.

Module  NumberVisitor.
Section NumberVisitor.
  Inductive t : Set := Build.
End NumberVisitor.
End NumberVisitor.

Module  Impl_serde_de_Visitor_for_serde_json_number_deserialize_NumberVisitor_t.
Section Impl_serde_de_Visitor_for_serde_json_number_deserialize_NumberVisitor_t.
  Definition Self : Set := serde_json.number.deserialize.NumberVisitor.t.
  
  (*
              type Value = Number;
  *)
  Definition Value : Set := serde_json.number.Number.t.
  
  (*
              fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                  formatter.write_str("a JSON number")
              }
  *)
  Definition expecting
      (self : ref Self)
      (formatter : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* formatter := M.alloc formatter in
    M.read foo.
  
  Global Instance AssociatedFunction_expecting :
    Notations.DoubleColon Self "expecting" := {
    Notations.double_colon := expecting;
  }.
  
  (*
              fn visit_i64<E>(self, value: i64) -> Result<Number, E> {
                  Ok(value.into())
              }
  *)
  Definition visit_i64
      {E : Set}
      (self : Self)
      (value : i64.t)
      : M (core.result.Result.t serde_json.number.Number.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_i64 {E : Set} :
    Notations.DoubleColon Self "visit_i64" := {
    Notations.double_colon := visit_i64 (E := E);
  }.
  
  (*
              fn visit_u64<E>(self, value: u64) -> Result<Number, E> {
                  Ok(value.into())
              }
  *)
  Definition visit_u64
      {E : Set}
      (self : Self)
      (value : u64.t)
      : M (core.result.Result.t serde_json.number.Number.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_u64 {E : Set} :
    Notations.DoubleColon Self "visit_u64" := {
    Notations.double_colon := visit_u64 (E := E);
  }.
  
  (*
              fn visit_f64<E>(self, value: f64) -> Result<Number, E>
              where
                  E: de::Error,
              {
                  Number::from_f64(value).ok_or_else(|| de::Error::custom("not a JSON number"))
              }
  *)
  Definition visit_f64
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E}
      (self : Self)
      (value : f64.t)
      : M (core.result.Result.t serde_json.number.Number.t E) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_visit_f64
      {E : Set}
      {ℋ_0 : serde.de.Error.Trait E} :
    Notations.DoubleColon Self "visit_f64" := {
    Notations.double_colon := visit_f64 (E := E);
  }.
  
  Global Instance ℐ : serde.de.Visitor.Required.Trait Self := {
    serde.de.Visitor.Value := Value;
    serde.de.Visitor.expecting := expecting;
    serde.de.Visitor.visit_i64 {E : Set} := Datatypes.Some (visit_i64 (E := E));
    serde.de.Visitor.visit_u64 {E : Set} := Datatypes.Some (visit_u64 (E := E));
    serde.de.Visitor.visit_f64 {E : Set} {ℋ_0 : serde.de.Error.Trait E} :=
      Datatypes.Some (visit_f64 (E := E));
    serde.de.Visitor.visit_bool := Datatypes.None;
    serde.de.Visitor.visit_i8 := Datatypes.None;
    serde.de.Visitor.visit_i16 := Datatypes.None;
    serde.de.Visitor.visit_i32 := Datatypes.None;
    serde.de.Visitor.visit_i128 := Datatypes.None;
    serde.de.Visitor.visit_u8 := Datatypes.None;
    serde.de.Visitor.visit_u16 := Datatypes.None;
    serde.de.Visitor.visit_u32 := Datatypes.None;
    serde.de.Visitor.visit_u128 := Datatypes.None;
    serde.de.Visitor.visit_f32 := Datatypes.None;
    serde.de.Visitor.visit_char := Datatypes.None;
    serde.de.Visitor.visit_str := Datatypes.None;
    serde.de.Visitor.visit_borrowed_str := Datatypes.None;
    serde.de.Visitor.visit_string := Datatypes.None;
    serde.de.Visitor.visit_bytes := Datatypes.None;
    serde.de.Visitor.visit_borrowed_bytes := Datatypes.None;
    serde.de.Visitor.visit_byte_buf := Datatypes.None;
    serde.de.Visitor.visit_none := Datatypes.None;
    serde.de.Visitor.visit_some := Datatypes.None;
    serde.de.Visitor.visit_unit := Datatypes.None;
    serde.de.Visitor.visit_newtype_struct := Datatypes.None;
    serde.de.Visitor.visit_seq := Datatypes.None;
    serde.de.Visitor.visit_map := Datatypes.None;
    serde.de.Visitor.visit_enum := Datatypes.None;
    serde.de.Visitor.__private_visit_untagged_option := Datatypes.None;
  }.
End Impl_serde_de_Visitor_for_serde_json_number_deserialize_NumberVisitor_t.
End Impl_serde_de_Visitor_for_serde_json_number_deserialize_NumberVisitor_t.

Module  Impl_serde_de_Deserializer_for_serde_json_number_Number_t.
Section Impl_serde_de_Deserializer_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
          fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self.n {
                  N::PosInt(u) => visitor.visit_u64(u),
                  N::NegInt(i) => visitor.visit_i64(i),
                  N::Float(f) => visitor.visit_f64(f),
              }
          }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* fields := M.alloc fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* variants := M.alloc variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_serde_json_number_Number_t.
End Impl_serde_de_Deserializer_for_serde_json_number_Number_t.

Module  Impl_serde_de_Deserializer_for_ref_serde_json_number_Number_t.
Section Impl_serde_de_Deserializer_for_ref_serde_json_number_Number_t.
  Definition Self : Set := ref serde_json.number.Number.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := serde_json.error.Error.t.
  
  (*
          fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              match self.n {
                  N::PosInt(u) => visitor.visit_u64(u),
                  N::NegInt(i) => visitor.visit_i64(i),
                  N::Float(f) => visitor.visit_f64(f),
              }
          }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t serde_json.error.Error.t) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* fields := M.alloc fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* variants := M.alloc variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_ref_serde_json_number_Number_t.
End Impl_serde_de_Deserializer_for_ref_serde_json_number_Number_t.

Module  Impl_core_convert_From_serde_json_de_ParserNumber_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_serde_json_de_ParserNumber_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      fn from(value: ParserNumber) -> Self {
          let n = match value {
              ParserNumber::F64(f) => {
                  #[cfg(not(feature = "arbitrary_precision"))]
                  {
                      N::Float(f)
                  }
                  #[cfg(feature = "arbitrary_precision")]
                  {
                      f.to_string()
                  }
              }
              ParserNumber::U64(u) => {
                  #[cfg(not(feature = "arbitrary_precision"))]
                  {
                      N::PosInt(u)
                  }
                  #[cfg(feature = "arbitrary_precision")]
                  {
                      u.to_string()
                  }
              }
              ParserNumber::I64(i) => {
                  #[cfg(not(feature = "arbitrary_precision"))]
                  {
                      N::NegInt(i)
                  }
                  #[cfg(feature = "arbitrary_precision")]
                  {
                      i.to_string()
                  }
              }
              #[cfg(feature = "arbitrary_precision")]
              ParserNumber::String(s) => s,
          };
          Number { n }
      }
  *)
  Definition from (value : serde_json.de.ParserNumber.t) : M Self :=
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := serde_json.de.ParserNumber.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_serde_json_de_ParserNumber_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_serde_json_de_ParserNumber_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_u8_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_u8_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(u: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          { N::PosInt(u as u64) }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(u).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (u : u8.t) : M Self :=
    let* u := M.alloc u in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u8_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_u8_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_u16_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_u16_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(u: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          { N::PosInt(u as u64) }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(u).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (u : u16.t) : M Self :=
    let* u := M.alloc u in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u16.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u16_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_u16_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_u32_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_u32_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(u: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          { N::PosInt(u as u64) }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(u).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (u : u32.t) : M Self :=
    let* u := M.alloc u in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u32.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u32_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_u32_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_u64_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_u64_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(u: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          { N::PosInt(u as u64) }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(u).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (u : u64.t) : M Self :=
    let* u := M.alloc u in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u64.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u64_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_u64_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_usize_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_usize_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(u: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          { N::PosInt(u as u64) }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(u).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (u : usize.t) : M Self :=
    let* u := M.alloc u in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := usize.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_usize_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_usize_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_i8_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_i8_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(i: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          {
                              if i < 0 {
                                  N::NegInt(i as i64)
                              } else {
                                  N::PosInt(i as u64)
                              }
                          }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(i).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (i : i8.t) : M Self :=
    let* i := M.alloc i in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := i8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_i8_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_i8_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_i16_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_i16_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(i: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          {
                              if i < 0 {
                                  N::NegInt(i as i64)
                              } else {
                                  N::PosInt(i as u64)
                              }
                          }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(i).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (i : i16.t) : M Self :=
    let* i := M.alloc i in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := i16.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_i16_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_i16_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_i32_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_i32_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(i: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          {
                              if i < 0 {
                                  N::NegInt(i as i64)
                              } else {
                                  N::PosInt(i as u64)
                              }
                          }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(i).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (i : i32.t) : M Self :=
    let* i := M.alloc i in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := i32.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_i32_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_i32_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_i64_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_i64_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(i: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          {
                              if i < 0 {
                                  N::NegInt(i as i64)
                              } else {
                                  N::PosInt(i as u64)
                              }
                          }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(i).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (i : i64.t) : M Self :=
    let* i := M.alloc i in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := i64.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_i64_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_i64_t_for_serde_json_number_Number_t.

Module  Impl_core_convert_From_isize_t_for_serde_json_number_Number_t.
Section Impl_core_convert_From_isize_t_for_serde_json_number_Number_t.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
                  fn from(i: $ty) -> Self {
                      let n = {
                          #[cfg(not(feature = "arbitrary_precision"))]
                          {
                              if i < 0 {
                                  N::NegInt(i as i64)
                              } else {
                                  N::PosInt(i as u64)
                              }
                          }
                          #[cfg(feature = "arbitrary_precision")]
                          {
                              itoa::Buffer::new().format(i).to_owned()
                          }
                      };
                      Number { n }
                  }
  *)
  Definition from (i : isize.t) : M Self :=
    let* i := M.alloc i in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := isize.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_isize_t_for_serde_json_number_Number_t.
End Impl_core_convert_From_isize_t_for_serde_json_number_Number_t.

Module  Impl_serde_json_number_Number_t_4.
Section Impl_serde_json_number_Number_t_4.
  Definition Self : Set := serde_json.number.Number.t.
  
  (*
      pub(crate) fn unexpected(&self) -> Unexpected {
          match self.n {
              N::PosInt(u) => Unexpected::Unsigned(u),
              N::NegInt(i) => Unexpected::Signed(i),
              N::Float(f) => Unexpected::Float(f),
          }
      }
  *)
  Definition unexpected (self : ref Self) : M serde.de.Unexpected.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_unexpected :
    Notations.DoubleColon Self "unexpected" := {
    Notations.double_colon := unexpected;
  }.
End Impl_serde_json_number_Number_t_4.
End Impl_serde_json_number_Number_t_4.

Module read.
  Module  Read.
  Section Read.
    Class Trait (Self : Set) : Type := {
      ℒ_0 :: serde_json.read.private.Sealed.Trait Self;
      next :
        (mut_ref Self) ->
          M ltac:(serde_json.error.Result (core.option.Option.t u8.t));
      peek :
        (mut_ref Self) ->
          M ltac:(serde_json.error.Result (core.option.Option.t u8.t));
      discard : (mut_ref Self) -> M unit;
      position : (ref Self) -> M serde_json.read.Position.t;
      peek_position : (ref Self) -> M serde_json.read.Position.t;
      byte_offset : (ref Self) -> M usize.t;
      parse_str :
        (mut_ref Self) ->
          (mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)) ->
          M ltac:(serde_json.error.Result (serde_json.read.Reference.t str.t));
      parse_str_raw :
        (mut_ref Self) ->
          (mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)) ->
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t (slice u8.t)));
      ignore_str : (mut_ref Self) -> M ltac:(serde_json.error.Result unit);
      decode_hex_escape :
        (mut_ref Self) -> M ltac:(serde_json.error.Result u16.t);
      should_early_return_if_failed : bool.t;
      set_failed : (mut_ref Self) -> (mut_ref bool.t) -> M unit;
    }.
    
  End Read.
  End Read.
  
  Module  Position.
  Section Position.
    Record t : Set := {
      line : usize.t;
      column : usize.t;
    }.
    
    Definition Get_line :=
      Ref.map (fun α => Some α.(line)) (fun β α => Some (α <| line := β |>)).
    Definition Get_column :=
      Ref.map
        (fun α => Some α.(column))
        (fun β α => Some (α <| column := β |>)).
  End Position.
  End Position.
  
  Module Reference.
    Inductive t (T : Set) : Set :=
    | Borrowed (_ : ref T)
    | Copied (_ : ref T).
    
    Definition Get_Borrowed_0 :=
      Ref.map
        (fun α => match α with | Borrowed α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | Borrowed _ => Some (Borrowed β) | _ => None end).
    
    Definition Get_Copied_0 :=
      Ref.map
        (fun α => match α with | Copied α0 => Some α0 | _ => None end)
        (fun β α => match α with | Copied _ => Some (Copied β) | _ => None end).
  End Reference.
  
  Module  Impl_core_ops_deref_Deref_for_serde_json_read_Reference_t_T.
  Section Impl_core_ops_deref_Deref_for_serde_json_read_Reference_t_T.
    Context {T : Set}.
    
    Definition Self : Set := serde_json.read.Reference.t T.
    
    (*
        type Target = T;
    *)
    Definition Target : Set := T.
    
    (*
        fn deref(&self) -> &Self::Target {
            match *self {
                Reference::Borrowed(b) => b,
                Reference::Copied(c) => c,
            }
        }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_serde_json_read_Reference_t_T.
  End Impl_core_ops_deref_Deref_for_serde_json_read_Reference_t_T.
  
  Module  IoRead.
  Section IoRead.
    Context (R : Set).
    
    Context {ℋ_0 : std.io.Read.Trait R}.
    Record t : Set := {
      iter : serde_json.iter.LineColIterator.t (std.io.Bytes.t R);
      ch : core.option.Option.t u8.t;
    }.
    
    Definition Get_iter :=
      Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
    Definition Get_ch :=
      Ref.map (fun α => Some α.(ch)) (fun β α => Some (α <| ch := β |>)).
  End IoRead.
  End IoRead.
  
  Module  SliceRead.
  Section SliceRead.
    Record t : Set := {
      slice : ref (slice u8.t);
      index : usize.t;
    }.
    
    Definition Get_slice :=
      Ref.map (fun α => Some α.(slice)) (fun β α => Some (α <| slice := β |>)).
    Definition Get_index :=
      Ref.map (fun α => Some α.(index)) (fun β α => Some (α <| index := β |>)).
  End SliceRead.
  End SliceRead.
  
  Module  StrRead.
  Section StrRead.
    Record t : Set := {
      delegate : serde_json.read.SliceRead.t;
    }.
    
    Definition Get_delegate :=
      Ref.map
        (fun α => Some α.(delegate))
        (fun β α => Some (α <| delegate := β |>)).
  End StrRead.
  End StrRead.
  
  Module private.
    Module  Sealed.
    Section Sealed.
      Unset Primitive Projections.
      Class Trait (Self : Set) : Type := {
      }.
      Global Set Primitive Projections.
    End Sealed.
    End Sealed.
  End private.
  
  Module  Impl_serde_json_read_IoRead_t_R.
  Section Impl_serde_json_read_IoRead_t_R.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.read.IoRead.t R.
    
    (*
        pub fn new(reader: R) -> Self {
            IoRead {
                iter: LineColIterator::new(reader.bytes()),
                ch: None,
                #[cfg(feature = "raw_value")]
                raw_buffer: None,
            }
        }
    *)
    Definition new (reader : R) : M Self :=
      let* reader := M.alloc reader in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_read_IoRead_t_R.
  End Impl_serde_json_read_IoRead_t_R.
  
  Module  Impl_serde_json_read_private_Sealed_for_serde_json_read_IoRead_t_R.
  Section Impl_serde_json_read_private_Sealed_for_serde_json_read_IoRead_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : std.io.Read.Trait R}.
    
    Definition Self : Set := serde_json.read.IoRead.t R.
    
    Global Instance ℐ : serde_json.read.private.Sealed.Trait Self := {
    }.
  End Impl_serde_json_read_private_Sealed_for_serde_json_read_IoRead_t_R.
  End Impl_serde_json_read_private_Sealed_for_serde_json_read_IoRead_t_R.
  
  Module  Impl_serde_json_read_IoRead_t_R_2.
  Section Impl_serde_json_read_IoRead_t_R_2.
    Context {R : Set}.
    
    Definition Self : Set := serde_json.read.IoRead.t R.
    
    (*
        fn parse_str_bytes<'s, T, F>(
            &'s mut self,
            scratch: &'s mut Vec<u8>,
            validate: bool,
            result: F,
        ) -> Result<T>
        where
            T: 's,
            F: FnOnce(&'s Self, &'s [u8]) -> Result<T>,
        {
            loop {
                let ch = tri!(next_or_eof(self));
                if !ESCAPE[ch as usize] {
                    scratch.push(ch);
                    continue;
                }
                match ch {
                    b'"' => {
                        return result(self, scratch);
                    }
                    b'\\' => {
                        tri!(parse_escape(self, validate, scratch));
                    }
                    _ => {
                        if validate {
                            return error(self, ErrorCode::ControlCharacterWhileParsingString);
                        }
                        scratch.push(ch);
                    }
                }
            }
        }
    "
    *)
    Definition parse_str_bytes
        {T F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := (ref Self) * (ref (slice u8.t)))}
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        (validate : bool.t)
        (result : F)
        : M ltac:(serde_json.error.Result T) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      let* validate := M.alloc validate in
      let* result := M.alloc result in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str_bytes
        {T F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := (ref Self) * (ref (slice u8.t)))} :
      Notations.DoubleColon Self "parse_str_bytes" := {
      Notations.double_colon := parse_str_bytes (T := T) (F := F);
    }.
  End Impl_serde_json_read_IoRead_t_R_2.
  End Impl_serde_json_read_IoRead_t_R_2.
  
  Module  Impl_serde_json_read_Read_for_serde_json_read_IoRead_t_R.
  Section Impl_serde_json_read_Read_for_serde_json_read_IoRead_t_R.
    Context {R : Set}.
    
    Context {ℋ_0 : std.io.Read.Trait R}.
    
    Definition Self : Set := serde_json.read.IoRead.t R.
    
    (*
        fn next(&mut self) -> Result<Option<u8>> {
            match self.ch.take() {
                Some(ch) => {
                    #[cfg(feature = "raw_value")]
                    {
                        if let Some(buf) = &mut self.raw_buffer {
                            buf.push(ch);
                        }
                    }
                    Ok(Some(ch))
                }
                None => match self.iter.next() {
                    Some(Err(err)) => Err(Error::io(err)),
                    Some(Ok(ch)) => {
                        #[cfg(feature = "raw_value")]
                        {
                            if let Some(buf) = &mut self.raw_buffer {
                                buf.push(ch);
                            }
                        }
                        Ok(Some(ch))
                    }
                    None => Ok(None),
                },
            }
        }
    *)
    Definition next
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
        fn peek(&mut self) -> Result<Option<u8>> {
            match self.ch {
                Some(ch) => Ok(Some(ch)),
                None => match self.iter.next() {
                    Some(Err(err)) => Err(Error::io(err)),
                    Some(Ok(ch)) => {
                        self.ch = Some(ch);
                        Ok(self.ch)
                    }
                    None => Ok(None),
                },
            }
        }
    *)
    Definition peek
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek :
      Notations.DoubleColon Self "peek" := {
      Notations.double_colon := peek;
    }.
    
    (*
        fn discard(&mut self) {
            self.ch = None;
        }
    *)
    Definition discard (self : mut_ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_discard :
      Notations.DoubleColon Self "discard" := {
      Notations.double_colon := discard;
    }.
    
    (*
        fn position(&self) -> Position {
            Position {
                line: self.iter.line(),
                column: self.iter.col(),
            }
        }
    *)
    Definition position (self : ref Self) : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_position :
      Notations.DoubleColon Self "position" := {
      Notations.double_colon := position;
    }.
    
    (*
        fn peek_position(&self) -> Position {
            // The LineColIterator updates its position during peek() so it has the
            // right one here.
            self.position()
        }
    *)
    Definition peek_position (self : ref Self) : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek_position :
      Notations.DoubleColon Self "peek_position" := {
      Notations.double_colon := peek_position;
    }.
    
    (*
        fn byte_offset(&self) -> usize {
            match self.ch {
                Some(_) => self.iter.byte_offset() - 1,
                None => self.iter.byte_offset(),
            }
        }
    *)
    Definition byte_offset (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_byte_offset :
      Notations.DoubleColon Self "byte_offset" := {
      Notations.double_colon := byte_offset;
    }.
    
    (*
        fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> {
            self.parse_str_bytes(scratch, true, as_str)
                .map(Reference::Copied)
        }
    *)
    Definition parse_str
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        :
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t str.t)) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str :
      Notations.DoubleColon Self "parse_str" := {
      Notations.double_colon := parse_str;
    }.
    
    (*
        fn parse_str_raw<'s>(
            &'s mut self,
            scratch: &'s mut Vec<u8>,
        ) -> Result<Reference<'de, 's, [u8]>> {
            self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))
                .map(Reference::Copied)
        }
    *)
    Definition parse_str_raw
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        :
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t (slice u8.t))) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str_raw :
      Notations.DoubleColon Self "parse_str_raw" := {
      Notations.double_colon := parse_str_raw;
    }.
    
    (*
        fn ignore_str(&mut self) -> Result<()> {
            loop {
                let ch = tri!(next_or_eof(self));
                if !ESCAPE[ch as usize] {
                    continue;
                }
                match ch {
                    b'"' => {
                        return Ok(());
                    }
                    b'\\' => {
                        tri!(ignore_escape(self));
                    }
                    _ => {
                        return error(self, ErrorCode::ControlCharacterWhileParsingString);
                    }
                }
            }
        }
    "
    *)
    Definition ignore_str
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_ignore_str :
      Notations.DoubleColon Self "ignore_str" := {
      Notations.double_colon := ignore_str;
    }.
    
    (*
        fn decode_hex_escape(&mut self) -> Result<u16> {
            let mut n = 0;
            for _ in 0..4 {
                match decode_hex_val(tri!(next_or_eof(self))) {
                    None => return error(self, ErrorCode::InvalidEscape),
                    Some(val) => {
                        n = (n << 4) + val;
                    }
                }
            }
            Ok(n)
        }
    *)
    Definition decode_hex_escape
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result u16.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_decode_hex_escape :
      Notations.DoubleColon Self "decode_hex_escape" := {
      Notations.double_colon := decode_hex_escape;
    }.
    
    (*
        const should_early_return_if_failed: bool = true;
    *)
    
    Definition should_early_return_if_failed : bool.t := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_should_early_return_if_failed :
      Notations.DoubleColon Self "should_early_return_if_failed" := {
      Notations.double_colon := should_early_return_if_failed;
    }.
    
    (*
        fn set_failed(&mut self, failed: &mut bool) {
            *failed = true;
        }
    *)
    Definition set_failed
        (self : mut_ref Self)
        (failed : mut_ref bool.t)
        : M unit :=
      let* self := M.alloc self in
      let* failed := M.alloc failed in
      M.read foo.
    
    Global Instance AssociatedFunction_set_failed :
      Notations.DoubleColon Self "set_failed" := {
      Notations.double_colon := set_failed;
    }.
    
    Global Instance ℐ : serde_json.read.Read.Trait Self := {
      serde_json.read.Read.next := next;
      serde_json.read.Read.peek := peek;
      serde_json.read.Read.discard := discard;
      serde_json.read.Read.position := position;
      serde_json.read.Read.peek_position := peek_position;
      serde_json.read.Read.byte_offset := byte_offset;
      serde_json.read.Read.parse_str := parse_str;
      serde_json.read.Read.parse_str_raw := parse_str_raw;
      serde_json.read.Read.ignore_str := ignore_str;
      serde_json.read.Read.decode_hex_escape := decode_hex_escape;
      serde_json.read.Read.should_early_return_if_failed :=
        should_early_return_if_failed;
      serde_json.read.Read.set_failed := set_failed;
    }.
  End Impl_serde_json_read_Read_for_serde_json_read_IoRead_t_R.
  End Impl_serde_json_read_Read_for_serde_json_read_IoRead_t_R.
  
  Module  Impl_serde_json_read_SliceRead_t.
  Section Impl_serde_json_read_SliceRead_t.
    Definition Self : Set := serde_json.read.SliceRead.t.
    
    (*
        pub fn new(slice: &'a [u8]) -> Self {
            SliceRead {
                slice,
                index: 0,
                #[cfg(feature = "raw_value")]
                raw_buffering_start_index: 0,
            }
        }
    *)
    Definition new (slice : ref (slice u8.t)) : M Self :=
      let* slice := M.alloc slice in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        fn position_of_index(&self, i: usize) -> Position {
            let mut position = Position { line: 1, column: 0 };
            for ch in &self.slice[..i] {
                match *ch {
                    b'\n' => {
                        position.line += 1;
                        position.column = 0;
                    }
                    _ => {
                        position.column += 1;
                    }
                }
            }
            position
        }
    *)
    Definition position_of_index
        (self : ref Self)
        (i : usize.t)
        : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      let* i := M.alloc i in
      M.read foo.
    
    Global Instance AssociatedFunction_position_of_index :
      Notations.DoubleColon Self "position_of_index" := {
      Notations.double_colon := position_of_index;
    }.
    
    (*
        fn parse_str_bytes<'s, T, F>(
            &'s mut self,
            scratch: &'s mut Vec<u8>,
            validate: bool,
            result: F,
        ) -> Result<Reference<'a, 's, T>>
        where
            T: ?Sized + 's,
            F: for<'f> FnOnce(&'s Self, &'f [u8]) -> Result<&'f T>,
        {
            // Index of the first byte not yet copied into the scratch space.
            let mut start = self.index;
    
            loop {
                while self.index < self.slice.len() && !ESCAPE[self.slice[self.index] as usize] {
                    self.index += 1;
                }
                if self.index == self.slice.len() {
                    return error(self, ErrorCode::EofWhileParsingString);
                }
                match self.slice[self.index] {
                    b'"' => {
                        if scratch.is_empty() {
                            // Fast path: return a slice of the raw JSON without any
                            // copying.
                            let borrowed = &self.slice[start..self.index];
                            self.index += 1;
                            return result(self, borrowed).map(Reference::Borrowed);
                        } else {
                            scratch.extend_from_slice(&self.slice[start..self.index]);
                            self.index += 1;
                            return result(self, scratch).map(Reference::Copied);
                        }
                    }
                    b'\\' => {
                        scratch.extend_from_slice(&self.slice[start..self.index]);
                        self.index += 1;
                        tri!(parse_escape(self, validate, scratch));
                        start = self.index;
                    }
                    _ => {
                        self.index += 1;
                        if validate {
                            return error(self, ErrorCode::ControlCharacterWhileParsingString);
                        }
                    }
                }
            }
        }
    "
    *)
    Definition parse_str_bytes
        {T F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := (ref Self) * (ref (slice u8.t)))}
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        (validate : bool.t)
        (result : F)
        : M ltac:(serde_json.error.Result (serde_json.read.Reference.t T)) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      let* validate := M.alloc validate in
      let* result := M.alloc result in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str_bytes
        {T F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := (ref Self) * (ref (slice u8.t)))} :
      Notations.DoubleColon Self "parse_str_bytes" := {
      Notations.double_colon := parse_str_bytes (T := T) (F := F);
    }.
  End Impl_serde_json_read_SliceRead_t.
  End Impl_serde_json_read_SliceRead_t.
  
  Module  Impl_serde_json_read_private_Sealed_for_serde_json_read_SliceRead_t.
  Section Impl_serde_json_read_private_Sealed_for_serde_json_read_SliceRead_t.
    Definition Self : Set := serde_json.read.SliceRead.t.
    
    Global Instance ℐ : serde_json.read.private.Sealed.Trait Self := {
    }.
  End Impl_serde_json_read_private_Sealed_for_serde_json_read_SliceRead_t.
  End Impl_serde_json_read_private_Sealed_for_serde_json_read_SliceRead_t.
  
  Module  Impl_serde_json_read_Read_for_serde_json_read_SliceRead_t.
  Section Impl_serde_json_read_Read_for_serde_json_read_SliceRead_t.
    Definition Self : Set := serde_json.read.SliceRead.t.
    
    (*
        fn next(&mut self) -> Result<Option<u8>> {
            // `Ok(self.slice.get(self.index).map(|ch| { self.index += 1; *ch }))`
            // is about 10% slower.
            Ok(if self.index < self.slice.len() {
                let ch = self.slice[self.index];
                self.index += 1;
                Some(ch)
            } else {
                None
            })
        }
    *)
    Definition next
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
        fn peek(&mut self) -> Result<Option<u8>> {
            // `Ok(self.slice.get(self.index).map(|ch| *ch))` is about 10% slower
            // for some reason.
            Ok(if self.index < self.slice.len() {
                Some(self.slice[self.index])
            } else {
                None
            })
        }
    *)
    Definition peek
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek :
      Notations.DoubleColon Self "peek" := {
      Notations.double_colon := peek;
    }.
    
    (*
        fn discard(&mut self) {
            self.index += 1;
        }
    *)
    Definition discard (self : mut_ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_discard :
      Notations.DoubleColon Self "discard" := {
      Notations.double_colon := discard;
    }.
    
    (*
        fn position(&self) -> Position {
            self.position_of_index(self.index)
        }
    *)
    Definition position (self : ref Self) : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_position :
      Notations.DoubleColon Self "position" := {
      Notations.double_colon := position;
    }.
    
    (*
        fn peek_position(&self) -> Position {
            // Cap it at slice.len() just in case the most recent call was next()
            // and it returned the last byte.
            self.position_of_index(cmp::min(self.slice.len(), self.index + 1))
        }
    *)
    Definition peek_position (self : ref Self) : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek_position :
      Notations.DoubleColon Self "peek_position" := {
      Notations.double_colon := peek_position;
    }.
    
    (*
        fn byte_offset(&self) -> usize {
            self.index
        }
    *)
    Definition byte_offset (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_byte_offset :
      Notations.DoubleColon Self "byte_offset" := {
      Notations.double_colon := byte_offset;
    }.
    
    (*
        fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {
            self.parse_str_bytes(scratch, true, as_str)
        }
    *)
    Definition parse_str
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        :
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t str.t)) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str :
      Notations.DoubleColon Self "parse_str" := {
      Notations.double_colon := parse_str;
    }.
    
    (*
        fn parse_str_raw<'s>(
            &'s mut self,
            scratch: &'s mut Vec<u8>,
        ) -> Result<Reference<'a, 's, [u8]>> {
            self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))
        }
    *)
    Definition parse_str_raw
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        :
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t (slice u8.t))) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str_raw :
      Notations.DoubleColon Self "parse_str_raw" := {
      Notations.double_colon := parse_str_raw;
    }.
    
    (*
        fn ignore_str(&mut self) -> Result<()> {
            loop {
                while self.index < self.slice.len() && !ESCAPE[self.slice[self.index] as usize] {
                    self.index += 1;
                }
                if self.index == self.slice.len() {
                    return error(self, ErrorCode::EofWhileParsingString);
                }
                match self.slice[self.index] {
                    b'"' => {
                        self.index += 1;
                        return Ok(());
                    }
                    b'\\' => {
                        self.index += 1;
                        tri!(ignore_escape(self));
                    }
                    _ => {
                        return error(self, ErrorCode::ControlCharacterWhileParsingString);
                    }
                }
            }
        }
    "
    *)
    Definition ignore_str
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_ignore_str :
      Notations.DoubleColon Self "ignore_str" := {
      Notations.double_colon := ignore_str;
    }.
    
    (*
        fn decode_hex_escape(&mut self) -> Result<u16> {
            if self.index + 4 > self.slice.len() {
                self.index = self.slice.len();
                return error(self, ErrorCode::EofWhileParsingString);
            }
    
            let mut n = 0;
            for _ in 0..4 {
                let ch = decode_hex_val(self.slice[self.index]);
                self.index += 1;
                match ch {
                    None => return error(self, ErrorCode::InvalidEscape),
                    Some(val) => {
                        n = (n << 4) + val;
                    }
                }
            }
            Ok(n)
        }
    *)
    Definition decode_hex_escape
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result u16.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_decode_hex_escape :
      Notations.DoubleColon Self "decode_hex_escape" := {
      Notations.double_colon := decode_hex_escape;
    }.
    
    (*
        const should_early_return_if_failed: bool = false;
    *)
    
    Definition should_early_return_if_failed : bool.t := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_should_early_return_if_failed :
      Notations.DoubleColon Self "should_early_return_if_failed" := {
      Notations.double_colon := should_early_return_if_failed;
    }.
    
    (*
        fn set_failed(&mut self, _failed: &mut bool) {
            self.slice = &self.slice[..self.index];
        }
    *)
    Definition set_failed
        (self : mut_ref Self)
        (_failed : mut_ref bool.t)
        : M unit :=
      let* self := M.alloc self in
      let* _failed := M.alloc _failed in
      M.read foo.
    
    Global Instance AssociatedFunction_set_failed :
      Notations.DoubleColon Self "set_failed" := {
      Notations.double_colon := set_failed;
    }.
    
    Global Instance ℐ : serde_json.read.Read.Trait Self := {
      serde_json.read.Read.next := next;
      serde_json.read.Read.peek := peek;
      serde_json.read.Read.discard := discard;
      serde_json.read.Read.position := position;
      serde_json.read.Read.peek_position := peek_position;
      serde_json.read.Read.byte_offset := byte_offset;
      serde_json.read.Read.parse_str := parse_str;
      serde_json.read.Read.parse_str_raw := parse_str_raw;
      serde_json.read.Read.ignore_str := ignore_str;
      serde_json.read.Read.decode_hex_escape := decode_hex_escape;
      serde_json.read.Read.should_early_return_if_failed :=
        should_early_return_if_failed;
      serde_json.read.Read.set_failed := set_failed;
    }.
  End Impl_serde_json_read_Read_for_serde_json_read_SliceRead_t.
  End Impl_serde_json_read_Read_for_serde_json_read_SliceRead_t.
  
  Module  Impl_serde_json_read_StrRead_t.
  Section Impl_serde_json_read_StrRead_t.
    Definition Self : Set := serde_json.read.StrRead.t.
    
    (*
        pub fn new(s: &'a str) -> Self {
            StrRead {
                delegate: SliceRead::new(s.as_bytes()),
                #[cfg(feature = "raw_value")]
                data: s,
            }
        }
    *)
    Definition new (s : ref str.t) : M Self :=
      let* s := M.alloc s in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_serde_json_read_StrRead_t.
  End Impl_serde_json_read_StrRead_t.
  
  Module  Impl_serde_json_read_private_Sealed_for_serde_json_read_StrRead_t.
  Section Impl_serde_json_read_private_Sealed_for_serde_json_read_StrRead_t.
    Definition Self : Set := serde_json.read.StrRead.t.
    
    Global Instance ℐ : serde_json.read.private.Sealed.Trait Self := {
    }.
  End Impl_serde_json_read_private_Sealed_for_serde_json_read_StrRead_t.
  End Impl_serde_json_read_private_Sealed_for_serde_json_read_StrRead_t.
  
  Module  Impl_serde_json_read_Read_for_serde_json_read_StrRead_t.
  Section Impl_serde_json_read_Read_for_serde_json_read_StrRead_t.
    Definition Self : Set := serde_json.read.StrRead.t.
    
    (*
        fn next(&mut self) -> Result<Option<u8>> {
            self.delegate.next()
        }
    *)
    Definition next
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
        fn peek(&mut self) -> Result<Option<u8>> {
            self.delegate.peek()
        }
    *)
    Definition peek
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek :
      Notations.DoubleColon Self "peek" := {
      Notations.double_colon := peek;
    }.
    
    (*
        fn discard(&mut self) {
            self.delegate.discard();
        }
    *)
    Definition discard (self : mut_ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_discard :
      Notations.DoubleColon Self "discard" := {
      Notations.double_colon := discard;
    }.
    
    (*
        fn position(&self) -> Position {
            self.delegate.position()
        }
    *)
    Definition position (self : ref Self) : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_position :
      Notations.DoubleColon Self "position" := {
      Notations.double_colon := position;
    }.
    
    (*
        fn peek_position(&self) -> Position {
            self.delegate.peek_position()
        }
    *)
    Definition peek_position (self : ref Self) : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek_position :
      Notations.DoubleColon Self "peek_position" := {
      Notations.double_colon := peek_position;
    }.
    
    (*
        fn byte_offset(&self) -> usize {
            self.delegate.byte_offset()
        }
    *)
    Definition byte_offset (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_byte_offset :
      Notations.DoubleColon Self "byte_offset" := {
      Notations.double_colon := byte_offset;
    }.
    
    (*
        fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {
            self.delegate.parse_str_bytes(scratch, true, |_, bytes| {
                // The deserialization input came in as &str with a UTF-8 guarantee,
                // and the \u-escapes are checked along the way, so don't need to
                // check here.
                Ok(unsafe { str::from_utf8_unchecked(bytes) })
            })
        }
    *)
    Definition parse_str
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        :
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t str.t)) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str :
      Notations.DoubleColon Self "parse_str" := {
      Notations.double_colon := parse_str;
    }.
    
    (*
        fn parse_str_raw<'s>(
            &'s mut self,
            scratch: &'s mut Vec<u8>,
        ) -> Result<Reference<'a, 's, [u8]>> {
            self.delegate.parse_str_raw(scratch)
        }
    *)
    Definition parse_str_raw
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        :
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t (slice u8.t))) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str_raw :
      Notations.DoubleColon Self "parse_str_raw" := {
      Notations.double_colon := parse_str_raw;
    }.
    
    (*
        fn ignore_str(&mut self) -> Result<()> {
            self.delegate.ignore_str()
        }
    *)
    Definition ignore_str
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_ignore_str :
      Notations.DoubleColon Self "ignore_str" := {
      Notations.double_colon := ignore_str;
    }.
    
    (*
        fn decode_hex_escape(&mut self) -> Result<u16> {
            self.delegate.decode_hex_escape()
        }
    *)
    Definition decode_hex_escape
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result u16.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_decode_hex_escape :
      Notations.DoubleColon Self "decode_hex_escape" := {
      Notations.double_colon := decode_hex_escape;
    }.
    
    (*
        const should_early_return_if_failed: bool = false;
    *)
    
    Definition should_early_return_if_failed : bool.t := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_should_early_return_if_failed :
      Notations.DoubleColon Self "should_early_return_if_failed" := {
      Notations.double_colon := should_early_return_if_failed;
    }.
    
    (*
        fn set_failed(&mut self, failed: &mut bool) {
            self.delegate.set_failed(failed);
        }
    *)
    Definition set_failed
        (self : mut_ref Self)
        (failed : mut_ref bool.t)
        : M unit :=
      let* self := M.alloc self in
      let* failed := M.alloc failed in
      M.read foo.
    
    Global Instance AssociatedFunction_set_failed :
      Notations.DoubleColon Self "set_failed" := {
      Notations.double_colon := set_failed;
    }.
    
    Global Instance ℐ : serde_json.read.Read.Trait Self := {
      serde_json.read.Read.next := next;
      serde_json.read.Read.peek := peek;
      serde_json.read.Read.discard := discard;
      serde_json.read.Read.position := position;
      serde_json.read.Read.peek_position := peek_position;
      serde_json.read.Read.byte_offset := byte_offset;
      serde_json.read.Read.parse_str := parse_str;
      serde_json.read.Read.parse_str_raw := parse_str_raw;
      serde_json.read.Read.ignore_str := ignore_str;
      serde_json.read.Read.decode_hex_escape := decode_hex_escape;
      serde_json.read.Read.should_early_return_if_failed :=
        should_early_return_if_failed;
      serde_json.read.Read.set_failed := set_failed;
    }.
  End Impl_serde_json_read_Read_for_serde_json_read_StrRead_t.
  End Impl_serde_json_read_Read_for_serde_json_read_StrRead_t.
  
  Module  Impl_serde_json_read_private_Sealed_for_mut_ref_R.
  Section Impl_serde_json_read_private_Sealed_for_mut_ref_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := mut_ref R.
    
    Global Instance ℐ : serde_json.read.private.Sealed.Trait Self := {
    }.
  End Impl_serde_json_read_private_Sealed_for_mut_ref_R.
  End Impl_serde_json_read_private_Sealed_for_mut_ref_R.
  
  Module  Impl_serde_json_read_Read_for_mut_ref_R.
  Section Impl_serde_json_read_Read_for_mut_ref_R.
    Context {R : Set}.
    
    Context {ℋ_0 : serde_json.read.Read.Trait R}.
    
    Definition Self : Set := mut_ref R.
    
    (*
        fn next(&mut self) -> Result<Option<u8>> {
            R::next(self)
        }
    *)
    Definition next
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
        fn peek(&mut self) -> Result<Option<u8>> {
            R::peek(self)
        }
    *)
    Definition peek
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek :
      Notations.DoubleColon Self "peek" := {
      Notations.double_colon := peek;
    }.
    
    (*
        fn discard(&mut self) {
            R::discard(self);
        }
    *)
    Definition discard (self : mut_ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_discard :
      Notations.DoubleColon Self "discard" := {
      Notations.double_colon := discard;
    }.
    
    (*
        fn position(&self) -> Position {
            R::position(self)
        }
    *)
    Definition position (self : ref Self) : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_position :
      Notations.DoubleColon Self "position" := {
      Notations.double_colon := position;
    }.
    
    (*
        fn peek_position(&self) -> Position {
            R::peek_position(self)
        }
    *)
    Definition peek_position (self : ref Self) : M serde_json.read.Position.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_peek_position :
      Notations.DoubleColon Self "peek_position" := {
      Notations.double_colon := peek_position;
    }.
    
    (*
        fn byte_offset(&self) -> usize {
            R::byte_offset(self)
        }
    *)
    Definition byte_offset (self : ref Self) : M usize.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_byte_offset :
      Notations.DoubleColon Self "byte_offset" := {
      Notations.double_colon := byte_offset;
    }.
    
    (*
        fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> {
            R::parse_str(self, scratch)
        }
    *)
    Definition parse_str
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        :
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t str.t)) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str :
      Notations.DoubleColon Self "parse_str" := {
      Notations.double_colon := parse_str;
    }.
    
    (*
        fn parse_str_raw<'s>(
            &'s mut self,
            scratch: &'s mut Vec<u8>,
        ) -> Result<Reference<'de, 's, [u8]>> {
            R::parse_str_raw(self, scratch)
        }
    *)
    Definition parse_str_raw
        (self : mut_ref Self)
        (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        :
          M
            ltac:(serde_json.error.Result
              (serde_json.read.Reference.t (slice u8.t))) :=
      let* self := M.alloc self in
      let* scratch := M.alloc scratch in
      M.read foo.
    
    Global Instance AssociatedFunction_parse_str_raw :
      Notations.DoubleColon Self "parse_str_raw" := {
      Notations.double_colon := parse_str_raw;
    }.
    
    (*
        fn ignore_str(&mut self) -> Result<()> {
            R::ignore_str(self)
        }
    *)
    Definition ignore_str
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_ignore_str :
      Notations.DoubleColon Self "ignore_str" := {
      Notations.double_colon := ignore_str;
    }.
    
    (*
        fn decode_hex_escape(&mut self) -> Result<u16> {
            R::decode_hex_escape(self)
        }
    *)
    Definition decode_hex_escape
        (self : mut_ref Self)
        : M ltac:(serde_json.error.Result u16.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_decode_hex_escape :
      Notations.DoubleColon Self "decode_hex_escape" := {
      Notations.double_colon := decode_hex_escape;
    }.
    
    (*
        const should_early_return_if_failed: bool = R::should_early_return_if_failed;
    *)
    
    Definition should_early_return_if_failed : bool.t := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_should_early_return_if_failed :
      Notations.DoubleColon Self "should_early_return_if_failed" := {
      Notations.double_colon := should_early_return_if_failed;
    }.
    
    (*
        fn set_failed(&mut self, failed: &mut bool) {
            R::set_failed(self, failed);
        }
    *)
    Definition set_failed
        (self : mut_ref Self)
        (failed : mut_ref bool.t)
        : M unit :=
      let* self := M.alloc self in
      let* failed := M.alloc failed in
      M.read foo.
    
    Global Instance AssociatedFunction_set_failed :
      Notations.DoubleColon Self "set_failed" := {
      Notations.double_colon := set_failed;
    }.
    
    Global Instance ℐ : serde_json.read.Read.Trait Self := {
      serde_json.read.Read.next := next;
      serde_json.read.Read.peek := peek;
      serde_json.read.Read.discard := discard;
      serde_json.read.Read.position := position;
      serde_json.read.Read.peek_position := peek_position;
      serde_json.read.Read.byte_offset := byte_offset;
      serde_json.read.Read.parse_str := parse_str;
      serde_json.read.Read.parse_str_raw := parse_str_raw;
      serde_json.read.Read.ignore_str := ignore_str;
      serde_json.read.Read.decode_hex_escape := decode_hex_escape;
      serde_json.read.Read.should_early_return_if_failed :=
        should_early_return_if_failed;
      serde_json.read.Read.set_failed := set_failed;
    }.
  End Impl_serde_json_read_Read_for_mut_ref_R.
  End Impl_serde_json_read_Read_for_mut_ref_R.
  
  Module  Fused.
  Section Fused.
    Class Trait (Self : Set) : Type := {
      ℒ_0 :: serde_json.read.private.Sealed.Trait Self;
    }.
    
  End Fused.
  End Fused.
  
  Module  Impl_serde_json_read_Fused_for_serde_json_read_SliceRead_t.
  Section Impl_serde_json_read_Fused_for_serde_json_read_SliceRead_t.
    Definition Self : Set := serde_json.read.SliceRead.t.
    
    Global Instance ℐ : serde_json.read.Fused.Trait Self := {
    }.
  End Impl_serde_json_read_Fused_for_serde_json_read_SliceRead_t.
  End Impl_serde_json_read_Fused_for_serde_json_read_SliceRead_t.
  
  Module  Impl_serde_json_read_Fused_for_serde_json_read_StrRead_t.
  Section Impl_serde_json_read_Fused_for_serde_json_read_StrRead_t.
    Definition Self : Set := serde_json.read.StrRead.t.
    
    Global Instance ℐ : serde_json.read.Fused.Trait Self := {
    }.
  End Impl_serde_json_read_Fused_for_serde_json_read_StrRead_t.
  End Impl_serde_json_read_Fused_for_serde_json_read_StrRead_t.
  
  Definition ESCAPE : M.Val (ref (array bool.t)) := M.run (M.alloc foo).
  
  (*
  fn next_or_eof<'de, R>(read: &mut R) -> Result<u8>
  where
      R: ?Sized + Read<'de>,
  {
      match tri!(read.next()) {
          Some(b) => Ok(b),
          None => error(read, ErrorCode::EofWhileParsingString),
      }
  }
  *)
  Definition next_or_eof
      {R : Set}
      {ℋ_0 : serde_json.read.Read.Trait R}
      (read : mut_ref R)
      : M ltac:(serde_json.error.Result u8.t) :=
    let* read := M.alloc read in
    M.read foo.
  
  (*
  fn peek_or_eof<'de, R>(read: &mut R) -> Result<u8>
  where
      R: ?Sized + Read<'de>,
  {
      match tri!(read.peek()) {
          Some(b) => Ok(b),
          None => error(read, ErrorCode::EofWhileParsingString),
      }
  }
  *)
  Definition peek_or_eof
      {R : Set}
      {ℋ_0 : serde_json.read.Read.Trait R}
      (read : mut_ref R)
      : M ltac:(serde_json.error.Result u8.t) :=
    let* read := M.alloc read in
    M.read foo.
  
  (*
  fn error<'de, R, T>(read: &R, reason: ErrorCode) -> Result<T>
  where
      R: ?Sized + Read<'de>,
  {
      let position = read.position();
      Err(Error::syntax(reason, position.line, position.column))
  }
  *)
  Definition error
      {R T : Set}
      {ℋ_0 : serde_json.read.Read.Trait R}
      (read : ref R)
      (reason : serde_json.error.ErrorCode.t)
      : M ltac:(serde_json.error.Result T) :=
    let* read := M.alloc read in
    let* reason := M.alloc reason in
    M.read foo.
  
  (*
  fn as_str<'de, 's, R: Read<'de>>(read: &R, slice: &'s [u8]) -> Result<&'s str> {
      str::from_utf8(slice).or_else(|_| error(read, ErrorCode::InvalidUnicodeCodePoint))
  }
  *)
  Definition as_str
      {R : Set}
      {ℋ_0 : serde_json.read.Read.Trait R}
      (read : ref R)
      (slice : ref (slice u8.t))
      : M ltac:(serde_json.error.Result (ref str.t)) :=
    let* read := M.alloc read in
    let* slice := M.alloc slice in
    M.read foo.
  
  (*
  fn parse_escape<'de, R: Read<'de>>(
      read: &mut R,
      validate: bool,
      scratch: &mut Vec<u8>,
  ) -> Result<()> {
      let ch = tri!(next_or_eof(read));
  
      match ch {
          b'"' => scratch.push(b'"'),
          b'\\' => scratch.push(b'\\'),
          b'/' => scratch.push(b'/'),
          b'b' => scratch.push(b'\x08'),
          b'f' => scratch.push(b'\x0c'),
          b'n' => scratch.push(b'\n'),
          b'r' => scratch.push(b'\r'),
          b't' => scratch.push(b'\t'),
          b'u' => {
              fn encode_surrogate(scratch: &mut Vec<u8>, n: u16) {
                  scratch.extend_from_slice(&[
                      (n >> 12 & 0b0000_1111) as u8 | 0b1110_0000,
                      (n >> 6 & 0b0011_1111) as u8 | 0b1000_0000,
                      (n & 0b0011_1111) as u8 | 0b1000_0000,
                  ]);
              }
  
              let c = match tri!(read.decode_hex_escape()) {
                  n @ 0xDC00..=0xDFFF => {
                      return if validate {
                          error(read, ErrorCode::LoneLeadingSurrogateInHexEscape)
                      } else {
                          encode_surrogate(scratch, n);
                          Ok(())
                      };
                  }
  
                  // Non-BMP characters are encoded as a sequence of two hex
                  // escapes, representing UTF-16 surrogates. If deserializing a
                  // utf-8 string the surrogates are required to be paired,
                  // whereas deserializing a byte string accepts lone surrogates.
                  n1 @ 0xD800..=0xDBFF => {
                      if tri!(peek_or_eof(read)) == b'\\' {
                          read.discard();
                      } else {
                          return if validate {
                              read.discard();
                              error(read, ErrorCode::UnexpectedEndOfHexEscape)
                          } else {
                              encode_surrogate(scratch, n1);
                              Ok(())
                          };
                      }
  
                      if tri!(peek_or_eof(read)) == b'u' {
                          read.discard();
                      } else {
                          return if validate {
                              read.discard();
                              error(read, ErrorCode::UnexpectedEndOfHexEscape)
                          } else {
                              encode_surrogate(scratch, n1);
                              // The \ prior to this byte started an escape sequence,
                              // so we need to parse that now. This recursive call
                              // does not blow the stack on malicious input because
                              // the escape is not \u, so it will be handled by one
                              // of the easy nonrecursive cases.
                              parse_escape(read, validate, scratch)
                          };
                      }
  
                      let n2 = tri!(read.decode_hex_escape());
  
                      if n2 < 0xDC00 || n2 > 0xDFFF {
                          return error(read, ErrorCode::LoneLeadingSurrogateInHexEscape);
                      }
  
                      let n = (((n1 - 0xD800) as u32) << 10 | (n2 - 0xDC00) as u32) + 0x1_0000;
  
                      match char::from_u32(n) {
                          Some(c) => c,
                          None => {
                              return error(read, ErrorCode::InvalidUnicodeCodePoint);
                          }
                      }
                  }
  
                  // Every u16 outside of the surrogate ranges above is guaranteed
                  // to be a legal char.
                  n => char::from_u32(n as u32).unwrap(),
              };
  
              scratch.extend_from_slice(c.encode_utf8(&mut [0_u8; 4]).as_bytes());
          }
          _ => {
              return error(read, ErrorCode::InvalidEscape);
          }
      }
  
      Ok(())
  }
  *)
  Definition parse_escape
      {R : Set}
      {ℋ_0 : serde_json.read.Read.Trait R}
      (read : mut_ref R)
      (validate : bool.t)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      : M ltac:(serde_json.error.Result unit) :=
    let* read := M.alloc read in
    let* validate := M.alloc validate in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  (*
  fn ignore_escape<'de, R>(read: &mut R) -> Result<()>
  where
      R: ?Sized + Read<'de>,
  {
      let ch = tri!(next_or_eof(read));
  
      match ch {
          b'"' | b'\\' | b'/' | b'b' | b'f' | b'n' | b'r' | b't' => {}
          b'u' => {
              // At this point we don't care if the codepoint is valid. We just
              // want to consume it. We don't actually know what is valid or not
              // at this point, because that depends on if this string will
              // ultimately be parsed into a string or a byte buffer in the "real"
              // parse.
  
              tri!(read.decode_hex_escape());
          }
          _ => {
              return error(read, ErrorCode::InvalidEscape);
          }
      }
  
      Ok(())
  }
  "
  *)
  Definition ignore_escape
      {R : Set}
      {ℋ_0 : serde_json.read.Read.Trait R}
      (read : mut_ref R)
      : M ltac:(serde_json.error.Result unit) :=
    let* read := M.alloc read in
    M.read foo.
  
  Definition HEX : M.Val (ref (array u8.t)) := M.run (M.alloc foo).
  
  (*
  fn decode_hex_val(val: u8) -> Option<u16> {
      let n = HEX[val as usize] as u16;
      if n == 255 {
          None
      } else {
          Some(n)
      }
  }
  *)
  Definition decode_hex_val (val : u8.t) : M (core.option.Option.t u16.t) :=
    let* val := M.alloc val in
    M.read foo.
End read.

Module  Read.
Section Read.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: serde_json.read.private.Sealed.Trait Self;
    next :
      (mut_ref Self) ->
        M ltac:(serde_json.error.Result (core.option.Option.t u8.t));
    peek :
      (mut_ref Self) ->
        M ltac:(serde_json.error.Result (core.option.Option.t u8.t));
    discard : (mut_ref Self) -> M unit;
    position : (ref Self) -> M serde_json.read.Position.t;
    peek_position : (ref Self) -> M serde_json.read.Position.t;
    byte_offset : (ref Self) -> M usize.t;
    parse_str :
      (mut_ref Self) ->
        (mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)) ->
        M ltac:(serde_json.error.Result (serde_json.read.Reference.t str.t));
    parse_str_raw :
      (mut_ref Self) ->
        (mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)) ->
        M
          ltac:(serde_json.error.Result
            (serde_json.read.Reference.t (slice u8.t)));
    ignore_str : (mut_ref Self) -> M ltac:(serde_json.error.Result unit);
    decode_hex_escape :
      (mut_ref Self) -> M ltac:(serde_json.error.Result u16.t);
    should_early_return_if_failed : bool.t;
    set_failed : (mut_ref Self) -> (mut_ref bool.t) -> M unit;
  }.
  
End Read.
End Read.

Module  Position.
Section Position.
  Record t : Set := {
    line : usize.t;
    column : usize.t;
  }.
  
  Definition Get_line :=
    Ref.map (fun α => Some α.(line)) (fun β α => Some (α <| line := β |>)).
  Definition Get_column :=
    Ref.map (fun α => Some α.(column)) (fun β α => Some (α <| column := β |>)).
End Position.
End Position.

Module Reference.
  Inductive t (T : Set) : Set :=
  | Borrowed (_ : ref T)
  | Copied (_ : ref T).
  
  Definition Get_Borrowed_0 :=
    Ref.map
      (fun α => match α with | Borrowed α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Borrowed _ => Some (Borrowed β) | _ => None end).
  
  Definition Get_Copied_0 :=
    Ref.map
      (fun α => match α with | Copied α0 => Some α0 | _ => None end)
      (fun β α => match α with | Copied _ => Some (Copied β) | _ => None end).
End Reference.

Module  Impl_core_ops_deref_Deref_for_serde_json_read_Reference_t_T.
Section Impl_core_ops_deref_Deref_for_serde_json_read_Reference_t_T.
  Context {T : Set}.
  
  Definition Self : Set := serde_json.read.Reference.t T.
  
  (*
      type Target = T;
  *)
  Definition Target : Set := T.
  
  (*
      fn deref(&self) -> &Self::Target {
          match *self {
              Reference::Borrowed(b) => b,
              Reference::Copied(c) => c,
          }
      }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_serde_json_read_Reference_t_T.
End Impl_core_ops_deref_Deref_for_serde_json_read_Reference_t_T.

Module  IoRead.
Section IoRead.
  Context (R : Set).
  
  Context {ℋ_0 : std.io.Read.Trait R}.
  Record t : Set := {
    iter : serde_json.iter.LineColIterator.t (std.io.Bytes.t R);
    ch : core.option.Option.t u8.t;
  }.
  
  Definition Get_iter :=
    Ref.map (fun α => Some α.(iter)) (fun β α => Some (α <| iter := β |>)).
  Definition Get_ch :=
    Ref.map (fun α => Some α.(ch)) (fun β α => Some (α <| ch := β |>)).
End IoRead.
End IoRead.

Module  SliceRead.
Section SliceRead.
  Record t : Set := {
    slice : ref (slice u8.t);
    index : usize.t;
  }.
  
  Definition Get_slice :=
    Ref.map (fun α => Some α.(slice)) (fun β α => Some (α <| slice := β |>)).
  Definition Get_index :=
    Ref.map (fun α => Some α.(index)) (fun β α => Some (α <| index := β |>)).
End SliceRead.
End SliceRead.

Module  StrRead.
Section StrRead.
  Record t : Set := {
    delegate : serde_json.read.SliceRead.t;
  }.
  
  Definition Get_delegate :=
    Ref.map
      (fun α => Some α.(delegate))
      (fun β α => Some (α <| delegate := β |>)).
End StrRead.
End StrRead.

Module Wrap_private_1.
Module private.
  Module  Sealed.
  Section Sealed.
    Unset Primitive Projections.
    Class Trait (Self : Set) : Type := {
    }.
    Global Set Primitive Projections.
  End Sealed.
  End Sealed.
End private.
End Wrap_private_1.
Import Wrap_private_1.

Module  Impl_serde_json_read_IoRead_t_R_3.
Section Impl_serde_json_read_IoRead_t_R_3.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.read.IoRead.t R.
  
  (*
      pub fn new(reader: R) -> Self {
          IoRead {
              iter: LineColIterator::new(reader.bytes()),
              ch: None,
              #[cfg(feature = "raw_value")]
              raw_buffer: None,
          }
      }
  *)
  Definition new (reader : R) : M Self :=
    let* reader := M.alloc reader in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_read_IoRead_t_R_3.
End Impl_serde_json_read_IoRead_t_R_3.

Module  Impl_serde_json_read_private_Sealed_for_serde_json_read_IoRead_t_R.
Section Impl_serde_json_read_private_Sealed_for_serde_json_read_IoRead_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : std.io.Read.Trait R}.
  
  Definition Self : Set := serde_json.read.IoRead.t R.
  
  Global Instance ℐ : serde_json.read.private.Sealed.Trait Self := {
  }.
End Impl_serde_json_read_private_Sealed_for_serde_json_read_IoRead_t_R.
End Impl_serde_json_read_private_Sealed_for_serde_json_read_IoRead_t_R.

Module  Impl_serde_json_read_IoRead_t_R_4.
Section Impl_serde_json_read_IoRead_t_R_4.
  Context {R : Set}.
  
  Definition Self : Set := serde_json.read.IoRead.t R.
  
  (*
      fn parse_str_bytes<'s, T, F>(
          &'s mut self,
          scratch: &'s mut Vec<u8>,
          validate: bool,
          result: F,
      ) -> Result<T>
      where
          T: 's,
          F: FnOnce(&'s Self, &'s [u8]) -> Result<T>,
      {
          loop {
              let ch = tri!(next_or_eof(self));
              if !ESCAPE[ch as usize] {
                  scratch.push(ch);
                  continue;
              }
              match ch {
                  b'"' => {
                      return result(self, scratch);
                  }
                  b'\\' => {
                      tri!(parse_escape(self, validate, scratch));
                  }
                  _ => {
                      if validate {
                          return error(self, ErrorCode::ControlCharacterWhileParsingString);
                      }
                      scratch.push(ch);
                  }
              }
          }
      }
  "
  *)
  Definition parse_str_bytes
      {T F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (ref Self) * (ref (slice u8.t)))}
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      (validate : bool.t)
      (result : F)
      : M ltac:(serde_json.error.Result T) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    let* validate := M.alloc validate in
    let* result := M.alloc result in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str_bytes
      {T F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (ref Self) * (ref (slice u8.t)))} :
    Notations.DoubleColon Self "parse_str_bytes" := {
    Notations.double_colon := parse_str_bytes (T := T) (F := F);
  }.
End Impl_serde_json_read_IoRead_t_R_4.
End Impl_serde_json_read_IoRead_t_R_4.

Module  Impl_serde_json_read_Read_for_serde_json_read_IoRead_t_R.
Section Impl_serde_json_read_Read_for_serde_json_read_IoRead_t_R.
  Context {R : Set}.
  
  Context {ℋ_0 : std.io.Read.Trait R}.
  
  Definition Self : Set := serde_json.read.IoRead.t R.
  
  (*
      fn next(&mut self) -> Result<Option<u8>> {
          match self.ch.take() {
              Some(ch) => {
                  #[cfg(feature = "raw_value")]
                  {
                      if let Some(buf) = &mut self.raw_buffer {
                          buf.push(ch);
                      }
                  }
                  Ok(Some(ch))
              }
              None => match self.iter.next() {
                  Some(Err(err)) => Err(Error::io(err)),
                  Some(Ok(ch)) => {
                      #[cfg(feature = "raw_value")]
                      {
                          if let Some(buf) = &mut self.raw_buffer {
                              buf.push(ch);
                          }
                      }
                      Ok(Some(ch))
                  }
                  None => Ok(None),
              },
          }
      }
  *)
  Definition next
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
      fn peek(&mut self) -> Result<Option<u8>> {
          match self.ch {
              Some(ch) => Ok(Some(ch)),
              None => match self.iter.next() {
                  Some(Err(err)) => Err(Error::io(err)),
                  Some(Ok(ch)) => {
                      self.ch = Some(ch);
                      Ok(self.ch)
                  }
                  None => Ok(None),
              },
          }
      }
  *)
  Definition peek
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
      fn discard(&mut self) {
          self.ch = None;
      }
  *)
  Definition discard (self : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_discard :
    Notations.DoubleColon Self "discard" := {
    Notations.double_colon := discard;
  }.
  
  (*
      fn position(&self) -> Position {
          Position {
              line: self.iter.line(),
              column: self.iter.col(),
          }
      }
  *)
  Definition position (self : ref Self) : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_position :
    Notations.DoubleColon Self "position" := {
    Notations.double_colon := position;
  }.
  
  (*
      fn peek_position(&self) -> Position {
          // The LineColIterator updates its position during peek() so it has the
          // right one here.
          self.position()
      }
  *)
  Definition peek_position (self : ref Self) : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek_position :
    Notations.DoubleColon Self "peek_position" := {
    Notations.double_colon := peek_position;
  }.
  
  (*
      fn byte_offset(&self) -> usize {
          match self.ch {
              Some(_) => self.iter.byte_offset() - 1,
              None => self.iter.byte_offset(),
          }
      }
  *)
  Definition byte_offset (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_byte_offset :
    Notations.DoubleColon Self "byte_offset" := {
    Notations.double_colon := byte_offset;
  }.
  
  (*
      fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> {
          self.parse_str_bytes(scratch, true, as_str)
              .map(Reference::Copied)
      }
  *)
  Definition parse_str
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      : M ltac:(serde_json.error.Result (serde_json.read.Reference.t str.t)) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str :
    Notations.DoubleColon Self "parse_str" := {
    Notations.double_colon := parse_str;
  }.
  
  (*
      fn parse_str_raw<'s>(
          &'s mut self,
          scratch: &'s mut Vec<u8>,
      ) -> Result<Reference<'de, 's, [u8]>> {
          self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))
              .map(Reference::Copied)
      }
  *)
  Definition parse_str_raw
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      :
        M
          ltac:(serde_json.error.Result
            (serde_json.read.Reference.t (slice u8.t))) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str_raw :
    Notations.DoubleColon Self "parse_str_raw" := {
    Notations.double_colon := parse_str_raw;
  }.
  
  (*
      fn ignore_str(&mut self) -> Result<()> {
          loop {
              let ch = tri!(next_or_eof(self));
              if !ESCAPE[ch as usize] {
                  continue;
              }
              match ch {
                  b'"' => {
                      return Ok(());
                  }
                  b'\\' => {
                      tri!(ignore_escape(self));
                  }
                  _ => {
                      return error(self, ErrorCode::ControlCharacterWhileParsingString);
                  }
              }
          }
      }
  "
  *)
  Definition ignore_str
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_ignore_str :
    Notations.DoubleColon Self "ignore_str" := {
    Notations.double_colon := ignore_str;
  }.
  
  (*
      fn decode_hex_escape(&mut self) -> Result<u16> {
          let mut n = 0;
          for _ in 0..4 {
              match decode_hex_val(tri!(next_or_eof(self))) {
                  None => return error(self, ErrorCode::InvalidEscape),
                  Some(val) => {
                      n = (n << 4) + val;
                  }
              }
          }
          Ok(n)
      }
  *)
  Definition decode_hex_escape
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result u16.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_decode_hex_escape :
    Notations.DoubleColon Self "decode_hex_escape" := {
    Notations.double_colon := decode_hex_escape;
  }.
  
  (*
      const should_early_return_if_failed: bool = true;
  *)
  
  Definition should_early_return_if_failed : bool.t := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_should_early_return_if_failed :
    Notations.DoubleColon Self "should_early_return_if_failed" := {
    Notations.double_colon := should_early_return_if_failed;
  }.
  
  (*
      fn set_failed(&mut self, failed: &mut bool) {
          *failed = true;
      }
  *)
  Definition set_failed
      (self : mut_ref Self)
      (failed : mut_ref bool.t)
      : M unit :=
    let* self := M.alloc self in
    let* failed := M.alloc failed in
    M.read foo.
  
  Global Instance AssociatedFunction_set_failed :
    Notations.DoubleColon Self "set_failed" := {
    Notations.double_colon := set_failed;
  }.
  
  Global Instance ℐ : serde_json.read.Read.Trait Self := {
    serde_json.read.Read.next := next;
    serde_json.read.Read.peek := peek;
    serde_json.read.Read.discard := discard;
    serde_json.read.Read.position := position;
    serde_json.read.Read.peek_position := peek_position;
    serde_json.read.Read.byte_offset := byte_offset;
    serde_json.read.Read.parse_str := parse_str;
    serde_json.read.Read.parse_str_raw := parse_str_raw;
    serde_json.read.Read.ignore_str := ignore_str;
    serde_json.read.Read.decode_hex_escape := decode_hex_escape;
    serde_json.read.Read.should_early_return_if_failed :=
      should_early_return_if_failed;
    serde_json.read.Read.set_failed := set_failed;
  }.
End Impl_serde_json_read_Read_for_serde_json_read_IoRead_t_R.
End Impl_serde_json_read_Read_for_serde_json_read_IoRead_t_R.

Module  Impl_serde_json_read_SliceRead_t_2.
Section Impl_serde_json_read_SliceRead_t_2.
  Definition Self : Set := serde_json.read.SliceRead.t.
  
  (*
      pub fn new(slice: &'a [u8]) -> Self {
          SliceRead {
              slice,
              index: 0,
              #[cfg(feature = "raw_value")]
              raw_buffering_start_index: 0,
          }
      }
  *)
  Definition new (slice : ref (slice u8.t)) : M Self :=
    let* slice := M.alloc slice in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn position_of_index(&self, i: usize) -> Position {
          let mut position = Position { line: 1, column: 0 };
          for ch in &self.slice[..i] {
              match *ch {
                  b'\n' => {
                      position.line += 1;
                      position.column = 0;
                  }
                  _ => {
                      position.column += 1;
                  }
              }
          }
          position
      }
  *)
  Definition position_of_index
      (self : ref Self)
      (i : usize.t)
      : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    let* i := M.alloc i in
    M.read foo.
  
  Global Instance AssociatedFunction_position_of_index :
    Notations.DoubleColon Self "position_of_index" := {
    Notations.double_colon := position_of_index;
  }.
  
  (*
      fn parse_str_bytes<'s, T, F>(
          &'s mut self,
          scratch: &'s mut Vec<u8>,
          validate: bool,
          result: F,
      ) -> Result<Reference<'a, 's, T>>
      where
          T: ?Sized + 's,
          F: for<'f> FnOnce(&'s Self, &'f [u8]) -> Result<&'f T>,
      {
          // Index of the first byte not yet copied into the scratch space.
          let mut start = self.index;
  
          loop {
              while self.index < self.slice.len() && !ESCAPE[self.slice[self.index] as usize] {
                  self.index += 1;
              }
              if self.index == self.slice.len() {
                  return error(self, ErrorCode::EofWhileParsingString);
              }
              match self.slice[self.index] {
                  b'"' => {
                      if scratch.is_empty() {
                          // Fast path: return a slice of the raw JSON without any
                          // copying.
                          let borrowed = &self.slice[start..self.index];
                          self.index += 1;
                          return result(self, borrowed).map(Reference::Borrowed);
                      } else {
                          scratch.extend_from_slice(&self.slice[start..self.index]);
                          self.index += 1;
                          return result(self, scratch).map(Reference::Copied);
                      }
                  }
                  b'\\' => {
                      scratch.extend_from_slice(&self.slice[start..self.index]);
                      self.index += 1;
                      tri!(parse_escape(self, validate, scratch));
                      start = self.index;
                  }
                  _ => {
                      self.index += 1;
                      if validate {
                          return error(self, ErrorCode::ControlCharacterWhileParsingString);
                      }
                  }
              }
          }
      }
  "
  *)
  Definition parse_str_bytes
      {T F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (ref Self) * (ref (slice u8.t)))}
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      (validate : bool.t)
      (result : F)
      : M ltac:(serde_json.error.Result (serde_json.read.Reference.t T)) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    let* validate := M.alloc validate in
    let* result := M.alloc result in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str_bytes
      {T F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (ref Self) * (ref (slice u8.t)))} :
    Notations.DoubleColon Self "parse_str_bytes" := {
    Notations.double_colon := parse_str_bytes (T := T) (F := F);
  }.
End Impl_serde_json_read_SliceRead_t_2.
End Impl_serde_json_read_SliceRead_t_2.

Module  Impl_serde_json_read_private_Sealed_for_serde_json_read_SliceRead_t.
Section Impl_serde_json_read_private_Sealed_for_serde_json_read_SliceRead_t.
  Definition Self : Set := serde_json.read.SliceRead.t.
  
  Global Instance ℐ : serde_json.read.private.Sealed.Trait Self := {
  }.
End Impl_serde_json_read_private_Sealed_for_serde_json_read_SliceRead_t.
End Impl_serde_json_read_private_Sealed_for_serde_json_read_SliceRead_t.

Module  Impl_serde_json_read_Read_for_serde_json_read_SliceRead_t.
Section Impl_serde_json_read_Read_for_serde_json_read_SliceRead_t.
  Definition Self : Set := serde_json.read.SliceRead.t.
  
  (*
      fn next(&mut self) -> Result<Option<u8>> {
          // `Ok(self.slice.get(self.index).map(|ch| { self.index += 1; *ch }))`
          // is about 10% slower.
          Ok(if self.index < self.slice.len() {
              let ch = self.slice[self.index];
              self.index += 1;
              Some(ch)
          } else {
              None
          })
      }
  *)
  Definition next
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
      fn peek(&mut self) -> Result<Option<u8>> {
          // `Ok(self.slice.get(self.index).map(|ch| *ch))` is about 10% slower
          // for some reason.
          Ok(if self.index < self.slice.len() {
              Some(self.slice[self.index])
          } else {
              None
          })
      }
  *)
  Definition peek
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
      fn discard(&mut self) {
          self.index += 1;
      }
  *)
  Definition discard (self : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_discard :
    Notations.DoubleColon Self "discard" := {
    Notations.double_colon := discard;
  }.
  
  (*
      fn position(&self) -> Position {
          self.position_of_index(self.index)
      }
  *)
  Definition position (self : ref Self) : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_position :
    Notations.DoubleColon Self "position" := {
    Notations.double_colon := position;
  }.
  
  (*
      fn peek_position(&self) -> Position {
          // Cap it at slice.len() just in case the most recent call was next()
          // and it returned the last byte.
          self.position_of_index(cmp::min(self.slice.len(), self.index + 1))
      }
  *)
  Definition peek_position (self : ref Self) : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek_position :
    Notations.DoubleColon Self "peek_position" := {
    Notations.double_colon := peek_position;
  }.
  
  (*
      fn byte_offset(&self) -> usize {
          self.index
      }
  *)
  Definition byte_offset (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_byte_offset :
    Notations.DoubleColon Self "byte_offset" := {
    Notations.double_colon := byte_offset;
  }.
  
  (*
      fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {
          self.parse_str_bytes(scratch, true, as_str)
      }
  *)
  Definition parse_str
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      : M ltac:(serde_json.error.Result (serde_json.read.Reference.t str.t)) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str :
    Notations.DoubleColon Self "parse_str" := {
    Notations.double_colon := parse_str;
  }.
  
  (*
      fn parse_str_raw<'s>(
          &'s mut self,
          scratch: &'s mut Vec<u8>,
      ) -> Result<Reference<'a, 's, [u8]>> {
          self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))
      }
  *)
  Definition parse_str_raw
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      :
        M
          ltac:(serde_json.error.Result
            (serde_json.read.Reference.t (slice u8.t))) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str_raw :
    Notations.DoubleColon Self "parse_str_raw" := {
    Notations.double_colon := parse_str_raw;
  }.
  
  (*
      fn ignore_str(&mut self) -> Result<()> {
          loop {
              while self.index < self.slice.len() && !ESCAPE[self.slice[self.index] as usize] {
                  self.index += 1;
              }
              if self.index == self.slice.len() {
                  return error(self, ErrorCode::EofWhileParsingString);
              }
              match self.slice[self.index] {
                  b'"' => {
                      self.index += 1;
                      return Ok(());
                  }
                  b'\\' => {
                      self.index += 1;
                      tri!(ignore_escape(self));
                  }
                  _ => {
                      return error(self, ErrorCode::ControlCharacterWhileParsingString);
                  }
              }
          }
      }
  "
  *)
  Definition ignore_str
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_ignore_str :
    Notations.DoubleColon Self "ignore_str" := {
    Notations.double_colon := ignore_str;
  }.
  
  (*
      fn decode_hex_escape(&mut self) -> Result<u16> {
          if self.index + 4 > self.slice.len() {
              self.index = self.slice.len();
              return error(self, ErrorCode::EofWhileParsingString);
          }
  
          let mut n = 0;
          for _ in 0..4 {
              let ch = decode_hex_val(self.slice[self.index]);
              self.index += 1;
              match ch {
                  None => return error(self, ErrorCode::InvalidEscape),
                  Some(val) => {
                      n = (n << 4) + val;
                  }
              }
          }
          Ok(n)
      }
  *)
  Definition decode_hex_escape
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result u16.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_decode_hex_escape :
    Notations.DoubleColon Self "decode_hex_escape" := {
    Notations.double_colon := decode_hex_escape;
  }.
  
  (*
      const should_early_return_if_failed: bool = false;
  *)
  
  Definition should_early_return_if_failed : bool.t := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_should_early_return_if_failed :
    Notations.DoubleColon Self "should_early_return_if_failed" := {
    Notations.double_colon := should_early_return_if_failed;
  }.
  
  (*
      fn set_failed(&mut self, _failed: &mut bool) {
          self.slice = &self.slice[..self.index];
      }
  *)
  Definition set_failed
      (self : mut_ref Self)
      (_failed : mut_ref bool.t)
      : M unit :=
    let* self := M.alloc self in
    let* _failed := M.alloc _failed in
    M.read foo.
  
  Global Instance AssociatedFunction_set_failed :
    Notations.DoubleColon Self "set_failed" := {
    Notations.double_colon := set_failed;
  }.
  
  Global Instance ℐ : serde_json.read.Read.Trait Self := {
    serde_json.read.Read.next := next;
    serde_json.read.Read.peek := peek;
    serde_json.read.Read.discard := discard;
    serde_json.read.Read.position := position;
    serde_json.read.Read.peek_position := peek_position;
    serde_json.read.Read.byte_offset := byte_offset;
    serde_json.read.Read.parse_str := parse_str;
    serde_json.read.Read.parse_str_raw := parse_str_raw;
    serde_json.read.Read.ignore_str := ignore_str;
    serde_json.read.Read.decode_hex_escape := decode_hex_escape;
    serde_json.read.Read.should_early_return_if_failed :=
      should_early_return_if_failed;
    serde_json.read.Read.set_failed := set_failed;
  }.
End Impl_serde_json_read_Read_for_serde_json_read_SliceRead_t.
End Impl_serde_json_read_Read_for_serde_json_read_SliceRead_t.

Module  Impl_serde_json_read_StrRead_t_2.
Section Impl_serde_json_read_StrRead_t_2.
  Definition Self : Set := serde_json.read.StrRead.t.
  
  (*
      pub fn new(s: &'a str) -> Self {
          StrRead {
              delegate: SliceRead::new(s.as_bytes()),
              #[cfg(feature = "raw_value")]
              data: s,
          }
      }
  *)
  Definition new (s : ref str.t) : M Self :=
    let* s := M.alloc s in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_serde_json_read_StrRead_t_2.
End Impl_serde_json_read_StrRead_t_2.

Module  Impl_serde_json_read_private_Sealed_for_serde_json_read_StrRead_t.
Section Impl_serde_json_read_private_Sealed_for_serde_json_read_StrRead_t.
  Definition Self : Set := serde_json.read.StrRead.t.
  
  Global Instance ℐ : serde_json.read.private.Sealed.Trait Self := {
  }.
End Impl_serde_json_read_private_Sealed_for_serde_json_read_StrRead_t.
End Impl_serde_json_read_private_Sealed_for_serde_json_read_StrRead_t.

Module  Impl_serde_json_read_Read_for_serde_json_read_StrRead_t.
Section Impl_serde_json_read_Read_for_serde_json_read_StrRead_t.
  Definition Self : Set := serde_json.read.StrRead.t.
  
  (*
      fn next(&mut self) -> Result<Option<u8>> {
          self.delegate.next()
      }
  *)
  Definition next
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
      fn peek(&mut self) -> Result<Option<u8>> {
          self.delegate.peek()
      }
  *)
  Definition peek
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
      fn discard(&mut self) {
          self.delegate.discard();
      }
  *)
  Definition discard (self : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_discard :
    Notations.DoubleColon Self "discard" := {
    Notations.double_colon := discard;
  }.
  
  (*
      fn position(&self) -> Position {
          self.delegate.position()
      }
  *)
  Definition position (self : ref Self) : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_position :
    Notations.DoubleColon Self "position" := {
    Notations.double_colon := position;
  }.
  
  (*
      fn peek_position(&self) -> Position {
          self.delegate.peek_position()
      }
  *)
  Definition peek_position (self : ref Self) : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek_position :
    Notations.DoubleColon Self "peek_position" := {
    Notations.double_colon := peek_position;
  }.
  
  (*
      fn byte_offset(&self) -> usize {
          self.delegate.byte_offset()
      }
  *)
  Definition byte_offset (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_byte_offset :
    Notations.DoubleColon Self "byte_offset" := {
    Notations.double_colon := byte_offset;
  }.
  
  (*
      fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {
          self.delegate.parse_str_bytes(scratch, true, |_, bytes| {
              // The deserialization input came in as &str with a UTF-8 guarantee,
              // and the \u-escapes are checked along the way, so don't need to
              // check here.
              Ok(unsafe { str::from_utf8_unchecked(bytes) })
          })
      }
  *)
  Definition parse_str
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      : M ltac:(serde_json.error.Result (serde_json.read.Reference.t str.t)) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str :
    Notations.DoubleColon Self "parse_str" := {
    Notations.double_colon := parse_str;
  }.
  
  (*
      fn parse_str_raw<'s>(
          &'s mut self,
          scratch: &'s mut Vec<u8>,
      ) -> Result<Reference<'a, 's, [u8]>> {
          self.delegate.parse_str_raw(scratch)
      }
  *)
  Definition parse_str_raw
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      :
        M
          ltac:(serde_json.error.Result
            (serde_json.read.Reference.t (slice u8.t))) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str_raw :
    Notations.DoubleColon Self "parse_str_raw" := {
    Notations.double_colon := parse_str_raw;
  }.
  
  (*
      fn ignore_str(&mut self) -> Result<()> {
          self.delegate.ignore_str()
      }
  *)
  Definition ignore_str
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_ignore_str :
    Notations.DoubleColon Self "ignore_str" := {
    Notations.double_colon := ignore_str;
  }.
  
  (*
      fn decode_hex_escape(&mut self) -> Result<u16> {
          self.delegate.decode_hex_escape()
      }
  *)
  Definition decode_hex_escape
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result u16.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_decode_hex_escape :
    Notations.DoubleColon Self "decode_hex_escape" := {
    Notations.double_colon := decode_hex_escape;
  }.
  
  (*
      const should_early_return_if_failed: bool = false;
  *)
  
  Definition should_early_return_if_failed : bool.t := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_should_early_return_if_failed :
    Notations.DoubleColon Self "should_early_return_if_failed" := {
    Notations.double_colon := should_early_return_if_failed;
  }.
  
  (*
      fn set_failed(&mut self, failed: &mut bool) {
          self.delegate.set_failed(failed);
      }
  *)
  Definition set_failed
      (self : mut_ref Self)
      (failed : mut_ref bool.t)
      : M unit :=
    let* self := M.alloc self in
    let* failed := M.alloc failed in
    M.read foo.
  
  Global Instance AssociatedFunction_set_failed :
    Notations.DoubleColon Self "set_failed" := {
    Notations.double_colon := set_failed;
  }.
  
  Global Instance ℐ : serde_json.read.Read.Trait Self := {
    serde_json.read.Read.next := next;
    serde_json.read.Read.peek := peek;
    serde_json.read.Read.discard := discard;
    serde_json.read.Read.position := position;
    serde_json.read.Read.peek_position := peek_position;
    serde_json.read.Read.byte_offset := byte_offset;
    serde_json.read.Read.parse_str := parse_str;
    serde_json.read.Read.parse_str_raw := parse_str_raw;
    serde_json.read.Read.ignore_str := ignore_str;
    serde_json.read.Read.decode_hex_escape := decode_hex_escape;
    serde_json.read.Read.should_early_return_if_failed :=
      should_early_return_if_failed;
    serde_json.read.Read.set_failed := set_failed;
  }.
End Impl_serde_json_read_Read_for_serde_json_read_StrRead_t.
End Impl_serde_json_read_Read_for_serde_json_read_StrRead_t.

Module  Impl_serde_json_read_private_Sealed_for_mut_ref_R.
Section Impl_serde_json_read_private_Sealed_for_mut_ref_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := mut_ref R.
  
  Global Instance ℐ : serde_json.read.private.Sealed.Trait Self := {
  }.
End Impl_serde_json_read_private_Sealed_for_mut_ref_R.
End Impl_serde_json_read_private_Sealed_for_mut_ref_R.

Module  Impl_serde_json_read_Read_for_mut_ref_R.
Section Impl_serde_json_read_Read_for_mut_ref_R.
  Context {R : Set}.
  
  Context {ℋ_0 : serde_json.read.Read.Trait R}.
  
  Definition Self : Set := mut_ref R.
  
  (*
      fn next(&mut self) -> Result<Option<u8>> {
          R::next(self)
      }
  *)
  Definition next
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
      fn peek(&mut self) -> Result<Option<u8>> {
          R::peek(self)
      }
  *)
  Definition peek
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result (core.option.Option.t u8.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
      fn discard(&mut self) {
          R::discard(self);
      }
  *)
  Definition discard (self : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_discard :
    Notations.DoubleColon Self "discard" := {
    Notations.double_colon := discard;
  }.
  
  (*
      fn position(&self) -> Position {
          R::position(self)
      }
  *)
  Definition position (self : ref Self) : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_position :
    Notations.DoubleColon Self "position" := {
    Notations.double_colon := position;
  }.
  
  (*
      fn peek_position(&self) -> Position {
          R::peek_position(self)
      }
  *)
  Definition peek_position (self : ref Self) : M serde_json.read.Position.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_peek_position :
    Notations.DoubleColon Self "peek_position" := {
    Notations.double_colon := peek_position;
  }.
  
  (*
      fn byte_offset(&self) -> usize {
          R::byte_offset(self)
      }
  *)
  Definition byte_offset (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_byte_offset :
    Notations.DoubleColon Self "byte_offset" := {
    Notations.double_colon := byte_offset;
  }.
  
  (*
      fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> {
          R::parse_str(self, scratch)
      }
  *)
  Definition parse_str
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      : M ltac:(serde_json.error.Result (serde_json.read.Reference.t str.t)) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str :
    Notations.DoubleColon Self "parse_str" := {
    Notations.double_colon := parse_str;
  }.
  
  (*
      fn parse_str_raw<'s>(
          &'s mut self,
          scratch: &'s mut Vec<u8>,
      ) -> Result<Reference<'de, 's, [u8]>> {
          R::parse_str_raw(self, scratch)
      }
  *)
  Definition parse_str_raw
      (self : mut_ref Self)
      (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
      :
        M
          ltac:(serde_json.error.Result
            (serde_json.read.Reference.t (slice u8.t))) :=
    let* self := M.alloc self in
    let* scratch := M.alloc scratch in
    M.read foo.
  
  Global Instance AssociatedFunction_parse_str_raw :
    Notations.DoubleColon Self "parse_str_raw" := {
    Notations.double_colon := parse_str_raw;
  }.
  
  (*
      fn ignore_str(&mut self) -> Result<()> {
          R::ignore_str(self)
      }
  *)
  Definition ignore_str
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_ignore_str :
    Notations.DoubleColon Self "ignore_str" := {
    Notations.double_colon := ignore_str;
  }.
  
  (*
      fn decode_hex_escape(&mut self) -> Result<u16> {
          R::decode_hex_escape(self)
      }
  *)
  Definition decode_hex_escape
      (self : mut_ref Self)
      : M ltac:(serde_json.error.Result u16.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_decode_hex_escape :
    Notations.DoubleColon Self "decode_hex_escape" := {
    Notations.double_colon := decode_hex_escape;
  }.
  
  (*
      const should_early_return_if_failed: bool = R::should_early_return_if_failed;
  *)
  
  Definition should_early_return_if_failed : bool.t := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_should_early_return_if_failed :
    Notations.DoubleColon Self "should_early_return_if_failed" := {
    Notations.double_colon := should_early_return_if_failed;
  }.
  
  (*
      fn set_failed(&mut self, failed: &mut bool) {
          R::set_failed(self, failed);
      }
  *)
  Definition set_failed
      (self : mut_ref Self)
      (failed : mut_ref bool.t)
      : M unit :=
    let* self := M.alloc self in
    let* failed := M.alloc failed in
    M.read foo.
  
  Global Instance AssociatedFunction_set_failed :
    Notations.DoubleColon Self "set_failed" := {
    Notations.double_colon := set_failed;
  }.
  
  Global Instance ℐ : serde_json.read.Read.Trait Self := {
    serde_json.read.Read.next := next;
    serde_json.read.Read.peek := peek;
    serde_json.read.Read.discard := discard;
    serde_json.read.Read.position := position;
    serde_json.read.Read.peek_position := peek_position;
    serde_json.read.Read.byte_offset := byte_offset;
    serde_json.read.Read.parse_str := parse_str;
    serde_json.read.Read.parse_str_raw := parse_str_raw;
    serde_json.read.Read.ignore_str := ignore_str;
    serde_json.read.Read.decode_hex_escape := decode_hex_escape;
    serde_json.read.Read.should_early_return_if_failed :=
      should_early_return_if_failed;
    serde_json.read.Read.set_failed := set_failed;
  }.
End Impl_serde_json_read_Read_for_mut_ref_R.
End Impl_serde_json_read_Read_for_mut_ref_R.

Module  Fused.
Section Fused.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: serde_json.read.private.Sealed.Trait Self;
  }.
  
End Fused.
End Fused.

Module  Impl_serde_json_read_Fused_for_serde_json_read_SliceRead_t.
Section Impl_serde_json_read_Fused_for_serde_json_read_SliceRead_t.
  Definition Self : Set := serde_json.read.SliceRead.t.
  
  Global Instance ℐ : serde_json.read.Fused.Trait Self := {
  }.
End Impl_serde_json_read_Fused_for_serde_json_read_SliceRead_t.
End Impl_serde_json_read_Fused_for_serde_json_read_SliceRead_t.

Module  Impl_serde_json_read_Fused_for_serde_json_read_StrRead_t.
Section Impl_serde_json_read_Fused_for_serde_json_read_StrRead_t.
  Definition Self : Set := serde_json.read.StrRead.t.
  
  Global Instance ℐ : serde_json.read.Fused.Trait Self := {
  }.
End Impl_serde_json_read_Fused_for_serde_json_read_StrRead_t.
End Impl_serde_json_read_Fused_for_serde_json_read_StrRead_t.

Definition ESCAPE : M.Val (ref (array bool.t)) := M.run (M.alloc foo).

Definition CT : M.Val bool.t := M.run (M.pure foo).

Definition QU : M.Val bool.t := M.run (M.pure foo).

Definition BS : M.Val bool.t := M.run (M.pure foo).

Definition __ : M.Val bool.t := M.run (M.pure foo).

(*
fn next_or_eof<'de, R>(read: &mut R) -> Result<u8>
where
    R: ?Sized + Read<'de>,
{
    match tri!(read.next()) {
        Some(b) => Ok(b),
        None => error(read, ErrorCode::EofWhileParsingString),
    }
}
*)
Definition next_or_eof
    {R : Set}
    {ℋ_0 : serde_json.read.Read.Trait R}
    (read : mut_ref R)
    : M ltac:(serde_json.error.Result u8.t) :=
  let* read := M.alloc read in
  M.read foo.

(*
fn peek_or_eof<'de, R>(read: &mut R) -> Result<u8>
where
    R: ?Sized + Read<'de>,
{
    match tri!(read.peek()) {
        Some(b) => Ok(b),
        None => error(read, ErrorCode::EofWhileParsingString),
    }
}
*)
Definition peek_or_eof
    {R : Set}
    {ℋ_0 : serde_json.read.Read.Trait R}
    (read : mut_ref R)
    : M ltac:(serde_json.error.Result u8.t) :=
  let* read := M.alloc read in
  M.read foo.

(*
fn error<'de, R, T>(read: &R, reason: ErrorCode) -> Result<T>
where
    R: ?Sized + Read<'de>,
{
    let position = read.position();
    Err(Error::syntax(reason, position.line, position.column))
}
*)
Definition error
    {R T : Set}
    {ℋ_0 : serde_json.read.Read.Trait R}
    (read : ref R)
    (reason : serde_json.error.ErrorCode.t)
    : M ltac:(serde_json.error.Result T) :=
  let* read := M.alloc read in
  let* reason := M.alloc reason in
  M.read foo.

(*
fn as_str<'de, 's, R: Read<'de>>(read: &R, slice: &'s [u8]) -> Result<&'s str> {
    str::from_utf8(slice).or_else(|_| error(read, ErrorCode::InvalidUnicodeCodePoint))
}
*)
Definition as_str
    {R : Set}
    {ℋ_0 : serde_json.read.Read.Trait R}
    (read : ref R)
    (slice : ref (slice u8.t))
    : M ltac:(serde_json.error.Result (ref str.t)) :=
  let* read := M.alloc read in
  let* slice := M.alloc slice in
  M.read foo.

(*
fn parse_escape<'de, R: Read<'de>>(
    read: &mut R,
    validate: bool,
    scratch: &mut Vec<u8>,
) -> Result<()> {
    let ch = tri!(next_or_eof(read));

    match ch {
        b'"' => scratch.push(b'"'),
        b'\\' => scratch.push(b'\\'),
        b'/' => scratch.push(b'/'),
        b'b' => scratch.push(b'\x08'),
        b'f' => scratch.push(b'\x0c'),
        b'n' => scratch.push(b'\n'),
        b'r' => scratch.push(b'\r'),
        b't' => scratch.push(b'\t'),
        b'u' => {
            fn encode_surrogate(scratch: &mut Vec<u8>, n: u16) {
                scratch.extend_from_slice(&[
                    (n >> 12 & 0b0000_1111) as u8 | 0b1110_0000,
                    (n >> 6 & 0b0011_1111) as u8 | 0b1000_0000,
                    (n & 0b0011_1111) as u8 | 0b1000_0000,
                ]);
            }

            let c = match tri!(read.decode_hex_escape()) {
                n @ 0xDC00..=0xDFFF => {
                    return if validate {
                        error(read, ErrorCode::LoneLeadingSurrogateInHexEscape)
                    } else {
                        encode_surrogate(scratch, n);
                        Ok(())
                    };
                }

                // Non-BMP characters are encoded as a sequence of two hex
                // escapes, representing UTF-16 surrogates. If deserializing a
                // utf-8 string the surrogates are required to be paired,
                // whereas deserializing a byte string accepts lone surrogates.
                n1 @ 0xD800..=0xDBFF => {
                    if tri!(peek_or_eof(read)) == b'\\' {
                        read.discard();
                    } else {
                        return if validate {
                            read.discard();
                            error(read, ErrorCode::UnexpectedEndOfHexEscape)
                        } else {
                            encode_surrogate(scratch, n1);
                            Ok(())
                        };
                    }

                    if tri!(peek_or_eof(read)) == b'u' {
                        read.discard();
                    } else {
                        return if validate {
                            read.discard();
                            error(read, ErrorCode::UnexpectedEndOfHexEscape)
                        } else {
                            encode_surrogate(scratch, n1);
                            // The \ prior to this byte started an escape sequence,
                            // so we need to parse that now. This recursive call
                            // does not blow the stack on malicious input because
                            // the escape is not \u, so it will be handled by one
                            // of the easy nonrecursive cases.
                            parse_escape(read, validate, scratch)
                        };
                    }

                    let n2 = tri!(read.decode_hex_escape());

                    if n2 < 0xDC00 || n2 > 0xDFFF {
                        return error(read, ErrorCode::LoneLeadingSurrogateInHexEscape);
                    }

                    let n = (((n1 - 0xD800) as u32) << 10 | (n2 - 0xDC00) as u32) + 0x1_0000;

                    match char::from_u32(n) {
                        Some(c) => c,
                        None => {
                            return error(read, ErrorCode::InvalidUnicodeCodePoint);
                        }
                    }
                }

                // Every u16 outside of the surrogate ranges above is guaranteed
                // to be a legal char.
                n => char::from_u32(n as u32).unwrap(),
            };

            scratch.extend_from_slice(c.encode_utf8(&mut [0_u8; 4]).as_bytes());
        }
        _ => {
            return error(read, ErrorCode::InvalidEscape);
        }
    }

    Ok(())
}
*)
Definition parse_escape
    {R : Set}
    {ℋ_0 : serde_json.read.Read.Trait R}
    (read : mut_ref R)
    (validate : bool.t)
    (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
    : M ltac:(serde_json.error.Result unit) :=
  let* read := M.alloc read in
  let* validate := M.alloc validate in
  let* scratch := M.alloc scratch in
  M.read foo.

(*
            fn encode_surrogate(scratch: &mut Vec<u8>, n: u16) {
                scratch.extend_from_slice(&[
                    (n >> 12 & 0b0000_1111) as u8 | 0b1110_0000,
                    (n >> 6 & 0b0011_1111) as u8 | 0b1000_0000,
                    (n & 0b0011_1111) as u8 | 0b1000_0000,
                ]);
            }
*)
Definition encode_surrogate
    (scratch : mut_ref (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
    (n : u16.t)
    : M unit :=
  let* scratch := M.alloc scratch in
  let* n := M.alloc n in
  M.read foo.

(*
fn ignore_escape<'de, R>(read: &mut R) -> Result<()>
where
    R: ?Sized + Read<'de>,
{
    let ch = tri!(next_or_eof(read));

    match ch {
        b'"' | b'\\' | b'/' | b'b' | b'f' | b'n' | b'r' | b't' => {}
        b'u' => {
            // At this point we don't care if the codepoint is valid. We just
            // want to consume it. We don't actually know what is valid or not
            // at this point, because that depends on if this string will
            // ultimately be parsed into a string or a byte buffer in the "real"
            // parse.

            tri!(read.decode_hex_escape());
        }
        _ => {
            return error(read, ErrorCode::InvalidEscape);
        }
    }

    Ok(())
}
"
*)
Definition ignore_escape
    {R : Set}
    {ℋ_0 : serde_json.read.Read.Trait R}
    (read : mut_ref R)
    : M ltac:(serde_json.error.Result unit) :=
  let* read := M.alloc read in
  M.read foo.

Definition HEX : M.Val (ref (array u8.t)) := M.run (M.alloc foo).

(*
fn decode_hex_val(val: u8) -> Option<u16> {
    let n = HEX[val as usize] as u16;
    if n == 255 {
        None
    } else {
        Some(n)
    }
}
*)
Definition decode_hex_val (val : u8.t) : M (core.option.Option.t u16.t) :=
  let* val := M.alloc val in
  M.read foo.
